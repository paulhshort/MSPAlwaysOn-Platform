This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
__init__.py
agent.py
auth/__init__.py
auth/m365_auth.py
auth/README.md
config.py
context_enhancement.py
context.py
cw_tools/__init__.py
cw_tools/activity.py
cw_tools/api_client.py
cw_tools/context_tools.py
cw_tools/cw_tools_main.py
cw_tools/error_handling.py
cw_tools/member_utils.py
cw_tools/models.py
cw_tools/README.md
cw_tools/tool_adapter.py
experimental/api_updated.py
experimental/chat_enhancements.py
experimental/README.md
main.py
routes/__init__.py
routes/api.py
routes/generate.py
routes/search.py
routes/suggestions.py
user_context.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__init__.py">
# This file makes the 'app' directory a Python package.
</file>

<file path="agent.py">
import logging
from typing import List, Optional, Any, Callable, Type, cast
from openai import AsyncOpenAI # type: ignore


import app.config as config
import app.cw_tools as cw  # import as cw for brevity in referring to tools
# No need to import tool_adapter as we're using the decorated tools directly

# Define variables before try block with placeholder type hints
Agent: Optional[Type[Any]] = None
ToolContext: Optional[Type[Any]] = None
OpenAIResponsesModel: Optional[Type[Any]] = None
FunctionTool: Optional[Type[Any]] = None # Add placeholder for FunctionTool
_HAS_AGENT_SDK = False

# Import the OpenAI Agents SDK Agent class
try:
    from agents import Agent as _AgentSDK # type: ignore # Use the SDK's Agent
    from agents import OpenAIResponsesModel as _OpenAIResponsesModelSDK # type: ignore
    from agents.tool import FunctionTool as _FunctionToolSDK # type: ignore # Import FunctionTool
    # Import the context class defined in cw_tools
    from app.cw_tools import ToolContext as _ToolContextCW

    # Assign imported types to variables
    Agent = _AgentSDK
    ToolContext = _ToolContextCW
    OpenAIResponsesModel = _OpenAIResponsesModelSDK
    FunctionTool = _FunctionToolSDK # Assign FunctionTool
    _HAS_AGENT_SDK = True

    # We'll patch the agent instance when it's created in get_connectwise_agent

except ImportError:
    # Variables remain None
    logging.critical("OpenAI Agents SDK ('agents' module) or cw_tools.ToolContext not found. Please ensure it is installed.")


# --- Dynamic Model Selection (Adapted from Streamlit version) ---

def get_agent_model(selected_model_identifier: str) -> Optional[Any]: # Return Optional[Any]
    """
    Initializes and returns the appropriate agent model based on the identifier.
    Example identifiers: "openai/gpt-4o", "openrouter/openai/gpt-4o"
    """
    if not OpenAIResponsesModel: # Check if type is available
        logging.error("OpenAIResponsesModel type not available due to SDK import failure.")
        return None

    logger.info(f"Attempting to initialize agent model for: {selected_model_identifier}")
    provider = selected_model_identifier.split('/')[0]
    # Handle potential nested names like 'openrouter/google/gemini-pro'
    model_name = "/".join(selected_model_identifier.split('/')[1:])

    if provider == "openai":
        if not config.OPENAI_API_KEY:
            logger.error("OpenAI API key missing, cannot initialize OpenAI model.")
            return None
        try:
            # Use AsyncOpenAI for the SDK's expected client type
            client = AsyncOpenAI(api_key=config.OPENAI_API_KEY, timeout=60.0, max_retries=2)
            # Ensure the model name doesn't include the provider prefix for OpenAI
            openai_model_name = model_name.split('/')[-1]
            model = OpenAIResponsesModel(openai_client=client, model=openai_model_name)
            logger.info(f"OpenAI model configured: {openai_model_name}")
            return model
        except Exception as e:
            logger.error(f"Failed to configure OpenAI model '{model_name}': {e}", exc_info=True)
            return None
    elif provider == "openrouter":
        if not config.OPENROUTER_API_KEY:
            logger.error("OpenRouter API key missing, cannot initialize OpenRouter model.")
            return None
        try:
            # OpenRouter requires a different base_url but can use the same client
            client = AsyncOpenAI(
                api_key=config.OPENROUTER_API_KEY,
                base_url="https://openrouter.ai/api/v1",
                timeout=60.0,
                max_retries=2
            )
            # Use the full model name (including provider prefix) for OpenRouter
            model = OpenAIResponsesModel(openai_client=client, model=model_name)
            logger.info(f"OpenRouter model configured: {model_name}")
            return model
        except Exception as e:
            logger.error(f"Failed to configure OpenRouter model '{model_name}': {e}", exc_info=True)
            return None
    else:
        logger.error(f"Unsupported model provider: {provider}")
        return None


# Remove old framework imports like OpenAIResponsesModel, FunctionTool, RunContextWrapper
logger = logging.getLogger(__name__)

# The SDK's Agent class handles client initialization based on environment variables (OPENAI_API_KEY)
# and the model name provided. No need for the get_agent_model helper.
# Ensure OPENAI_API_KEY is set in the environment (e.g., via .env and python-dotenv).
# If using OpenRouter, the SDK might require specific configuration or the base OpenAI client
# might need to be configured globally or passed differently. For now, assume standard OpenAI.

# Aggregate all available tool functions (as callables) for the agent to use

# List the available tool functions directly (decorated with @function_tool in cw_tools.py)
# The SDK will inspect these functions.
available_tools: List[Callable] = []
if cw:
    # Check each tool function exists before adding
    tool_functions = [
        getattr(cw, 'get_ticket_details', None),
        getattr(cw, 'add_ticket_note', None),
        getattr(cw, 'change_ticket_status', None),
        getattr(cw, 'create_new_ticket', None),
        getattr(cw, 'close_ticket', None),
        getattr(cw, 'list_service_boards', None),
        getattr(cw, 'list_ticket_statuses', None),
        getattr(cw, 'find_company', None),
        getattr(cw, 'find_contact', None),
        getattr(cw, 'find_member', None),
        getattr(cw, 'add_time_entry', None),
        getattr(cw, 'update_ticket_company', None),
        getattr(cw, 'update_ticket_owner', None),
        getattr(cw, 'list_ticket_priorities', None),
        getattr(cw, 'update_ticket_summary', None),
        getattr(cw, 'update_ticket_priority', None),
        # New tools
        getattr(cw, 'assign_resource_to_ticket', None),
        getattr(cw, 'remove_resource_from_ticket', None),
        getattr(cw, 'create_contact', None),
        getattr(cw, 'move_ticket_to_board', None),
        getattr(cw, 'get_ticket_attachments', None),
        getattr(cw, 'search_tickets_tool', None),
        # Add other tools here if they exist in cw_tools
    ]
    # Filter out any None values if a tool function wasn't found
    raw_tools = [tool for tool in tool_functions if tool is not None]

    # Use the raw tools directly - they are already properly decorated with @function_tool
    available_tools = raw_tools

    if len(available_tools) != len(tool_functions):
         logger.warning("Some ConnectWise tool functions were not found or loaded from cw_tools module.")
else:
    logger.error("cw_tools module not loaded. No tools available.")
# Cache for the created agent instance (simple singleton pattern)
_agent_instance: Optional[Any] = None # Use Any as Agent might be None

def get_connectwise_agent() -> Optional[Any]: # Return Optional[Any]
    """
    Creates and returns a singleton instance of the ConnectWise Agent using the SDK.
    Reads configuration from app.config.
    """
    global _agent_instance
    if _agent_instance:
        return _agent_instance

    # Check if SDK and necessary types were imported successfully
    if not _HAS_AGENT_SDK or Agent is None or ToolContext is None or FunctionTool is None:
        logger.critical("OpenAI Agents SDK or required types (Agent, ToolContext, FunctionTool) are not available; cannot create agent instance.")
        return None

    if not available_tools:
         logger.warning("No ConnectWise tools are available to the agent. Creating agent without tools.")
         # Allow agent creation even without tools, might be useful for basic chat

    # Construct the full model identifier (adjust if config structure differs)
    # Example: "openai/gpt-4o" or "openrouter/openai/gpt-4o"
    model_identifier = f"{config.DEFAULT_MODEL_PROVIDER}/{config.PRIMARY_MODEL}"
    logger.info(f"Attempting to initialize agent with model identifier: {model_identifier}")

    agent_model = get_agent_model(model_identifier) # Call the dynamic model loader

    if not agent_model:
         logger.error(f"Failed to get agent model for identifier: {model_identifier}")
         return None

    try:
        # Cast tools list to the expected type for the Agent constructor
        # This assumes all tools are FunctionTools for now. Adjust if other tool types are used.
        typed_tools = cast(List[FunctionTool], available_tools) # type: ignore[valid-type] # Suppress Mypy/Pylance error

        # Create the agent instance using the dynamically loaded model
        agent_instance = Agent[ToolContext]( # Specify context type using the imported ToolContext
            model=agent_model, # Pass the initialized model object
            instructions=config.AGENT_INSTRUCTIONS,
            tools=typed_tools, # Pass the casted list
            name=config.AGENT_NAME
            # No need to pass model name string here as model object is provided
        )

        # Apply our patch to ensure all tools have a name attribute
        if hasattr(agent_instance, 'tools'):
            for tool in agent_instance.tools:
                if not hasattr(tool, 'name') and hasattr(tool, '__name__'):
                    tool.name = tool.__name__
                elif not hasattr(tool, 'name'):
                    tool.name = str(tool)

        logger.info(f"Agent '{config.AGENT_NAME}' created with model identifier '{model_identifier}' and {len(available_tools)} tools.") # Use model_identifier
        _agent_instance = agent_instance
        return _agent_instance
    except Exception as e:
        logger.exception(f"Failed to instantiate SDK agent: {e}")
        return None # Added missing return

# --- Ticket-Specific AI Functions (Ported from Streamlit version) ---

def process_ticket_request(
    agent_instance: Any, # Use Any as Agent might be None
    ticket_id: int,
    ticket_details: dict,
    request_type: str,
    custom_prompt: str = "",
    # context: Optional[ToolContext] = None # Context might be needed for member info if drafting notes/time
) -> dict:
    """
    Process a ticket-related request using the agent (Logic ported from Streamlit version).
    Generates a specific prompt based on the request type and ticket details.
    NOTE: Actual agent execution (.run/.run_streamed) needs to be called separately where this function is used.

    Args:
        agent_instance: The initialized Agent instance (used for context/potential future state).
        ticket_id: The ID of the ticket.
        ticket_details: The details of the ticket (dictionary format).
        request_type: The type of request (summary, customer_response, internal_note, next_steps, time_entry, custom).
        custom_prompt: Any additional custom prompt text.

    Returns:
        A dictionary {success: bool, message: str, content: Optional[str], generated_prompt: Optional[str]}.
        'content' will be None as this function only prepares the prompt.
    """
    if not agent_instance: # Check instance directly
        return {"success": False, "message": "Agent not initialized", "content": None, "generated_prompt": None}
    if not ticket_details or not isinstance(ticket_details, dict):
         return {"success": False, "message": "Invalid or missing ticket details provided.", "content": None, "generated_prompt": None}

    try:
        # Create ticket context string for the agent prompt
        notes = ticket_details.get('notes', [])
        time_entries = ticket_details.get('time_entries', [])
        # Use safe_get and format_datetime from cw_tools for consistency
        notes_text = "\n".join([
            f"- Note ({cw.format_datetime(n.get('date')) or 'Unknown Date'} by {n.get('member', 'System')} "
            f"{'[Internal]' if n.get('is_internal') else ''}{'[Resolution]' if n.get('is_resolution') else ''}): "
            f"{n.get('text', '')}"
            for n in notes[:5] # Limit context size
        ]) if notes else "No recent notes available."

        time_text = "\n".join([
             f"- Time Entry ({cw.format_datetime(t.get('date')) or 'Unknown Date'} by {t.get('member', 'System')} - {t.get('hours', 0)} hrs): "
             f"{t.get('notes', '')}"
             for t in time_entries[:3] # Limit context size
        ]) if time_entries else "No recent time entries available."

        ticket_context = f"""Current Ticket Context:
        ID: {ticket_id}
        Summary: {ticket_details.get('summary', 'N/A')}
        Status: {ticket_details.get('status', 'N/A')}
        Company: {ticket_details.get('company_name', 'N/A')}
        Contact: {ticket_details.get('contact_name', 'N/A')}
        Owner: {ticket_details.get('owner_name', 'N/A')} ({ticket_details.get('owner_identifier', 'N/A')})
        Board: {ticket_details.get('board_name', 'N/A')} (ID: {ticket_details.get('board_id', 'N/A')})
        Description: {ticket_details.get('initial_description', 'N/A')}

        Recent Notes (Max 15):
        {notes_text}

        Recent Time Entries (Max 10):
        {time_text}
        """

        # Build the specific request prompt
        prompt_instruction = ""
        if request_type == "summary":
            prompt_instruction = "Provide a concise summary of the ticket above, highlighting key issues and current status. Focus on summarizing the key points of the ticket, highlighting the most important information, recent updates, and the roles of the owner and assigned resources (if any)."
        elif request_type == "customer_response":
            prompt_instruction = "Draft a professional response to the customer regarding the ticket above. Be helpful and address their likely needs based on the context."
        elif request_type == "internal_note":
            prompt_instruction = "Create a detailed internal note for the ticket above that captures key information, recent activity, and suggested next steps."
        elif request_type == "next_steps":
            prompt_instruction = "Based on the ticket information above, suggest the most logical next steps to resolve this ticket efficiently. Suggest appropriate next steps for resolving the issue based on the ticket information, best practices in IT support for a Managed Service Provider, and consider the current owner and assigned resources (if any). If there's no owner or assigned resources, suggest assigning the ticket as a potential next step."
        elif request_type == "time_entry":
            prompt_instruction = "Generate detailed notes suitable for a time entry on the ticket above, explaining what work was likely done based on the recent context."
        elif request_type == "analyze":
            prompt_instruction = "Analyze the ticket timeline, identify patterns, and provide coaching and guidance of the technicians who worked on the ticket. Ensure to break things down chronologically based on the time entry and note dates, and consider how the owner and assigned resources (if any) have been involved. If the ticket is in one of the completed statuses, review the ticket and confirm if the ticket can be safely closed (Notes are good, the ticket summary is descriptive of the ticket)."
        elif request_type == "close_review":
            prompt_instruction = "Review this ticket and determine if it can be safely closed. Check if the notes are comprehensive, the ticket summary is descriptive, and all necessary work appears to be completed. If the ticket is in a completed status, suggest whether it should be closed and provide a reason."
        elif request_type == "custom":
             if not custom_prompt:
                  return {"success": False, "message": "Custom request type selected, but no custom prompt provided.", "content": None, "generated_prompt": None}
             prompt_instruction = f"Perform the following custom request regarding the ticket above: {custom_prompt}"
        else:
            return {"success": False, "message": f"Unknown request type: {request_type}", "content": None, "generated_prompt": None}

        # Combine context and instruction
        final_prompt = f"{ticket_context}\n\nTASK:\n{prompt_instruction}"

        # Add custom prompt as additional context if provided for non-custom types
        if custom_prompt and request_type != "custom":
            final_prompt += f"\n\nAdditional context/request from user: {custom_prompt}"

        logger.info(f"Generated prompt for ticket #{ticket_id}, request type '{request_type}'.")
        return {
            "success": True,
            "message": "Prompt generated successfully.",
            "content": None, # No content generated by this function itself
            "generated_prompt": final_prompt
        }

    except Exception as e:
        logger.error(f"Error processing ticket request for ticket {ticket_id}: {e}", exc_info=True)
        return {"success": False, "message": f"Internal error generating prompt: {str(e)}", "content": None, "generated_prompt": None}

# Function to add ticket to agent memory/context (Ported Placeholder)
def add_ticket_to_agent_context(agent_instance: Any, ticket_id: int, ticket_details: dict) -> bool: # Use Any
    """
    Placeholder function to represent adding ticket context to the agent.
    Actual implementation depends on the agent's context management capabilities.
    """
    if not agent_instance: # Check instance directly
        return False

    try:
        # Create a concise ticket summary
        ticket_summary = f"""
        Current ticket context: #{ticket_id} - {ticket_details.get('summary', 'N/A')}
        Status: {ticket_details.get('status', 'N/A')}
        Company: {ticket_details.get('company_name', 'N/A')}
        """

        # Placeholder: Log the action. Actual implementation would modify agent state/memory.
        logger.info(f"Placeholder: Added ticket #{ticket_id} context summary to agent state (not actually implemented). Summary: {ticket_summary}")
        # Example (conceptual): agent_instance.add_context_message(f"Context loaded for ticket {ticket_id}")
        return True
    except Exception as e:
        logger.error(f"Error adding ticket to agent context placeholder: {e}", exc_info=True)
        return False

# Example usage (optional, for testing within this module)
# if __name__ == "__main__":
#     test_agent = create_agent()
#     if test_agent:
#         # Example: Run agent with a prompt (requires agent framework's run method)
#         # response = test_agent.run("What is ticket 123?")
#         # print(response)
#         pass
</file>

<file path="auth/__init__.py">
"""
Authentication package for the ConnectWise AI Copilot.

This package handles authentication with Microsoft 365 and Azure AD,
as well as integration with ConnectWise Manage for member lookup.
"""

from .m365_auth import get_user_info, validate_token

__all__ = ["get_user_info", "validate_token"]
</file>

<file path="auth/m365_auth.py">
"""
Microsoft 365 Authentication Module

This module handles authentication with Microsoft 365 and Azure AD,
including token validation and user information extraction.
"""
import logging
import os
from typing import Dict, Any, Optional

import jwt
from jwt.exceptions import PyJWTError

logger = logging.getLogger(__name__)

# Azure AD configuration
TENANT_ID = os.getenv("AZURE_TENANT_ID", "")
CLIENT_ID = os.getenv("AZURE_CLIENT_ID", "")
CLIENT_SECRET = os.getenv("AZURE_CLIENT_SECRET", "")

# JWT validation configuration
ISSUER = f"https://login.microsoftonline.com/{TENANT_ID}/v2.0"
AUDIENCE = CLIENT_ID

def get_jwks_uri() -> str:
    """Get the JWKS URI for the Azure AD tenant."""
    return f"https://login.microsoftonline.com/{TENANT_ID}/discovery/v2.0/keys"

def get_signing_keys():
    """Fetch the signing keys from Azure AD."""
    from jwt.jwks_client import PyJWKClient

    jwks_uri = get_jwks_uri()
    try:
        # Create a PyJWKClient with the JWKS URI
        # This will automatically fetch the keys when needed
        jwks_client = PyJWKClient(jwks_uri)
        return jwks_client
    except Exception as e:
        logger.error(f"Error fetching signing keys: {e}")
        return None

def validate_token(token: str) -> Dict[str, Any]:
    """
    Validate a JWT token from Azure AD.

    Args:
        token: The JWT token to validate

    Returns:
        A dictionary containing the token claims if valid

    Raises:
        ValueError: If the token is invalid
    """
    if not token:
        raise ValueError("No token provided")

    try:
        # Remove 'Bearer ' prefix if present
        if token.startswith("Bearer "):
            token = token[7:]

        # Check if we're in development mode
        if os.getenv("DEVELOPMENT_MODE", "False").lower() in ("true", "1", "t"):
            # In development mode, decode without verification
            logger.info("Development mode: Decoding token without verification")
            decoded = jwt.decode(token, options={"verify_signature": False})
        else:
            # In production mode, validate the token signature
            logger.info("Production mode: Validating token signature")

            try:
                # Get the signing keys
                jwks_client = get_signing_keys()
                if jwks_client:
                    # Get the signing key for this token
                    signing_key = jwks_client.get_signing_key_from_jwt(token)

                    # Decode and verify the token
                    decoded = jwt.decode(
                        token,
                        signing_key.key,
                        algorithms=["RS256"],
                        audience=AUDIENCE,
                        issuer=ISSUER
                    )
                else:
                    # Fall back to no verification if we can't get the signing keys
                    logger.warning("Could not get signing keys, falling back to no verification")
                    decoded = jwt.decode(token, options={"verify_signature": False})
            except Exception as e:
                logger.error(f"Error validating token signature: {e}")
                # Fall back to no verification in case of error
                logger.warning("Error validating token signature, falling back to no verification")
                decoded = jwt.decode(token, options={"verify_signature": False})

        logger.info(f"Token validated successfully for user: {decoded.get('name', 'Unknown')}")
        return decoded

    except PyJWTError as e:
        logger.error(f"Token validation error: {e}")
        raise ValueError(f"Invalid token: {e}")

def get_user_info_from_token(token: str) -> Dict[str, Any]:
    """
    Extract user information from an Azure AD JWT token.

    Args:
        token: The JWT token

    Returns:
        A dictionary containing user information
    """
    try:
        # Validate and decode the token
        claims = validate_token(token)

        # Extract user information
        user_info = {
            "name": claims.get("name", ""),
            "email": claims.get("preferred_username", ""),
            "preferred_username": claims.get("preferred_username", ""),
            "oid": claims.get("oid", ""),  # Azure AD Object ID
            "tid": claims.get("tid", ""),  # Azure AD Tenant ID
            "sub": claims.get("sub", ""),  # Subject (user ID)
            "roles": claims.get("roles", []),  # User roles (if any)
            "groups": claims.get("groups", []),  # User groups (if any)
            "upn": claims.get("upn", ""),  # User Principal Name
            "given_name": claims.get("given_name", ""),  # First name
            "family_name": claims.get("family_name", ""),  # Last name
            "source": "Azure AD"
        }

        # Log the user info for debugging
        logger.info(f"Extracted user info from token: {user_info['name']} ({user_info['email']})")

        return user_info

    except Exception as e:
        logger.error(f"Error extracting user info from token: {e}")
        return {
            "name": "",
            "email": "",
            "preferred_username": "",
            "oid": "",
            "source": "Error"
        }

def get_user_info(token: Optional[str] = None) -> Dict[str, Any]:
    """
    Get user information from the token or return development user info.

    Args:
        token: The JWT token (optional)

    Returns:
        A dictionary containing user information
    """
    # Check if we're in development mode
    if os.getenv("DEVELOPMENT_MODE", "False").lower() in ("true", "1", "t"):
        # Return development user info with more fields to match production
        return {
            "dummy_user": True,
            "name": "Paul Short",
            "email": "pshort@grid4.com",
            "preferred_username": "pshort@grid4.com",
            "oid": "00000000-0000-0000-0000-000000000000",
            "tid": "3f90d8aa-842e-412f-9293-a5cb3b109521",  # Development tenant ID
            "sub": "dev-user-subject-id",
            "roles": ["User", "Admin"],  # Example roles
            "groups": [],
            "upn": "pshort@grid4.com",
            "given_name": "Paul",
            "family_name": "Short",
            "source": "Development Mode"
        }

    # If we have a token, extract user info from it
    if token:
        return get_user_info_from_token(token)

    # Otherwise, return empty user info with all fields
    return {
        "name": "",
        "email": "",
        "preferred_username": "",
        "oid": "",
        "tid": "",
        "sub": "",
        "roles": [],
        "groups": [],
        "upn": "",
        "given_name": "",
        "family_name": "",
        "source": "Unknown"
    }
</file>

<file path="auth/README.md">
# Authentication Module

This module handles authentication with Microsoft 365 and Azure AD, including token validation and user information extraction.

## Overview

The authentication module provides the following functionality:

1. **Token Validation**: Validates JWT tokens from Azure AD.
2. **User Information Extraction**: Extracts user information from tokens.
3. **Development Mode**: Provides a development user when running in development mode.

## Files

- `__init__.py`: Exports the module's public API.
- `m365_auth.py`: Contains the core authentication functionality.

## Usage

### Token Validation

```python
from app.auth import validate_token

# Validate a token
try:
    claims = validate_token(token)
    print(f"Token is valid for user: {claims.get('name')}")
except ValueError as e:
    print(f"Token validation failed: {e}")
```

### User Information Extraction

```python
from app.auth import get_user_info

# Get user information from a token
user_info = get_user_info(token)
print(f"User: {user_info['name']} ({user_info['email']})")
```

### Development Mode

When running in development mode, the `get_user_info` function returns a development user:

```python
# Set DEVELOPMENT_MODE=True in .env
from app.auth import get_user_info

# Get development user information
user_info = get_user_info()
print(f"Development user: {user_info['name']} ({user_info['email']})")
```

## Configuration

The authentication module is configured using environment variables:

- `AZURE_AD_CLIENT_ID`: The Azure AD application client ID.
- `AZURE_AD_CLIENT_SECRET`: The Azure AD application client secret.
- `AZURE_AD_TENANT_ID`: The Azure AD tenant ID.
- `DEVELOPMENT_MODE`: Set to "True" to enable development mode.

## Dependencies

The authentication module depends on the following packages:

- `PyJWT`: For JWT token validation.
- `cryptography`: For JWT token signature verification.
- `requests`: For fetching signing keys from Azure AD.

## Security Considerations

1. **Token Validation**: The module validates the token signature, issuer, and audience to ensure the token is valid.
2. **Development Mode**: In development mode, token validation is skipped to simplify testing.
3. **Error Handling**: The module handles errors gracefully to prevent information leakage.

## Future Improvements

1. **Caching**: Cache signing keys to improve performance.
2. **Role-Based Access Control**: Implement role-based access control based on the user's roles.
3. **Multi-Tenant Support**: Support multiple Azure AD tenants.
4. **User Profile Pictures**: Fetch and display the user's profile picture from Microsoft Graph.
</file>

<file path="config.py">
import os, sys, logging
from dotenv import load_dotenv

load_dotenv()  # Load variables from .env file for local development

# Basic logging configuration

LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
logging.basicConfig(
    level=LOG_LEVEL,
    format="%(asctime)s %(levelname)s [%(filename)s:%(lineno)d] %(message)s",
    datefmt="%H:%M:%S"
)
logger = logging.getLogger(__name__)
logger.info(f"Logging level set to {LOG_LEVEL}")

# --- Development Mode ---
DEVELOPMENT_MODE = os.getenv("DEVELOPMENT_MODE", "False").lower() in ("true", "1", "t")
logger.info(f"DEVELOPMENT_MODE environment variable: {os.getenv('DEVELOPMENT_MODE', 'Not set')}")
logger.info(f"DEVELOPMENT_MODE setting: {DEVELOPMENT_MODE}")
if DEVELOPMENT_MODE:
    logger.warning("Running in DEVELOPMENT MODE - authentication is disabled and development overrides are active")

# --- OpenAI / OpenRouter Configuration ---

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENAI_ASSISTANT_ID = os.getenv("OPENAI_ASSISTANT_ID", "asst_123456789")

# Default model settings (these can be changed to switch model providers)

DEFAULT_MODEL_PROVIDER = os.getenv("DEFAULT_MODEL_PROVIDER", "openai")
DEFAULT_OPENAI_MODEL = "gpt-4o"          # Custom identifier for GPT-4 (OpenAI)
DEFAULT_OPENROUTER_MODEL = "openai/gpt-4o"  # OpenRouter model alias

# By default, use OpenAI's model unless specified otherwise

PRIMARY_MODEL = DEFAULT_OPENAI_MODEL if DEFAULT_MODEL_PROVIDER == "openai" else DEFAULT_OPENROUTER_MODEL

# --- ConnectWise Manage API Credentials ---

CW_COMPANY    = os.getenv("CW_COMPANY")
CW_URL_BASE   = os.getenv("CW_URL_BASE")
CW_PUBLIC_KEY = os.getenv("CW_PUBLIC_KEY")
CW_PRIVATE_KEY= os.getenv("CW_PRIVATE_KEY")
CW_CLIENT_ID  = os.getenv("CW_CLIENT_ID")
CONNECTWISE_CONFIG_VALID = all([CW_COMPANY, CW_URL_BASE, CW_PUBLIC_KEY, CW_PRIVATE_KEY, CW_CLIENT_ID])
if not CONNECTWISE_CONFIG_VALID:
    logger.warning("One or more ConnectWise credentials are missing or invalid.")

# --- Azure AD OAuth Configuration ---

AZURE_AD_CLIENT_ID     = os.getenv("AZURE_AD_CLIENT_ID")
AZURE_AD_CLIENT_SECRET = os.getenv("AZURE_AD_CLIENT_SECRET")
AZURE_AD_TENANT_ID     = os.getenv("AZURE_AD_TENANT_ID")
AZURE_AD_AUTHORITY     = f"https://login.microsoftonline.com/{AZURE_AD_TENANT_ID}" if AZURE_AD_TENANT_ID else None
AZURE_AD_REDIRECT_URI  = os.getenv("AZURE_AD_REDIRECT_URI", "http://localhost:5173")
AZURE_AD_SCOPES        = ["User.Read"]  # example scope for MS Graph (not heavily used here)
AZURE_AD_CONFIG_VALID  = all([AZURE_AD_CLIENT_ID, AZURE_AD_CLIENT_SECRET, AZURE_AD_TENANT_ID])
if not AZURE_AD_CONFIG_VALID:
    logger.critical("Azure AD configuration is incomplete. OAuth will not function properly.")

# --- AI Agent Configuration ---

AGENT_NAME = "ConnectWise Assistant"
AGENT_INSTRUCTIONS = """
You are an AI assistant specialized in interacting with the ConnectWise Manage ticketing system via available tools for an MSP (Managed Service Provider).
Your goal is to help users manage support tickets efficiently and accurately based on their requests. All tools return a dictionary response.

You are knowledgeable about IT support, managed services, and technical troubleshooting. You can provide helpful suggestions for common IT issues and best practices for ticket management.

**Initial State:** You might start without a specific ticket selected. In this state, you can perform general actions like listing boards (`list_service_boards`), finding companies (`find_company`), finding contacts (`find_contact`), or creating new tickets (`create_new_ticket`). You can also answer general questions about ConnectWise concepts if possible. If the user asks about a specific ticket, use `get_ticket_details` to load its information.

**Ticket Context:** When a ticket *is* selected (the user interface will provide `selected_ticket_id` and potentially `ticket_details` in the context), your actions should primarily relate to that ticket unless the user explicitly asks about something else.

**Error Handling & Loop Avoidance:**
- If a tool call fails, clearly explain the error to the user and suggest alternative approaches.
- Avoid making the same tool call repeatedly with the same parameters if it's failing.
- If you need to search for an entity (ticket, company, contact), start with more specific search terms before trying broader ones.
- When you encounter an error with a specific tool, try a different approach rather than retrying the same action multiple times.
- If you find yourself in a situation where you're not making progress after 2-3 attempts, acknowledge the limitation and suggest an alternative course of action for the user.

Available Tools (All return a dictionary):
- `get_ticket_details(ticket_id:int)`: Fetches detailed info for a ticket ID. Use this when the user asks about a specific ticket not currently in context. Response: `{"success": boolean, "ticket_id": int, ...}` or `{"success": false, "message": string}`.
- `search_tickets_tool(board_id:Optional[int]=None, company_name:Optional[str]=None, contact_name:Optional[str]=None, status_name:Optional[str]=None, days_range:Optional[int]=None, search_term:Optional[str]=None, limit:Optional[int]=50)`: Searches for tickets based on multiple criteria. All parameters are optional filters. Response: `{"success": boolean, "tickets": list, "total_found": int, "message": string}`. Use this when the user wants to find tickets matching specific criteria.
- `get_company_details(company_id:int)`: Gets detailed information about a company by its ID. Response: `{"success": boolean, "message": string, "company": CompanyDetail}`. Use this when the user wants to know more about a specific company.
- `get_company_contacts(company_id:int)`: Gets all contacts for a company by its ID. Response: `{"success": boolean, "message": string, "contacts": List[ContactDetail], "total_count": int, "company_id": int, "company_name": string}`. Use this when the user wants to see all contacts for a specific company.
- `get_company_tickets(company_id:int, board_id:Optional[int]=None)`: Gets tickets for a company, optionally filtered by service board ID. Response: `{"success": boolean, "message": string, "tickets": List[TicketSummary], "total_found": int}`. Use this when the user wants to see all tickets for a specific company, optionally filtered by service board.
- `add_ticket_note(ticket_id:int, note_text:str, internal:bool, resolution:bool)`: Adds a note to a ticket. Requires ticket ID, note text, internal flag (true/false), and resolution flag (true/false). Member handled automatically. Response: `{"success": boolean, "message": string, "note_id": optional_int}`.
- `change_ticket_status(ticket_id:int, new_status_name:str, service_board_id:int)`: Updates status of a ticket. Requires ticket ID, the exact new status name, **and the `service_board_id`**. Response: `{"success": boolean, "message": string}`.
- `create_new_ticket(summary:str, company_name:str, service_board_id:int, contact_name:Optional[str]=None, priority_id:Optional[int]=None, details:Optional[str]=None)`: Creates a new ticket. Requires summary, company name, board ID. Optional: contact name, priority ID, details. Response: `{"success": boolean, "message": string, "ticket_id": optional_int}`.
- `close_ticket(ticket_id:int, service_board_id:int)`: Closes a ticket. Requires ticket ID **and the `service_board_id`**. Response: `{"success": boolean, "message": string, "already_closed": boolean}`.
- `list_service_boards()`: Lists active boards. Useful if the user needs a board ID. Response: `{"success": boolean, "boards": list | None, "message": optional_string}`.
- `list_ticket_statuses(service_board_id:int)`: Lists statuses for a specific board ID. **Requires `service_board_id`**. Useful before changing status. Response: `{"success": boolean, "statuses": list | None, "message": optional_string}`.
- `find_company(company_name:str)`: Finds company ID by name. Useful for creating tickets or finding contacts. Response: `{"success": boolean, "found": boolean, "company": dict | None, "message": optional_string}`.
- `find_contact(company_id:int, contact_name:str)`: Finds contact ID within a specific company ID. Requires company ID, contact name. Response: `{"success": boolean, "found": boolean, "contact": dict | None, "message": optional_string}`.
- `find_member(member_identifier:str)`: Finds member ID/identifier. Requires identifier (email/username). Response: `{"success": boolean, "found": boolean, "member": dict | None, "message": optional_string}`.
- `add_time_entry(ticket_id:int, notes:str, actual_hours:float, billable_option:str, time_start:Optional[str]=None)`: Adds time entry to a ticket. Requires ticket ID, notes, actual_hours (e.g., 0.5), and billable_option ('Billable', 'DoNotBill', 'NoCharge'). Optional: 'time_start' (ISO string like '2025-04-01T14:30:00Z' or 'now', defaults to now if omitted). Member handled automatically. Response: `{"success": boolean, "message": string, "entry_id": optional_int}`.
- `update_ticket_contact(ticket_id:int, new_contact_id:int)`: Updates the primary contact for a ticket. Requires ticket ID and the new contact's ID. Response: `{"success": boolean, "message": string}`.
- `update_ticket_owner(ticket_id:int, member_identifier:str)`: Assigns/reassigns the owner (member) of a ticket. Requires ticket ID and the member's identifier (email/username). Response: `{"success": boolean, "message": string}`.
- `create_company(name:str, identifier:Optional[str]=None, ...)`: Creates a new company. Requires name. Optional fields include identifier, address, phone, status. Response: `{"success": boolean, "message": string, "company_id": int, "company_identifier": str}`.
- `create_contact(company_id:int, first_name:str, last_name:str, email:Optional[str]=None, ...)`: Creates a new contact for a company. Requires company ID, first name, last name. Optional fields include email, phone, title. Response: `{"success": boolean, "message": string, "contact_id": int}`.

Interaction Guidelines:
- **Advanced Ticket Searching:**
    - When a user asks to search for tickets, use the `search_tickets_tool` tool with appropriate parameters.
    - **Example 1 (Search by Company):** User: "Find all tickets for company ABC" -> Use `search_tickets_tool` with company_name="ABC".
    - **Example 2 (Search by Time Range):** User: "Show me tickets from the last 7 days" -> Use `search_tickets_tool` with days_range=7.
    - **Example 3 (Combined Search):** User: "Find open tickets for contact John Smith" -> Use `search_tickets_tool` with contact_name="John Smith" and status_name="open".
    - **Example 4 (Text Search):** User: "Find tickets about network issues" -> Use `search_tickets_tool` with search_term="network issues".
    - Present search results in a clear, readable format, especially when there are multiple results.

- **Company and Contact Information:**
    - When a user asks about a company, use the `get_company_details` tool to get detailed information about the company.
    - When a user asks about contacts for a company, use the `get_company_contacts` tool to get all contacts for the company.
    - When a user asks about tickets for a company, use the `get_company_tickets` tool to get all tickets for the company.
    - **Example 1 (Company Details):** User: "Tell me about company XYZ" -> Use `find_company` to get the company ID, then use `get_company_details` with the company ID.
    - **Example 2 (Company Contacts):** User: "Who are the contacts at company XYZ?" -> Use `find_company` to get the company ID, then use `get_company_contacts` with the company ID.
    - **Example 3 (Company Tickets):** User: "Show me all tickets for company XYZ" -> Use `find_company` to get the company ID, then use `get_company_tickets` with the company ID.
    - **Example 4 (Filtered Company Tickets):** User: "Show me all tickets for company XYZ on the Help Desk board" -> Use `find_company` to get the company ID, use `list_service_boards` to get the board ID, then use `get_company_tickets` with the company ID and board ID.

- **Command Interpretation & Parameter Gathering:**
    - Identify the user's intent and the required parameters for the relevant tool.
    - **If critical parameters are missing:** YOU MUST explicitly ask the user for them. Do not try to guess or assume. This includes `ticket_id`, `board_id`, `notes`, `actual_hours`, `billable_option` when required by a tool.
    - **Example 1 (Missing Ticket ID):** User: "Add a note saying 'called client'." -> Agent: "Okay, I can add that note. Which ticket ID should I add it to?" (Unless a ticket is already selected in context).
    - **Example 2 (Missing Board ID):** User: "Change ticket #12345 status to 'In Progress'." -> Agent: "Got it. To change the status for ticket #12345, I also need the Service Board ID it belongs to. Do you know the Board ID? If not, I can look it up if the ticket details are available, or you can tell me."
    - **Example 3 (Missing Time Entry Details):** User: "Add time to ticket #67890." -> Agent: "Sure. How many hours should I log (e.g., 0.5 for 30 mins), what notes should I include, and should this time be 'Billable', 'DoNotBill', or 'NoCharge'?"
- **Contextual Suggestions When Asking:**
    - When asking for a Ticket ID, if you have details for a `selected_ticket_id` in your context, you can suggest it: "Okay, which ticket ID? Are you referring to the currently viewed ticket #{selected_ticket_id}?"
    - When asking for a Board ID, you can offer to list them: "Do you know the Board ID? If not, I can list the available service boards for you."
    - When asking for a Status Name for a specific ticket, you can offer to list them *if the board ID is known* (from ticket details or user): "What status should I change it to? If you're unsure, I can list the available statuses for board ID {board_id}."
- **Tool Parameter Requirements (CRITICAL):**
    - Tools `change_ticket_status`, `close_ticket`, and `list_ticket_statuses` **REQUIRE** the `service_board_id`.
    - Tools `add_ticket_note`, `add_time_entry`, `get_ticket_details`, `change_ticket_status`, `close_ticket`, `update_ticket_contact`, `update_ticket_owner`, `assign_resource_to_ticket`, `remove_resource_from_ticket`, `get_ticket_attachments`, `move_ticket_to_board` **REQUIRE** a `ticket_id`. Ask if not provided or selected.
    - `add_time_entry` also requires `notes`, `actual_hours`, and `billable_option`.
    - `create_contact` requires `company_id`, `first_name`, and `last_name`.
    - Ensure all other *required* parameters mentioned in the tool descriptions are provided or ask the user for clarification.
- **ID Mapping:** Use the provided `board_map` and `member_map` in context to resolve names to IDs when possible before calling tools. Ask for clarification if ambiguous.
- **Confirmation:** Briefly confirm modification actions *after* the tool reports success (`"success": true`), mentioning the ticket ID or relevant entity.
- **Synthesize Tool Output:** Check the 'success' field. Present relevant info clearly in natural language. **DO NOT output raw dictionaries.** Format lists nicely (Markdown bulleted list or simple table). Provide brief confirmation summaries below your main response (e.g., "✅ `list_service_boards` found 12 item(s)."). Handle `success: false` by explaining the issue using the 'message' field.
- **User Context:** Your actions are performed as the logged-in ConnectWise member (provided automatically). **DO NOT ask the user for their member identifier.**
- **Be Concise:** Get straight to the point.
- **Troubleshooting Guidance:** When users describe technical issues, provide helpful troubleshooting steps and best practices based on industry standards. Suggest appropriate ticket categorization, priority levels, and next steps.
- **Web Search Integration:** You can use web search to find information about technical issues, product documentation, or best practices when needed. This can help provide more accurate and up-to-date information to users.
- **Proactive Suggestions:** When appropriate, suggest follow-up actions that might be helpful, such as adding time entries, updating ticket status, or adding relevant notes based on the conversation context.

- **Resource Management:**
    - Use `assign_resource_to_ticket` to assign a member (resource) to a ticket.
    - Use `remove_resource_from_ticket` to remove a member from a ticket.
    - **Example 1 (Assign Resource):** User: "Assign John to ticket #12345" -> Use `find_member` to get John's member ID, then use `assign_resource_to_ticket` with the ticket ID and member ID.
    - **Example 2 (Remove Resource):** User: "Remove Jane from ticket #67890" -> Use `find_member` to get Jane's member ID, then use `remove_resource_from_ticket` with the ticket ID and member ID.

- **Contact Management:**
    - Use `create_contact` to create a new contact for a company.
    - **Example 1 (Create Contact):** User: "Create a new contact for ABC Corp named John Smith" -> Use `find_company` to get the company ID, then use `create_contact` with the company ID, first name "John", and last name "Smith".

- **Ticket Management:**
    - Use `move_ticket_to_board` to move a ticket to a different service board.
    - Use `get_ticket_attachments` to get a list of attachments for a ticket.
    - **Example 1 (Move Ticket):** User: "Move ticket #12345 to the Help Desk board" -> Use `list_service_boards` to get the board ID for "Help Desk", then use `move_ticket_to_board` with the ticket ID and board ID.
    - **Example 2 (Get Attachments):** User: "Show me the attachments for ticket #67890" -> Use `get_ticket_attachments` with the ticket ID.

- **Error Handling and Tool Failures:**
    - If a tool call fails, carefully read the error message and respond appropriately.
    - **Common Error Types:**
        - **ValueError:** Usually indicates invalid input parameters. Double-check parameter values and try again with corrected values.
        - **APIError:** Indicates an issue with the ConnectWise API. Check the status code and message for details.
        - **AuthError:** Indicates an authentication issue. The user may need to re-authenticate.
        - **MaxTurnsExceeded:** Indicates you've reached the maximum number of turns in the conversation. This usually happens when you're stuck in a loop.
    - **Recovery Strategies:**
        - If a tool fails due to invalid parameters, clearly explain what went wrong and ask for corrected information.
        - If a tool fails due to a ConnectWise API error, explain the issue and suggest alternatives if possible.
        - If you're unsure about the correct parameters after multiple attempts, suggest an alternative approach to accomplish the user's goal.
        - **DO NOT** repeatedly call the same tool with the same parameters if it's failing.
        - **IMPORTANT:** If you notice you're making the same tool call multiple times without success, STOP and explain to the user what's happening. Ask for clarification or suggest an alternative approach.
        - If you can't resolve an issue after 2-3 attempts, acknowledge the limitation and ask the user for more specific guidance.
    - **Avoiding Loops:**
        - Keep track of which tools you've called and their parameters.
        - If you find yourself calling the same tool with similar parameters more than twice, STOP and reconsider your approach.
        - When stuck, try a completely different approach or ask the user for more specific instructions.
        - If you're repeatedly failing to get information needed for a task, explain the specific issue to the user rather than continuing to try.
    - **Example 1 (Invalid Parameter):** If `change_ticket_status` fails with "Status 'In Progres' not found", respond with: "I couldn't change the status because 'In Progres' wasn't found. Did you mean 'In Progress'? Please confirm the exact status name."
    - **Example 2 (API Error):** If `get_ticket_details` fails with a 404 error, respond with: "I couldn't find ticket #12345. It may have been deleted or you might not have access to it. Could you verify the ticket number?"
    - **Example 3 (Stuck in Loop):** If you've tried to find a company multiple times without success: "I've made several attempts to find company 'ABC Corp' but haven't been successful. Could you provide the exact company name as it appears in ConnectWise, or perhaps the company ID if you have it?"
"""
</file>

<file path="context_enhancement.py">
"""
Context Enhancement Module

This module provides functions to enhance the context provided to the AI agent
with additional metadata and information about tickets, users, and the system.
"""

import logging
from typing import Dict, Any, Optional
from datetime import datetime

from app.cw_tools.tool_adapter import tool_adapter
from app.context import current_tool_context
from app.cw_tools.api_client import cache_get, cache_set

logger = logging.getLogger(__name__)

def _calculate_days_open(date_entered: str) -> Optional[int]:
    """
    Calculate the number of days a ticket has been open.

    Args:
        date_entered: The date the ticket was created

    Returns:
        Number of days the ticket has been open, or None if the date is invalid
    """
    if not date_entered:
        return None

    try:
        # Try to parse the date string
        # Assuming format is like "2023-04-15T14:30:00Z"
        if 'T' in date_entered:
            date_str = date_entered.split('T')[0]
        else:
            date_str = date_entered

        # Parse the date
        entry_date = datetime.strptime(date_str, "%Y-%m-%d")

        # Calculate days open
        days_open = (datetime.now() - entry_date).days
        return max(0, days_open)  # Ensure non-negative
    except Exception as e:
        logger.warning(f"Error calculating days open from date {date_entered}: {e}")
        return None

def enhance_ticket_context(ticket_id: int) -> Dict[str, Any]:
    """
    Enhance the ticket context with additional metadata.

    Args:
        ticket_id: The ID of the ticket to enhance

    Returns:
        A dictionary containing enhanced ticket context
    """
    logger.info(f"Enhancing context for ticket {ticket_id}")

    # Get basic ticket details
    ticket_details_result = tool_adapter.call_impl("get_ticket_details", ticket_id=ticket_id)

    if not ticket_details_result.success:
        logger.warning(f"Failed to get ticket details for {ticket_id}: {ticket_details_result.message}")
        return {"error": f"Failed to get ticket details: {ticket_details_result.message}"}

    # Extract the ticket details
    ticket_data = ticket_details_result.to_dict()

    # Check cache first
    cached_context = cache_get("enhanced_context", ticket_id=ticket_id)
    if cached_context is not None:
        logger.info(f"Using cached enhanced context for ticket {ticket_id}")
        return cached_context

    # Create enhanced context
    enhanced_context = {
        "ticket_id": ticket_id,
        "summary": ticket_data.get("summary", ""),
        "status": ticket_data.get("status", ""),
        "board_name": ticket_data.get("board_name", ""),
        "board_id": ticket_data.get("board_id", None),
        "company_name": ticket_data.get("company_name", ""),
        "company_id": ticket_data.get("company_id", None),
        "contact_name": ticket_data.get("contact_name", ""),
        "contact_id": ticket_data.get("contact_id", None),
        "owner_identifier": ticket_data.get("owner_identifier", ""),
        "priority": ticket_data.get("priority", ""),
        "date_entered": ticket_data.get("date_entered", ""),
        "closed_flag": ticket_data.get("closed_flag", False),

        # Type hierarchy
        "type_hierarchy": {
            "type": ticket_data.get("type", ""),
            "subtype": ticket_data.get("subtype", ""),
            "item": ticket_data.get("item", "")
        },

        # Recent notes (limited to 5)
        "recent_notes": ticket_data.get("notes", [])[:5] if ticket_data.get("notes") else [],

        # Recent time entries (limited to 5)
        "recent_time_entries": ticket_data.get("time_entries", [])[:5] if ticket_data.get("time_entries") else [],

        # Temporal data
        "temporal_data": {
            "creation_date": ticket_data.get("date_entered", ""),
            "last_updated": ticket_data.get("_last_updated", ""),
            "days_open": _calculate_days_open(ticket_data.get("date_entered", "")) if "date_entered" in ticket_data else None
        }
    }

    # Add status history
    try:
        status_history_result = tool_adapter.call_impl("get_ticket_status_history", ticket_id=ticket_id)
        if status_history_result.success and status_history_result.status_history:
            enhanced_context["status_history"] = [
                {
                    "date": item.date,
                    "status": item.status,
                    "member": item.member,
                    "previous_status": item.previous_status,
                    "days_in_previous_status": item.days_in_previous_status
                }
                for item in status_history_result.status_history
            ]

            # Add a summary of status changes
            if enhanced_context["status_history"]:
                status_summary = {
                    "current_status": enhanced_context["status_history"][0]["status"] if enhanced_context["status_history"] else None,
                    "previous_status": enhanced_context["status_history"][0]["previous_status"] if enhanced_context["status_history"] else None,
                    "status_change_count": len(enhanced_context["status_history"]),
                    "days_in_current_status": enhanced_context["status_history"][0]["days_in_previous_status"] if enhanced_context["status_history"] and enhanced_context["status_history"][0]["days_in_previous_status"] else 0
                }
                enhanced_context["status_summary"] = status_summary
    except Exception as e:
        logger.warning(f"Failed to get status history for ticket {ticket_id}: {e}")
        enhanced_context["status_history"] = []
        enhanced_context["status_summary"] = {
            "current_status": enhanced_context["status"],
            "previous_status": None,
            "status_change_count": 0,
            "days_in_current_status": 0
        }

    # Add related tickets
    try:
        related_tickets_result = tool_adapter.call_impl("find_related_tickets", ticket_id=ticket_id)
        if related_tickets_result.success and related_tickets_result.related_tickets:
            enhanced_context["related_tickets"] = [
                {
                    "ticket_id": ticket.ticket_id,
                    "summary": ticket.summary,
                    "status": ticket.status,
                    "board_name": ticket.board_name,
                    "company_name": ticket.company_name,
                    "relationship_type": ticket.relationship_type
                }
                for ticket in related_tickets_result.related_tickets
            ]

            # Add a summary of related tickets
            if enhanced_context["related_tickets"]:
                related_summary = {
                    "total_related": len(enhanced_context["related_tickets"]),
                    "parent_ticket": next((t for t in enhanced_context["related_tickets"] if t["relationship_type"] == "parent"), None),
                    "child_tickets_count": len([t for t in enhanced_context["related_tickets"] if t["relationship_type"] == "child"]),
                    "same_company_tickets_count": len([t for t in enhanced_context["related_tickets"] if t["relationship_type"] == "same_company"])
                }
                enhanced_context["related_summary"] = related_summary
    except Exception as e:
        logger.warning(f"Failed to get related tickets for ticket {ticket_id}: {e}")
        enhanced_context["related_tickets"] = []
        enhanced_context["related_summary"] = {
            "total_related": 0,
            "parent_ticket": None,
            "child_tickets_count": 0,
            "same_company_tickets_count": 0
        }

    # Add note summary
    try:
        note_summary_result = tool_adapter.call_impl("summarize_ticket_notes", ticket_id=ticket_id)
        if note_summary_result.success and note_summary_result.note_summary:
            enhanced_context["note_summary"] = {
                "total_notes": note_summary_result.note_summary.total_notes,
                "internal_notes": note_summary_result.note_summary.internal_notes,
                "resolution_notes": note_summary_result.note_summary.resolution_notes,
                "recent_topics": note_summary_result.note_summary.recent_topics,
                "sentiment": note_summary_result.note_summary.sentiment
            }
    except Exception as e:
        logger.warning(f"Failed to summarize notes for ticket {ticket_id}: {e}")
        enhanced_context["note_summary"] = {
            "total_notes": len(ticket_data.get("notes", [])),
            "internal_notes": 0,
            "resolution_notes": 0,
            "recent_topics": None,
            "sentiment": "neutral"
        }

    # Add user context if available
    try:
        # Get the current tool context to check for member info
        current_context = current_tool_context.get()
        if current_context and hasattr(current_context, "member_info") and current_context.member_info:
            enhanced_context["user_context"] = {
                "member_id": current_context.member_info.id,
                "member_identifier": current_context.member_info.identifier,
                "member_name": current_context.member_info.name,
                "is_owner": current_context.member_info.identifier == enhanced_context["owner_identifier"],
                "is_admin": getattr(current_context.member_info, "is_admin", False)
            }
    except Exception as e:
        logger.warning(f"Failed to add user context for ticket {ticket_id}: {e}")
        enhanced_context["user_context"] = None

    # Cache the enhanced context with a TTL of 5 minutes for active tickets
    cache_set("enhanced_context", enhanced_context, ticket_id=ticket_id, ttl=300)

    return enhanced_context

def enhance_user_context(member_identifier: Optional[str] = None) -> Dict[str, Any]:
    """
    Enhance the user context with additional metadata.

    Args:
        member_identifier: The identifier of the member to enhance (if None, uses current context)

    Returns:
        A dictionary containing enhanced user context
    """
    # If no member identifier is provided, try to get it from the current context
    if member_identifier is None:
        context = current_tool_context.get()
        if context and context.cw_member_info:
            member_identifier = context.cw_member_info.identifier

    if not member_identifier:
        logger.warning("No member identifier provided and none found in context")
        return {"error": "No member identifier available"}

    logger.info(f"Enhancing context for member {member_identifier}")

    # Get member details
    member_result = tool_adapter.call_impl("find_member", member_identifier=member_identifier)

    if not member_result.success or not member_result.found:
        logger.warning(f"Failed to get member details for {member_identifier}: {member_result.message}")
        return {
            "member_identifier": member_identifier,
            "error": f"Failed to get member details: {member_result.message}"
        }

    # Extract member details
    member_data = member_result.member

    # Create enhanced context
    enhanced_context = {
        "member_id": getattr(member_data, "id", None),
        "member_identifier": member_identifier,
        "member_name": getattr(member_data, "name", ""),
        "member_email": getattr(member_data, "email", ""),

        # Add role information if available
        "role": getattr(member_data, "title", ""),
    }

    # Get recent tickets assigned to this member
    try:
        recent_tickets_result = tool_adapter.call_impl(
            "search_tickets_tool",
            assigned_to=member_identifier,
            days_range=7,
            limit=5
        )

        if recent_tickets_result.success and recent_tickets_result.tickets:
            enhanced_context["recent_tickets"] = [
                {
                    "ticket_id": ticket.ticket_id,
                    "summary": ticket.summary,
                    "status": ticket.status,
                    "board_name": ticket.board_name,
                    "company_name": ticket.company_name,
                    "date_entered": ticket.date_entered
                }
                for ticket in recent_tickets_result.tickets
            ]
        else:
            enhanced_context["recent_tickets"] = []
    except Exception as e:
        logger.warning(f"Failed to get recent tickets for {member_identifier}: {e}")
        enhanced_context["recent_tickets"] = []

    return enhanced_context

def create_enhanced_context(ticket_id: Optional[int] = None, member_identifier: Optional[str] = None) -> Dict[str, Any]:
    """
    Create a comprehensive enhanced context for the AI agent.

    Args:
        ticket_id: Optional ticket ID to include in the context
        member_identifier: Optional member identifier to include in the context

    Returns:
        A dictionary containing the enhanced context
    """
    # Start with basic system context
    enhanced_context = {
        "system_info": {
            "name": "ConnectWise AI Assistant",
            "version": "1.0.0",
        }
    }

    # Add user context if available
    user_context = enhance_user_context(member_identifier)
    if "error" not in user_context:
        enhanced_context["user_context"] = user_context

    # Add ticket context if available
    if ticket_id is not None:
        ticket_context = enhance_ticket_context(ticket_id)
        if "error" not in ticket_context:
            enhanced_context["ticket_context"] = ticket_context

    return enhanced_context
</file>

<file path="context.py">
import contextvars
from typing import Optional
from .cw_tools import ToolContext # Assuming ToolContext is importable from here

# Define a ContextVar for the ToolContext
# This variable will hold the context specific to the current request/agent run.
current_tool_context: contextvars.ContextVar[Optional[ToolContext]] = contextvars.ContextVar("current_tool_context", default=None)
</file>

<file path="cw_tools/__init__.py">
import logging

# Import shared utility functions and models needed externally
from .api_client import manage_api_client, _handle_cw_error, safe_get, format_datetime # Keep helpers if used externally, otherwise remove

# Import models used in API routes or other modules
from .models import (
    CwMemberInfo, ToolContext, BaseToolResult, # Base context/result might be needed
    GetTicketDetailsResult, AddNoteResult, ChangeStatusResult, CreateTicketResult,
    CloseTicketResult, ListBoardsResult, ListStatusesResult, FindCompanyResult,
    FindContactResult, FindMemberResult, AddTimeEntryResult, ListPrioritiesResult,
    UpdateTicketResult, UpdateTicketContactResult, UpdateTicketOwnerResult,
    PriorityDetail, StatusDetail, BoardDetail, ContactDetail, MemberDetail, # Detail models might be needed by consumers
    TicketSummary, # Used in PaginatedTicketsResult in api.py
    TypeDetail, SubtypeDetail, ItemDetail, ListTypesResult, ListSubtypesResult, ListItemsResult,
    WorkTypeDetail, ListWorkTypesResult, WorkRoleDetail, ListWorkRolesResult,
    LocationDetail, ListLocationsResult, AttachmentInfo, GetTicketAttachmentsResult, CreateContactResult
    # Add other specific models if they are directly used by API routes
)

# Import specific tool functions or implementation details needed by API routes
from .activity import (
    get_ticket_activity # Assuming the tool itself might be registered or used elsewhere
    # get_ticket_activity_impl # Likely not needed externally
)

from .cw_tools_main import (
    # Tools potentially used by agent or API endpoints
    get_ticket_details,
    add_ticket_note,
    change_ticket_status,
    create_new_ticket,
    close_ticket,
    list_service_boards,
    list_ticket_statuses,
    find_company,
    find_contact,
    find_member,
    add_time_entry,
    search_tickets_tool,
    update_ticket_contact,
    update_ticket_owner,
    list_ticket_priorities,
    update_ticket_summary,
    update_ticket_priority,
    update_ticket_company,
    update_ticket_type,
    update_ticket_subtype,
    update_ticket_item,
    get_board_types,
    get_type_subtypes,
    get_subtype_items,
    list_work_types,
    list_work_roles,
    list_locations,
    assign_resource_to_ticket,
    remove_resource_from_ticket,
    create_contact,
    move_ticket_to_board,
    get_ticket_attachments,

    # Implementation/helper functions directly called by API routes
    _find_member_details_sync,
)

# Define __all__ for explicit export control (optional but good practice)
__all__ = [
    # Client & Helpers
    "manage_api_client",
    "_handle_cw_error",
    "safe_get",
    "format_datetime",

    # Context & Base Models
    "CwMemberInfo",
    "ToolContext",
    "BaseToolResult",

    # Detail Models (Export if needed externally)
    "PriorityDetail",
    "StatusDetail",
    "BoardDetail",
    "ContactDetail",
    "MemberDetail",
    "TicketSummary",
    "NoteDetail", # Needed by GetTicketDetailsResult
    "TimeEntryDetail", # Needed by GetTicketDetailsResult
    "TypeDetail",
    "SubtypeDetail",
    "ItemDetail",
    "WorkTypeDetail",
    "WorkRoleDetail",
    "LocationDetail",
    "AttachmentInfo",

    # Result Models
    "GetTicketDetailsResult",
    "AddNoteResult",
    "ChangeStatusResult",
    "CreateTicketResult",
    "CloseTicketResult",
    "ListBoardsResult",
    "ListStatusesResult",
    "FindCompanyResult",
    "FindContactResult",
    "FindMemberResult",
    "AddTimeEntryResult",
    "ListPrioritiesResult",
    "UpdateTicketResult",
    "UpdateTicketContactResult",
    "UpdateTicketOwnerResult",
    "ListTypesResult",
    "ListSubtypesResult",
    "ListItemsResult",
    "ListWorkTypesResult",
    "ListWorkRolesResult",
    "ListLocationsResult",
    "GetTicketAttachmentsResult",
    "CreateContactResult",
    # "QueryTicketsResult", # Replaced by PaginatedTicketsResult in api.py

    # Tool Functions
    "get_ticket_activity",
    "get_ticket_details",
    "add_ticket_note",
    "change_ticket_status",
    "create_new_ticket",
    "close_ticket",
    "list_service_boards",
    "list_ticket_statuses",
    "find_company",
    "find_contact",
    "find_member",
    "add_time_entry",
    "search_tickets_tool",
    "update_ticket_contact",
    "update_ticket_owner",
    "list_ticket_priorities",
    "update_ticket_summary",
    "update_ticket_priority",
    "update_ticket_company",
    "update_ticket_type",
    "update_ticket_subtype",
    "update_ticket_item",
    "get_board_types",
    "get_type_subtypes",
    "get_subtype_items",
    "list_work_types",
    "list_work_roles",
    "list_locations",
    "assign_resource_to_ticket",
    "remove_resource_from_ticket",
    "create_contact",
    "move_ticket_to_board",
    "get_ticket_attachments",

    # Implementation/Helper Functions (Export if needed externally)
    "_find_member_details_sync",
]

logger = logging.getLogger(__name__)
logger.debug(f"cw_tools package initialized. Exporting: {__all__}")
</file>

<file path="cw_tools/activity.py">
import logging

from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional

from agents.tool import function_tool # type: ignore # General ignore for missing stub
from pydantic import BaseModel

from .models import ToolContext, ActivityItem, TicketActivityResult # Import models from .models
from .api_client import format_datetime, safe_get, _handle_cw_error # Keep helpers from api_client
from app.cw_tools.api_client import manage_api_client # Import the client variable

logger = logging.getLogger(__name__)

# Models moved to models.py

def get_ticket_activity_impl(ticket_id: int, days: int = 7) -> Dict[str, Any]:
    """
    Fetch all activity (notes, time entries, status changes) for a ticket in chronological order.
    
    Args:
        ticket_id: The ID of the ticket
        days: Number of days of history to fetch
    
    Returns:
        Dictionary with success status and list of activity items
    """
    try:
        logger.info(f"Fetching activity for ticket #{ticket_id} for the past {days} days")
        
        # Get the API client
        client = manage_api_client # Use the imported client variable directly
        if not client:
            return {
                "success": False, 
                "message": "Failed to initialize ConnectWise API client.",
                "activity": []
            }
        
        # Calculate date range
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        # Initialize combined activity list
        all_activity = []
        
        # Fetch notes
        try:
            # Fetch notes associated with the specific ticket ID
            notes_conditions = f"dateCreated>[{start_date.strftime('%Y-%m-%d')}]" # Remove ticket condition, handled by path
            notes = client.service.tickets.id(ticket_id).notes.get(params={'conditions': notes_conditions}) # type: ignore[attr-defined, arg-type] # Pass conditions via params
            
            for note in notes:
                note_date = safe_get(note, "dateCreated") or "Unknown Date"
                member = safe_get(note, "member", "text") or "System"
                
                all_activity.append(ActivityItem(
                    type="note",
                    date=format_datetime(note_date),
                    actor=member,
                    description=f"Added a {'internal ' if safe_get(note, 'internal') else ''}{'resolution ' if safe_get(note, 'detailDescriptionFlag') else ''}note",
                    details={
                        "note_id": safe_get(note, "id"),
                        "text": safe_get(note, "text"),
                        "internal": bool(safe_get(note, "internal")),
                        "is_resolution": bool(safe_get(note, "detailDescriptionFlag"))
                    }
                ))
        except Exception as e:
            logger.warning(f"Error fetching notes for ticket #{ticket_id}: {e}")
        
        # Fetch time entries
        try:
            # Assume .get() is synchronous and uses 'params'
            time_entries = client.time.entries.get(params={'conditions': f"ticket/id={ticket_id} AND dateEntered>[{start_date.strftime('%Y-%m-%d')}]"}) # type: ignore[arg-type] # Mypy expects ConnectWiseManageRequestParams, but dict works
            
            for entry in time_entries:
                entry_date = safe_get(entry, "dateEntered") or "Unknown Date"
                member = safe_get(entry, "member", "name") or "System"
                hours = safe_get(entry, "actualHours") or 0
                
                all_activity.append(ActivityItem(
                    type="time_entry",
                    date=format_datetime(entry_date),
                    actor=member,
                    description=f"Logged {hours} hours of time",
                    details={
                        "entry_id": safe_get(entry, "id"),
                        "hours": hours,
                        "notes": safe_get(entry, "notes"),
                        "billable_option": safe_get(entry, "billableOption")
                    }
                ))
        except Exception as e:
            logger.warning(f"Error fetching time entries for ticket #{ticket_id}: {e}")
        
        # Fetch ticket history for status changes
        try:
            # If your API client supports history/audit logs, fetch them here
            # This is a placeholder - implementation depends on ConnectWise API capabilities
            # history_items = await client.service.tickets.get_ticket_history(ticket_id)
            pass
        except Exception as e:
            logger.warning(f"Error fetching history for ticket #{ticket_id}: {e}")
        
        # Sort all activity items by date
        all_activity.sort(key=lambda x: x.date, reverse=True)
        
        return {
            "success": True,
            "ticket_id": ticket_id,
            "activity": all_activity,
            "days": days
        }
    except Exception as e:
        logger.error(f"Failed to get activity for ticket #{ticket_id}: {e}", exc_info=True)
        return {
            "success": False,
            "message": f"Error retrieving ticket activity: {str(e)}",
            "activity": []
        }

@function_tool() # Restore decorator
def get_ticket_activity(
    ticket_id: int,
    days: Optional[int] = 7,
    context: Optional[ToolContext] = None # Restore context argument
) -> TicketActivityResult: # Restore Pydantic return type
    """
    Get recent activity for a ticket including notes, time entries, and status changes.
    
    Args:
        ticket_id: The ID of the ticket to fetch activity for
        days: Number of days of history to fetch (default: 7)
        context: Optional tool context object containing member information
        
    Returns:
        Dictionary with success status and activity information
    """
    try:
        result = get_ticket_activity_impl(ticket_id, days or 7) # Call synchronous impl directly
        return TicketActivityResult(
            success=True,
            ticket_id=ticket_id,
            activity=result.get("activity", []),
            days=days
        ) # Return Pydantic model directly
    except Exception as e:
        error_data = _handle_cw_error(e, "get_ticket_activity", TicketActivityResult, ticket_id=ticket_id, days=days)
        if isinstance(error_data, TicketActivityResult):
            return error_data
        else:
            return TicketActivityResult(**error_data)
</file>

<file path="cw_tools/api_client.py">
import logging
import time
from datetime import datetime
from typing import Dict, Any, Optional, Type, Callable

from pydantic import BaseModel
from pyconnectwise import ConnectWiseManageAPIClient # type: ignore
from pyconnectwise.config import Config as CWConfig # type: ignore
from pyconnectwise.exceptions import ConnectWiseException # type: ignore

import app.config as config # Import app config for CW credentials

logger = logging.getLogger(__name__)

# Initialize the global ConnectWise API client
manage_api_client: Optional[ConnectWiseManageAPIClient] = None

# Cache for API responses
api_cache: Dict[str, Dict[str, Any]] = {}

# Cache TTL in seconds
CACHE_TTL = {
    'boards': 24 * 60 * 60,  # 24 hours
    'statuses': 12 * 60 * 60,  # 12 hours
    'priorities': 12 * 60 * 60,  # 12 hours
    'companies': 24 * 60 * 60,  # 24 hours
    'contacts': 12 * 60 * 60,  # 12 hours
    'members': 24 * 60 * 60,  # 24 hours
    'tickets': 5 * 60,  # 5 minutes
    'default': 10 * 60  # 10 minutes default
}

def initialize_api_client() -> Optional[ConnectWiseManageAPIClient]:
    """Initialize the ConnectWise API client with retry logic."""
    if config.CONNECTWISE_CONFIG_VALID:
        try:
            # Configure with increased retries and timeout
            cw_conf = CWConfig(max_retries=5)

            # Assert config values are not None (checked by CONNECTWISE_CONFIG_VALID)
            assert config.CW_COMPANY is not None, "CW_COMPANY cannot be None"
            assert config.CW_URL_BASE is not None, "CW_URL_BASE cannot be None"
            assert config.CW_PUBLIC_KEY is not None, "CW_PUBLIC_KEY cannot be None"
            assert config.CW_PRIVATE_KEY is not None, "CW_PRIVATE_KEY cannot be None"
            assert config.CW_CLIENT_ID is not None, "CW_CLIENT_ID cannot be None"

            client = ConnectWiseManageAPIClient(
                company_name = str(config.CW_COMPANY),
                manage_url   = str(config.CW_URL_BASE),
                public_key   = str(config.CW_PUBLIC_KEY),
                private_key  = str(config.CW_PRIVATE_KEY),
                client_id    = str(config.CW_CLIENT_ID),
                config       = cw_conf
            )

            # Test the connection
            try:
                # Simple API call to verify connection
                _ = client.service.boards.get(params={"pageSize": 1})
                logger.info("ConnectWise API client initialized and connection verified successfully.")
                return client
            except Exception as conn_e:
                logger.error(f"API client created but connection test failed: {conn_e}")
                return client  # Still return the client even if test fails

        except Exception as e:
            logger.critical(f"Failed to initialize ConnectWise client: {e}", exc_info=True)
            return None
    else:
        logger.error("ConnectWise client not initialized due to missing configuration.")
        return None

# Initialize the client
manage_api_client = initialize_api_client()

# Create a mock client for development/testing if needed
if config.DEVELOPMENT_MODE and manage_api_client is None:
    logger.warning("Creating mock ConnectWise client for development mode")
    # This is just a placeholder - we'll implement proper mocking as needed
    manage_api_client = object()  # type: ignore

# Utility: safely get nested attribute from API result objects
def safe_get(obj: Any, attr_path: str, default=None):
    """Safely retrieve nested attributes from pyconnectwise objects (or dicts).

    Args:
        obj: The object to get the attribute from
        attr_path: The path to the attribute, using dot notation (e.g., 'company.name')
        default: The default value to return if the attribute is not found

    Returns:
        The attribute value or the default value if not found
    """
    if obj is None:
        return default
    # pyconnectwise returns custom objects, but they support dict-like access via ._attrs
    # We attempt dict-style first, then attribute traversal.
    current = obj._attrs if hasattr(obj, "_attrs") else obj

    for attr in attr_path.split('.'):
        if current is None:
            return default
        if isinstance(current, dict):
            current = current.get(attr, None)
        else:
            try:
                current = getattr(current, attr, None)
            except (AttributeError, TypeError):
                return default

        if current is None:
            return default

    return current



# Cache management functions
def cache_key(category: str, **params) -> str:
    """Generate a cache key from category and parameters."""
    param_str = "_".join(f"{k}:{v}" for k, v in sorted(params.items()) if v is not None)
    return f"{category}:{param_str}" if param_str else category


def cache_get(category: str, **params) -> Optional[Any]:
    """Get an item from the cache."""
    key = cache_key(category, **params)
    if key in api_cache:
        item = api_cache[key]
        # Check if cache has expired
        if time.time() < item.get('expiry', 0):
            logger.debug(f"Cache hit for {key}")
            return item.get('data')
        else:
            # Remove expired item
            logger.debug(f"Cache expired for {key}")
            del api_cache[key]
    return None


def cache_set(category: str, data: Any, **params) -> None:
    """Set an item in the cache."""
    key = cache_key(category, **params)
    ttl = CACHE_TTL.get(category, CACHE_TTL['default'])
    api_cache[key] = {
        'data': data,
        'expiry': time.time() + ttl
    }
    logger.debug(f"Cached {key} for {ttl} seconds")


def cache_clear(category: Optional[str] = None) -> None:
    """Clear cache items, optionally filtered by category."""
    if category:
        # Clear only items for the specified category
        keys_to_remove = [k for k in api_cache if k.startswith(f"{category}:")]
        for k in keys_to_remove:
            del api_cache[k]
        logger.debug(f"Cleared cache for category {category}")
    else:
        # Clear all cache
        api_cache.clear()
        logger.debug("Cleared entire cache")

# Utility: format datetime strings or objects to a friendly format
def format_datetime(dt_value: Any, format_str: str = "%Y-%m-%d %H:%M") -> Optional[str]:
    """Format a datetime value as a string.

    Args:
        dt_value: The datetime value to format. Can be a string, datetime object, or None.
        format_str: The format string to use for formatting.

    Returns:
        A formatted string representation of the datetime, or None if dt_value is None.
    """
    if dt_value is None:
        return None

    # If it's already a datetime object
    if isinstance(dt_value, datetime):
        return dt_value.strftime(format_str)

    # Handle string input
    if isinstance(dt_value, str):
        # Handle empty string
        if not dt_value:
            return ""

        # Handle special case for "Unknown Date"
        if dt_value == "Unknown Date":
            logger.debug("Handling 'Unknown Date' string")
            return "Unknown"

        try:
            # Many CW dates are in ISO8601 Zulu time
            # First, try with Z replacement
            if "Z" in dt_value:
                dt = datetime.fromisoformat(dt_value.replace("Z", "+00:00"))
                return dt.strftime(format_str)

            # Try direct parsing
            try:
                dt = datetime.fromisoformat(dt_value)
                return dt.strftime(format_str)
            except ValueError:
                # Try with different formats
                for fmt in ["%Y-%m-%dT%H:%M:%S", "%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]:
                    try:
                        dt = datetime.strptime(dt_value, fmt)
                        return dt.strftime(format_str)
                    except ValueError:
                        continue

                # If we get here, none of the formats worked
                raise ValueError(f"Could not parse datetime with any format: {dt_value}")

        except (ValueError, TypeError) as e: # Catch potential parsing errors
            logger.warning(f"Could not parse datetime string: {dt_value}. Error: {e}")
            # Return a cleaned version of the original string
            if len(dt_value) > 30:  # If it's a very long string
                return dt_value[:27] + "..."  # Truncate with ellipsis
            return dt_value  # Return original string

    # For any other type, try to convert to string
    try:
        return str(dt_value)
    except Exception as e:
        logger.warning(f"Could not convert datetime value to string: {e}")
        return None

# Error handling helper
def _handle_cw_error(e: Exception, tool_name: str, result_model_type: Type[BaseModel], **kwargs) -> Any:
    """Uniform error response for exceptions in tool functions."""
    log_msg = f"Error in ConnectWise tool '{tool_name}'"
    error_info: Dict[str, Any] = {"success": False} # Base fields for the specific model
    if kwargs:
        log_msg += f" with args: {kwargs}"
    if isinstance(e, ConnectWiseException):
        # API-specific error
        status = getattr(e, "status_code", None)
        msg = getattr(e, "message", str(e))
        logger.error(f"{log_msg}. API Error {status}: {msg}")
        error_info.update({
            "error_type": "APIError",
            "status_code": status,
            "message": f"ConnectWise API error: {msg} (status {status})"
        })
    elif isinstance(e, ValueError):
        logger.error(f"{log_msg}. ValueError: {e}")
        error_info.update({
            "error_type": "ValueError",
            "message": str(e)
        })
    else:
        # Unexpected error
        logger.exception(f"{log_msg}. Exception: {e}")
        error_info.update({
            "error_type": "Exception",
            "message": str(e)
        })
    # Instantiate the specific result type passed in
    # This might fail if result_model_type expects fields not in error_info
    try:
        return result_model_type(**error_info)
    except Exception as model_e:
        logger.error(f"Failed to instantiate error model {result_model_type.__name__}: {model_e}")
        # Fallback to a generic dictionary if model instantiation fails
        return error_info


# API call wrapper with caching and error handling
def api_call_with_cache(category: str, result_model_type: Type[BaseModel],
                        api_func: Callable, use_cache: bool = True,
                        cache_params: Optional[Dict[str, Any]] = None,
                        **kwargs) -> Any:
    """Make an API call with caching and error handling.

    Args:
        category: Cache category (e.g., 'boards', 'statuses')
        result_model_type: Pydantic model type for the result
        api_func: Function to call for the API request
        use_cache: Whether to use cache (default: True)
        cache_params: Parameters to use for cache key (default: kwargs)
        **kwargs: Arguments to pass to the API function

    Returns:
        API response or error result
    """
    # Use provided cache params or kwargs for cache key
    cache_params = cache_params or kwargs

    # Check cache first if enabled
    if use_cache:
        cached_data = cache_get(category, **cache_params)
        if cached_data is not None:
            return cached_data

    # Make the API call
    try:
        if not manage_api_client:
            raise ValueError("ConnectWise client not configured.")

        result = api_func(**kwargs)

        # Cache successful results
        if use_cache:
            cache_set(category, result, **cache_params)

        return result
    except Exception as e:
        return _handle_cw_error(e, f"api_call_{category}", result_model_type, **kwargs)
</file>

<file path="cw_tools/context_tools.py">
"""
Context Enhancement Tools

This module provides tools for enhancing the context provided to the AI agent
with additional metadata and information about tickets, users, and the system.
"""

import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Tuple

from agents.tool import function_tool # type: ignore # General ignore for missing stub

from .models import (
    ToolContext, StatusHistoryItem, RelatedTicket, NoteSummary,
    TicketStatusHistoryResult, RelatedTicketsResult, NoteSummaryResult
)
from .api_client import (
    format_datetime, safe_get, _handle_cw_error, cache_get, cache_set,
    manage_api_client
)

logger = logging.getLogger(__name__)

def get_ticket_status_history_impl(ticket_id: int, days: int = 30) -> Dict[str, Any]:
    """
    Get the status change history for a ticket.

    Args:
        ticket_id: The ID of the ticket
        days: Number of days of history to fetch (default: 30)

    Returns:
        Dictionary with success status and list of status history items
    """
    try:
        logger.info(f"Fetching status history for ticket #{ticket_id} for the past {days} days")

        # Check cache first
        cache_key = f"status_history_{ticket_id}_{days}"
        cached_result = cache_get("status_history", ticket_id=ticket_id, days=days)
        if cached_result is not None:
            logger.info(f"Using cached status history for ticket {ticket_id}")
            return cached_result

        # Get the API client
        client = manage_api_client
        if not client:
            return {
                "success": False,
                "message": "Failed to initialize ConnectWise API client.",
                "status_history": []
            }

        # Calculate date range
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)

        # Initialize status history list
        status_history = []

        # Fetch ticket history for status changes
        # Note: ConnectWise API doesn't directly provide status history
        # We'll need to use the audit trail or history endpoint if available

        # For now, we'll use a workaround by analyzing the notes and activity
        # to infer status changes

        # 1. Get the current status
        try:
            ticket_fields = "id,status/name,lastUpdated"
            ticket = client.service.tickets.id(ticket_id).get(params={"fields": ticket_fields})
            current_status = safe_get(ticket, "status.name")
            last_updated = safe_get(ticket, "lastUpdated")

            if current_status:
                # Add the current status as the most recent entry
                status_history.append(StatusHistoryItem(
                    date=format_datetime(last_updated) if last_updated else format_datetime(datetime.now()),
                    status=current_status,
                    member="Unknown",  # We don't know who made the last status change
                    previous_status=None,
                    days_in_previous_status=None
                ))
        except Exception as e:
            logger.warning(f"Error fetching current status for ticket #{ticket_id}: {e}")

        # 2. Look for status change indicators in notes
        try:
            # Fetch notes that might contain status change information
            notes_conditions = f"dateCreated>[{start_date.strftime('%Y-%m-%d')}] AND text contains 'status'"
            notes = client.service.tickets.id(ticket_id).notes.get(params={'conditions': notes_conditions})

            for note in notes:
                note_date = safe_get(note, "dateCreated")
                note_text = safe_get(note, "text", "")
                member = safe_get(note, "member.identifier") or "System"

                # Simple heuristic to detect status changes in notes
                # This is a basic implementation and could be improved
                if note_text and ("changed status" in note_text.lower() or "status changed" in note_text.lower()):
                    # Try to extract the statuses from the note text
                    # This is a very basic implementation
                    parts = note_text.split("to")
                    if len(parts) > 1:
                        new_status = parts[1].strip().split(".")[0].strip()
                        previous_status = None

                        # Try to extract the previous status
                        from_parts = parts[0].split("from")
                        if len(from_parts) > 1:
                            previous_status = from_parts[1].strip()

                        status_history.append(StatusHistoryItem(
                            date=format_datetime(note_date),
                            status=new_status,
                            member=member,
                            previous_status=previous_status,
                            days_in_previous_status=None  # We don't have this information
                        ))

        except Exception as e:
            logger.warning(f"Error analyzing notes for status changes for ticket #{ticket_id}: {e}")

        # 3. If we have audit trail access, we could use that for more accurate history
        # This would be implemented here if the API supports it

        # Sort status history by date (newest first)
        status_history.sort(key=lambda x: x.date if x.date else "", reverse=True)

        result = {
            "success": True,
            "ticket_id": ticket_id,
            "status_history": status_history
        }

        # Cache the result
        cache_set("status_history", result, ticket_id=ticket_id, days=days)

        return result
    except Exception as e:
        logger.error(f"Failed to get status history for ticket #{ticket_id}: {e}", exc_info=True)
        return {
            "success": False,
            "message": f"Error retrieving ticket status history: {str(e)}",
            "status_history": []
        }

@function_tool(strict_mode=False) # Disable strict schema validation
def get_ticket_status_history(
    ticket_id: int,
    days: Optional[int] = 30,
    context: Optional[ToolContext] = None
) -> TicketStatusHistoryResult:
    """
    Get the status change history for a ticket.

    Args:
        ticket_id: The ID of the ticket to fetch status history for
        days: Number of days of history to fetch (default: 30)
        context: Optional tool context object containing member information

    Returns:
        Object with success status and status history information
    """
    try:
        result = get_ticket_status_history_impl(ticket_id, days or 30)
        return TicketStatusHistoryResult(
            success=True,
            ticket_id=ticket_id,
            status_history=result.get("status_history", [])
        )
    except Exception as e:
        error_data = _handle_cw_error(e, "get_ticket_status_history", TicketStatusHistoryResult, ticket_id=ticket_id, days=days)
        if isinstance(error_data, TicketStatusHistoryResult):
            return error_data
        else:
            return TicketStatusHistoryResult(**error_data)

def find_related_tickets_impl(ticket_id: int) -> Dict[str, Any]:
    """
    Find tickets related to the specified ticket.

    Args:
        ticket_id: The ID of the ticket

    Returns:
        Dictionary with success status and list of related tickets
    """
    try:
        logger.info(f"Finding related tickets for ticket #{ticket_id}")

        # Check cache first
        cached_result = cache_get("related_tickets", ticket_id=ticket_id)
        if cached_result is not None:
            logger.info(f"Using cached related tickets for ticket {ticket_id}")
            return cached_result

        # Get the API client
        client = manage_api_client
        if not client:
            return {
                "success": False,
                "message": "Failed to initialize ConnectWise API client.",
                "related_tickets": []
            }

        related_tickets = []

        # 1. Check for parent-child relationships
        try:
            # Get the current ticket to check if it has a parent
            ticket_fields = "id,summary,parentTicketId"
            ticket = client.service.tickets.id(ticket_id).get(params={"fields": ticket_fields})
            parent_id = safe_get(ticket, "parentTicketId")

            # If this ticket has a parent, fetch the parent details
            if parent_id:
                try:
                    parent_fields = "id,summary,status/name,board/name,company/name"
                    parent_ticket = client.service.tickets.id(parent_id).get(params={"fields": parent_fields})

                    related_tickets.append(RelatedTicket(
                        ticket_id=parent_id,
                        summary=safe_get(parent_ticket, "summary"),
                        status=safe_get(parent_ticket, "status.name"),
                        board_name=safe_get(parent_ticket, "board.name"),
                        company_name=safe_get(parent_ticket, "company.name"),
                        relationship_type="parent"
                    ))
                except Exception as e:
                    logger.warning(f"Error fetching parent ticket #{parent_id}: {e}")

            # Find child tickets (tickets that have this ticket as their parent)
            try:
                children_conditions = f"parentTicketId={ticket_id}"
                children_fields = "id,summary,status/name,board/name,company/name"
                child_tickets = client.service.tickets.get(
                    params={
                        "conditions": children_conditions,
                        "fields": children_fields
                    }
                )

                for child in child_tickets:
                    related_tickets.append(RelatedTicket(
                        ticket_id=safe_get(child, "id"),
                        summary=safe_get(child, "summary"),
                        status=safe_get(child, "status.name"),
                        board_name=safe_get(child, "board.name"),
                        company_name=safe_get(child, "company.name"),
                        relationship_type="child"
                    ))
            except Exception as e:
                logger.warning(f"Error fetching child tickets for #{ticket_id}: {e}")

        except Exception as e:
            logger.warning(f"Error checking parent-child relationships for ticket #{ticket_id}: {e}")

        # 2. Find tickets from the same company with similar summary/description
        # This is a more advanced feature that would require text analysis
        # For now, we'll just find recent tickets from the same company
        try:
            # Get company ID from the ticket
            company_fields = "id,company/id,company/name"
            ticket_company = client.service.tickets.id(ticket_id).get(params={"fields": company_fields})
            company_id = safe_get(ticket_company, "company.id")

            if company_id:
                # Find recent tickets from the same company
                company_tickets_conditions = f"company/id={company_id} AND id!={ticket_id}"
                company_tickets_fields = "id,summary,status/name,board/name,company/name"
                company_tickets = client.service.tickets.get(
                    params={
                        "conditions": company_tickets_conditions,
                        "fields": company_tickets_fields,
                        "pageSize": 30,
                        "orderBy": "dateEntered desc"
                    }
                )

                for company_ticket in company_tickets:
                    related_tickets.append(RelatedTicket(
                        ticket_id=safe_get(company_ticket, "id"),
                        summary=safe_get(company_ticket, "summary"),
                        status=safe_get(company_ticket, "status.name"),
                        board_name=safe_get(company_ticket, "board.name"),
                        company_name=safe_get(company_ticket, "company.name"),
                        relationship_type="same_company"
                    ))
        except Exception as e:
            logger.warning(f"Error finding company-related tickets for #{ticket_id}: {e}")

        result = {
            "success": True,
            "ticket_id": ticket_id,
            "related_tickets": related_tickets
        }

        # Cache the result
        cache_set("related_tickets", result, ticket_id=ticket_id)

        return result
    except Exception as e:
        logger.error(f"Failed to find related tickets for #{ticket_id}: {e}", exc_info=True)
        return {
            "success": False,
            "message": f"Error finding related tickets: {str(e)}",
            "related_tickets": []
        }

@function_tool(strict_mode=False) # Disable strict schema validation
def find_related_tickets(
    ticket_id: int,
    context: Optional[ToolContext] = None
) -> RelatedTicketsResult:
    """
    Find tickets related to the specified ticket, including parent-child relationships
    and tickets from the same company.

    Args:
        ticket_id: The ID of the ticket to find related tickets for
        context: Optional tool context object containing member information

    Returns:
        Object with success status and related tickets information
    """
    try:
        result = find_related_tickets_impl(ticket_id)
        return RelatedTicketsResult(
            success=True,
            ticket_id=ticket_id,
            related_tickets=result.get("related_tickets", [])
        )
    except Exception as e:
        error_data = _handle_cw_error(e, "find_related_tickets", RelatedTicketsResult, ticket_id=ticket_id)
        if isinstance(error_data, RelatedTicketsResult):
            return error_data
        else:
            return RelatedTicketsResult(**error_data)

def summarize_ticket_notes_impl(ticket_id: int) -> Dict[str, Any]:
    """
    Summarize the notes for a ticket, including counts and basic sentiment analysis.

    Args:
        ticket_id: The ID of the ticket

    Returns:
        Dictionary with success status and note summary information
    """
    try:
        logger.info(f"Summarizing notes for ticket #{ticket_id}")

        # Check cache first
        cached_result = cache_get("note_summary", ticket_id=ticket_id)
        if cached_result is not None:
            logger.info(f"Using cached note summary for ticket {ticket_id}")
            return cached_result

        # Get the API client
        client = manage_api_client
        if not client:
            return {
                "success": False,
                "message": "Failed to initialize ConnectWise API client.",
                "note_summary": None
            }

        # Fetch all notes for the ticket
        try:
            notes_fields = "id,text,internalAnalysisFlag,detailDescriptionFlag,resolutionFlag"
            notes = client.service.tickets.id(ticket_id).notes.get(params={"fields": notes_fields})

            # Initialize counters
            total_notes = len(notes)
            internal_notes = 0
            resolution_notes = 0

            # Process each note
            for note in notes:
                if safe_get(note, "internalAnalysisFlag"):
                    internal_notes += 1
                if safe_get(note, "detailDescriptionFlag") or safe_get(note, "resolutionFlag"):
                    resolution_notes += 1

            # Very basic sentiment analysis (would be better with NLP)
            # Just checking for common positive/negative words
            positive_words = ["resolved", "fixed", "completed", "working", "success", "thank", "good", "great"]
            negative_words = ["issue", "problem", "error", "failed", "not working", "broken", "bug", "crash"]

            positive_count = 0
            negative_count = 0

            # Extract common topics (very basic implementation)
            topics = []

            for note in notes:
                note_text = safe_get(note, "text", "").lower()

                # Count sentiment words
                for word in positive_words:
                    if word in note_text:
                        positive_count += 1

                for word in negative_words:
                    if word in note_text:
                        negative_count += 1

                # Extract potential topics (very basic)
                # In a real implementation, you'd use NLP for topic extraction
                if len(note_text) > 10:  # Only process substantial notes
                    # Split into sentences and take the first one as a potential topic
                    sentences = note_text.split('.')
                    if sentences and len(sentences[0]) > 5:
                        topic = sentences[0].strip()
                        if len(topic) > 50:
                            topic = topic[:50] + "..."
                        if topic and topic not in topics:
                            topics.append(topic)

            # Determine overall sentiment
            sentiment = "neutral"
            if positive_count > negative_count * 1.5:
                sentiment = "positive"
            elif negative_count > positive_count * 1.5:
                sentiment = "negative"

            # Limit topics to the 3 most recent
            topics = topics[:3]

            # Create the note summary
            note_summary = NoteSummary(
                total_notes=total_notes,
                internal_notes=internal_notes,
                resolution_notes=resolution_notes,
                recent_topics=topics,
                sentiment=sentiment
            )

            result = {
                "success": True,
                "ticket_id": ticket_id,
                "note_summary": note_summary
            }

            # Cache the result
            cache_set("note_summary", result, ticket_id=ticket_id)

            return result

        except Exception as e:
            logger.warning(f"Error fetching notes for ticket #{ticket_id}: {e}")
            return {
                "success": False,
                "message": f"Error fetching notes: {str(e)}",
                "note_summary": None
            }

    except Exception as e:
        logger.error(f"Failed to summarize notes for ticket #{ticket_id}: {e}", exc_info=True)
        return {
            "success": False,
            "message": f"Error summarizing notes: {str(e)}",
            "note_summary": None
        }

@function_tool(strict_mode=False) # Disable strict schema validation
def summarize_ticket_notes(
    ticket_id: int,
    context: Optional[ToolContext] = None
) -> NoteSummaryResult:
    """
    Summarize the notes for a ticket, including counts, topics, and basic sentiment analysis.

    Args:
        ticket_id: The ID of the ticket to summarize notes for
        context: Optional tool context object containing member information

    Returns:
        Object with success status and note summary information
    """
    try:
        result = summarize_ticket_notes_impl(ticket_id)
        return NoteSummaryResult(
            success=True,
            ticket_id=ticket_id,
            note_summary=result.get("note_summary")
        )
    except Exception as e:
        error_data = _handle_cw_error(e, "summarize_ticket_notes", NoteSummaryResult, ticket_id=ticket_id)
        if isinstance(error_data, NoteSummaryResult):
            return error_data
        else:
            return NoteSummaryResult(**error_data)
</file>

<file path="cw_tools/cw_tools_main.py">
import logging
from datetime import datetime, timezone, timedelta
from typing import Dict, Any, Optional, Union, List, cast
from pyconnectwise.clients.manage_client import ConnectWiseManageAPIClient

from agents.tool import function_tool
from pyconnectwise.exceptions import ConnectWiseException
from .api_client import (
    manage_api_client, safe_get, format_datetime, _handle_cw_error,
    cache_get, cache_set, cache_clear
)
from .models import (
    CwMemberInfo, ToolContext, NoteDetail, TimeEntryDetail, BoardDetail,
    StatusDetail, CompanyDetail, ContactDetail, MemberDetail, GetTicketDetailsResult,
    AddNoteResult, ChangeStatusResult, CreateTicketResult, CloseTicketResult,
    ListBoardsResult, ListStatusesResult, FindCompanyResult, FindContactResult,
    FindMemberResult, AddTimeEntryResult, TicketSummary,
    QueryTicketsResult,
    UpdateTicketContactResult, UpdateTicketOwnerResult,
    PriorityDetail, ListPrioritiesResult, UpdateTicketResult,
    GetCompanyDetailsResult, GetCompanyContactsResult,
    TypeDetail, SubtypeDetail, ItemDetail, ListTypesResult, ListSubtypesResult, ListItemsResult,
    AttachmentInfo, GetTicketAttachmentsResult, CreateContactResult,
    WorkTypeDetail, ListWorkTypesResult, WorkRoleDetail, ListWorkRolesResult,
    LocationDetail, ListLocationsResult, ResourceDetail, AssignResourceResult, RemoveResourceResult
)
from app.context import current_tool_context
try:
    from app.config import config
except ImportError:
    # For testing purposes
    from dataclasses import dataclass
    @dataclass
    class Config:
        DEVELOPMENT_MODE = False
    config = Config()


logger = logging.getLogger(__name__)

# Define a context class for tools needing user-specific info
# Removed @dataclass decorator as it might conflict with BaseModel inheritance
# Models moved to cw_tools/models.py
# --- End Pydantic Models ---


# API Client Initialization and Helper functions moved to cw_tools/api_client.py

# --- Tool Functions ---

# --- Undecorated Helper for Core Logic ---
def get_ticket_details_impl(ticket_id: int) -> GetTicketDetailsResult:
    """Core logic to fetch detailed information about a specific ConnectWise service ticket."""
    # Merged implementation back into decorated function
    if not manage_api_client:
        return GetTicketDetailsResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Fetching details for ticket_id: {ticket_id}") # Changed log prefix
    try:
        if not isinstance(ticket_id, int) or ticket_id <= 0:
            raise ValueError("Invalid Ticket ID provided. Must be a positive integer.")
            
        # Cast manage_api_client to avoid None type errors
        api_client = cast(ConnectWiseClient, manage_api_client)
        
        ticket_fields = "id,summary,status/name,board/id,board/name,company/id,company/name,contact/id,contact/name,owner/id,owner/identifier,owner/name,priority/name,closedFlag,dateEntered,initialDescription,type/name,subType/name,item/name"
        ticket = api_client.service.tickets.id(ticket_id).get(params={"fields": ticket_fields})
        if not ticket:
            raise ValueError(f"Ticket with ID {ticket_id} not found.") # Use ValueError for custom message
        # --- DEBUG LOGGING START ---
        logger.info(f"Raw Ticket object attributes: {dir(ticket)}")
        logger.info(f"Raw Ticket sample data: id={getattr(ticket, 'id', 'N/A')}, summary={getattr(ticket, 'summary', 'N/A')}, status_name={getattr(getattr(ticket, 'status', None), 'name', 'N/A')}, board_name={getattr(getattr(ticket, 'board', None), 'name', 'N/A')}")
        # --- DEBUG LOGGING END ---

        notes_fields = "id,text,dateCreated,member/identifier,internalAnalysisFlag,resolutionFlag"
        notes = api_client.service.tickets.id(ticket_id).notes.get(params={"pageSize": 10, "orderBy": "dateCreated desc", "fields": notes_fields})

        time_fields = "id,timeStart,notes,member/identifier,actualHours"
        time_entries = api_client.time.entries.get(params={"conditions": f"ticket/id = {ticket_id}", "pageSize": 5, "orderBy": "timeStart desc", "fields": time_fields})

        result_data: Dict[str, Any] = {"success": True}
        result_data.update({
            # Use direct getattr based on debug logs for all fields
            "ticket_id": getattr(ticket, 'id', None),
            "summary": getattr(ticket, 'summary', ""),  # Provide empty string default for required field
            "status": getattr(getattr(ticket, 'status', None), 'name', None),
            "board_id": getattr(getattr(ticket, 'board', None), 'id', None),
            "board_name": getattr(getattr(ticket, 'board', None), 'name', None),
            "company_id": getattr(getattr(ticket, 'company', None), 'id', None),
            "company_name": getattr(getattr(ticket, 'company', None), 'name', None),
            "contact_id": getattr(getattr(ticket, 'contact', None), 'id', None),
            "contact_name": getattr(getattr(ticket, 'contact', None), 'name', None),
            "owner_identifier": getattr(getattr(ticket, 'owner', None), 'identifier', None),
            "owner_name": getattr(getattr(ticket, 'owner', None), 'name', 'Unassigned'),
            "priority": getattr(getattr(ticket, 'priority', None), 'name', None),
            "is_closed": getattr(ticket, 'closedFlag', False),
            "date_entered": format_datetime(getattr(ticket, 'dateEntered', None)),
            "initial_description": getattr(ticket, 'initialDescription', None),
            "ticket_type": getattr(getattr(ticket, 'type', None), 'name', None),
            "ticket_subtype": getattr(getattr(ticket, 'subType', None), 'name', None),
            "ticket_item": getattr(getattr(ticket, 'item', None), 'name', None)
        })

        result_data["notes"] = []
        # --- DEBUG LOGGING START ---
        if notes and isinstance(notes, list) and len(notes) > 0:
            logger.info(f"Raw Note object attributes: {dir(notes[0])}")
            logger.info(f"Raw Note sample data: id={getattr(notes[0], 'id', 'N/A')}, text={getattr(notes[0], 'text', 'N/A')}, member_identifier={getattr(getattr(notes[0], 'member', None), 'identifier', 'N/A')}")
        # --- DEBUG LOGGING END ---
        for note in (notes or []):
            # Use direct getattr based on debug logs
            date_raw = getattr(note, 'dateCreated', None) # Assign outside
            note_detail = NoteDetail(
                note_id=getattr(note, 'id', None),
                date=format_datetime(date_raw) if isinstance(date_raw, str) else "", # Use variable here
                member=getattr(getattr(note, 'member', None), 'identifier', 'System'), # Handle nested member
                text=getattr(note, 'text', None), # Use direct getattr for text
                is_internal=getattr(note, 'internalAnalysisFlag', False),
                is_resolution=getattr(note, 'resolutionFlag', False)
            )
            result_data["notes"].append(note_detail)

        result_data["time_entries"] = []
        # --- DEBUG LOGGING START ---
        if time_entries and isinstance(time_entries, list) and len(time_entries) > 0:
             logger.info(f"Raw Time Entry object attributes: {dir(time_entries[0])}")
             logger.info(f"Raw Time Entry sample data: id={getattr(time_entries[0], 'id', 'N/A')}, notes={getattr(time_entries[0], 'notes', 'N/A')}, member_identifier={getattr(getattr(time_entries[0], 'member', None), 'identifier', 'N/A')}")
        # --- DEBUG LOGGING END ---
        for entry in (time_entries or []):
            # Use direct getattr based on debug logs
            date_raw = getattr(entry, 'timeStart', None) # Assign outside
            time_detail = TimeEntryDetail(
                entry_id=getattr(entry, 'id', None),
                date=format_datetime(date_raw) if isinstance(date_raw, str) else "", # Use variable here
                member=getattr(getattr(entry, 'member', None), 'identifier', 'System'), # Handle nested member
                hours=getattr(entry, 'actualHours', None),
                notes=getattr(entry, 'notes', None) # Use direct getattr for notes
            )
            result_data["time_entries"].append(time_detail)

        logger.info(f"Logic: Successfully fetched details for ticket {ticket_id}.") # Changed log prefix
        return GetTicketDetailsResult(**result_data)
    except Exception as e:
        # Pass the specific result model type to the error handler
        # Use the implementation function name in the error log
        return _handle_cw_error(e, "get_ticket_details_impl", GetTicketDetailsResult, ticket_id=ticket_id)

# --- Agent Tool Definition ---

@function_tool() # Re-added decorator
def get_ticket_details(ticket_id: int) -> GetTicketDetailsResult:
    """Fetches detailed information about a specific ConnectWise service ticket, including recent notes and time entries."""
    logger.info(f"Tool 'get_ticket_details' called for ticket_id: {ticket_id}, delegating to implementation.")
    return get_ticket_details_impl(ticket_id=ticket_id)

# --- Helper function for API routes ---
def get_ticket_details_for_api(ticket_id: int) -> Dict[str, Any]:
    """Helper function for API routes to get ticket details.

    This function is used by the suggestions module and other API routes
    that need ticket details but don't need the full Pydantic model.

    Args:
        ticket_id: The ID of the ticket to fetch

    Returns:
        A dictionary with ticket details
    """
    logger.info(f"API helper 'get_ticket_details_for_api' called for ticket_id: {ticket_id}")

    try:
        # Call the implementation function directly without going through the decorated function
        if not isinstance(ticket_id, int) or ticket_id <= 0:
            raise ValueError("Invalid Ticket ID provided. Must be a positive integer.")

        # Include nested fields with explicit paths to ensure they're included in the response
        ticket_fields = "id,summary,status/id,status/name,board/id,board/name,company/id,company/name,contact/id,contact/name,owner/id,owner/identifier,owner/name,priority/id,priority/name,closedFlag,dateEntered,initialDescription,type/id,type/name,subType/id,subType/name,item/id,item/name,lastUpdated"

        # Log the fields being requested for debugging
        logger.info(f"Requesting ticket fields: {ticket_fields}")

        ticket = manage_api_client.service.tickets.id(ticket_id).get(params={"fields": ticket_fields})

        # Log the received ticket object to verify field presence
        logger.debug(f"Received ticket object with attributes: {dir(ticket) if ticket else 'None'}")

        if not ticket:
            raise ValueError(f"Ticket with ID {ticket_id} not found.")

        notes_fields = "id,text,dateCreated,member/identifier,internalAnalysisFlag,resolutionFlag"
        notes = manage_api_client.service.tickets.id(ticket_id).notes.get(params={"pageSize": 10, "orderBy": "dateCreated desc", "fields": notes_fields})

        time_fields = "id,timeStart,notes,member/identifier,actualHours"
        time_entries = manage_api_client.time.entries.get(params={"conditions": f"ticket/id = {ticket_id}", "pageSize": 5, "orderBy": "timeStart desc", "fields": time_fields})

        # Log the nested objects to verify their presence
        status_obj = getattr(ticket, 'status', None)
        type_obj = getattr(ticket, 'type', None)
        subtype_obj = getattr(ticket, 'subType', None)
        item_obj = getattr(ticket, 'item', None)

        logger.debug(f"Status object: {dir(status_obj) if status_obj else 'None'}")
        logger.debug(f"Type object: {dir(type_obj) if type_obj else 'None'}")
        logger.debug(f"Subtype object: {dir(subtype_obj) if subtype_obj else 'None'}")
        logger.debug(f"Item object: {dir(item_obj) if item_obj else 'None'}")

        result_data: Dict[str, Any] = {"success": True}
        result_data.update({
            "ticket_id": getattr(ticket, 'id', None),
            "summary": getattr(ticket, 'summary', ""),  # Provide empty string default for required field
            "status": getattr(getattr(ticket, 'status', None), 'name', None),
            "board_id": getattr(getattr(ticket, 'board', None), 'id', None),
            "board_name": getattr(getattr(ticket, 'board', None), 'name', None),
            "company_id": getattr(getattr(ticket, 'company', None), 'id', None),
            "company_name": getattr(getattr(ticket, 'company', None), 'name', None),
            "contact_id": getattr(getattr(ticket, 'contact', None), 'id', None),
            "contact_name": getattr(getattr(ticket, 'contact', None), 'name', None),
            "owner_identifier": getattr(getattr(ticket, 'owner', None), 'identifier', None),
            "owner_name": getattr(getattr(ticket, 'owner', None), 'name', 'Unassigned'),
            "priority": getattr(getattr(ticket, 'priority', None), 'name', None),
            "closed": getattr(ticket, 'closedFlag', False),
            "date_entered": format_datetime(getattr(ticket, 'dateEntered', None)),
            "last_updated": format_datetime(getattr(ticket, 'lastUpdated', None)),
            "description": getattr(ticket, 'initialDescription', None),
            "ticket_type": getattr(getattr(ticket, 'type', None), 'name', None),
            "ticket_subtype": getattr(getattr(ticket, 'subType', None), 'name', None),
            "ticket_item": getattr(getattr(ticket, 'item', None), 'name', None),
            "notes": [],
            "time_entries": []
        })

        # Log the extracted data to verify field extraction
        logger.debug(f"Extracted ticket data: ticket_type={result_data['ticket_type']}, ticket_subtype={result_data['ticket_subtype']}, ticket_item={result_data['ticket_item']}")

        # Process notes
        for note in (notes or []):
            note_detail = {
                "id": getattr(note, 'id', None),
                "date": format_datetime(getattr(note, 'dateCreated', None)),
                "member": getattr(getattr(note, 'member', None), 'identifier', 'System'),
                "text": getattr(note, 'text', None),
                "is_internal": getattr(note, 'internalAnalysisFlag', False),
                "is_resolution": getattr(note, 'resolutionFlag', False)
            }
            result_data["notes"].append(note_detail)

        # Process time entries
        for entry in (time_entries or []):
            date_raw = getattr(entry, 'timeStart', None)
            time_detail = {
                "entry_id": getattr(entry, 'id', None),
                "date": format_datetime(date_raw) if isinstance(date_raw, str) else "",
                "member": getattr(getattr(entry, 'member', None), 'identifier', 'System'),
                "hours": getattr(entry, 'actualHours', None),
                "notes": getattr(entry, 'notes', None)
            }
            result_data["time_entries"].append(time_detail)

        return result_data

    except Exception as e:
        logger.error(f"Error in get_ticket_details_for_api: {e}")
        return {
            "success": False,
            "message": str(e),
            "error_type": type(e).__name__,
            "status_code": 500
        }

# --- Undecorated Helper for Core Logic ---
def add_ticket_note_impl(context: ToolContext, ticket_id: int, note_text: str, internal: bool, resolution: bool, note_type: Optional[str] = None) -> AddNoteResult:
    """Core logic to add a note to a ticket."""
    if not manage_api_client:
        return AddNoteResult(success=False, message="ConnectWise client not configured.")
    member_info: Optional[CwMemberInfo] = context.cw_member_info if context else None
    member_identifier = member_info.identifier if member_info else None
    member_id = member_info.id if member_info else None
    if not member_id:
        logger.error("Member info missing in context; cannot add note.")
        return AddNoteResult(success=False, error_type="AuthError", message="No member info in context to attribute note.")
    logger.info(f"Logic: Adding note by member {member_identifier} on ticket {ticket_id} (internal={internal}, resolution={resolution})")
    try:
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID.")
        if not note_text:
            raise ValueError("Note text cannot be empty.")
        # Determine the note type based on flags if not provided
        if not note_type:
            note_type = "Resolution" if resolution else ("Internal" if internal else "Discussion")

        # Create note payload according to PyConnectWise API requirements
        # The PyConnectWise library expects a specific format for the note payload
        note_data = {
            "text": note_text,
            "internalFlag": internal,
            "member": {"identifier": member_info.identifier if member_info and member_info.identifier else None},
            "noteType": {"name": note_type}
        }

        # Log the payload for debugging
        logger.info(f"Note payload: {note_data}")
        created_note = manage_api_client.service.tickets.id(ticket_id).notes.post(note_data) # type: ignore[arg-type]
        note_id = getattr(created_note, "id", None)
        if note_id:
            logger.info(f"Logic: Note ID {note_id} added to ticket {ticket_id} by member {member_identifier}.")
            return AddNoteResult(success=True, message=f"Note added to ticket {ticket_id}.", note_id=note_id)
        else:
            logger.error("Logic: Note creation returned no ID.")
            return AddNoteResult(success=False, error_type="APIError", message="Failed to confirm note creation.")
    except Exception as e:
        return _handle_cw_error(e, "add_ticket_note_impl", AddNoteResult, ticket_id=ticket_id, member=member_identifier, internal=internal, resolution=resolution)

# --- Agent Tool Definition ---
@function_tool()
# Remove 'context: ToolContext' from signature as it's retrieved via contextvar now
def add_ticket_note(ticket_id: int, note_text: str, internal: bool, resolution: bool, note_type: Optional[str] = None) -> AddNoteResult:
    """Add a note to a ticket. Uses the member info from the current request context.

    Required parameters:
    - ticket_id: The ID of the ticket to add a note to (must be a positive integer)
    - note_text: The content of the note (cannot be empty)
    - internal: Whether this note is internal (true) or visible to the customer (false)
    - resolution: Whether this note is a resolution note (true) or regular note (false)

    Optional parameters:
    - note_type: Type of note (e.g., 'Discussion', 'Internal', 'Resolution'). If not provided, will be determined based on internal/resolution flags.
    """
    logger.info("Tool 'add_ticket_note' called.")
    # Retrieve context from the context variable
    context = current_tool_context.get()
    if not context:
        logger.error("Tool 'add_ticket_note': Failed to retrieve ToolContext from context variable.")
        return AddNoteResult(success=False, error_type="InternalError", message="Internal context error.")
    logger.debug(f"Tool 'add_ticket_note': Retrieved context with member_info: {context.cw_member_info}")
    return add_ticket_note_impl(context, ticket_id, note_text, internal, resolution, note_type)

# --- Undecorated Helper for Core Logic ---
def change_ticket_status_impl(ticket_id: int, status_id: int) -> ChangeStatusResult:
    """Core logic to change the status of a ticket using the status ID directly."""
    if not manage_api_client:
        return ChangeStatusResult(success=False, message="ConnectWise client not configured.")

    logger.info(f"Logic: Changing ticket {ticket_id} status to ID {status_id}")

    try:
        # Validate parameters
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID provided. Must be a positive integer.")
        if status_id <= 0:
            raise ValueError("Invalid Status ID provided. Must be a positive integer.")

        # For development mode, simulate a successful status change
        if config.DEVELOPMENT_MODE:
            logger.warning("Simulating successful status change for development mode")
            return ChangeStatusResult(success=True, message=f"Ticket {ticket_id} status changed to ID {status_id}. (Simulated)")

        # In production, make the actual API call
        try:
            # Construct the PATCH payload
            patch_operations = [{"op": "replace", "path": "/status/id", "value": status_id}]

            # Call the ConnectWise API
            manage_api_client.service.tickets.id(ticket_id).patch(patch_operations) # type: ignore[arg-type]

            logger.info(f"Successfully changed ticket {ticket_id} status to ID {status_id}")

            # Clear relevant caches
            cache_clear('ticket_statuses')
            cache_clear('ticket_details')

            return ChangeStatusResult(success=True, message=f"Ticket {ticket_id} status changed to ID {status_id}.")
        except Exception as api_e:
            logger.error(f"API error changing ticket status: {api_e}")
            return _handle_cw_error(api_e, "change_ticket_status_api", ChangeStatusResult)
    except Exception as e:
        return _handle_cw_error(e, "change_ticket_status_impl", ChangeStatusResult, ticket_id=ticket_id, status_id=status_id)

# --- Agent Tool Definition ---
@function_tool()
def change_ticket_status(ticket_id: int, new_status_name: str, service_board_id: Optional[int] = None) -> ChangeStatusResult:
    """Change the status of a ticket.

    Required parameters:
    - ticket_id: The ID of the ticket to update (must be a positive integer)
    - new_status_name: The exact name of the new status (case-insensitive)

    Optional parameters:
    - service_board_id: The ID of the service board the ticket belongs to. If not provided, it will be automatically determined from the ticket details.
    """
    logger.info(f"Tool 'change_ticket_status' called with ticket_id={ticket_id}, new_status_name='{new_status_name}', service_board_id={service_board_id}")

    try:
        # Validate ticket_id
        if ticket_id <= 0:
            return ChangeStatusResult(success=False, message="Invalid Ticket ID provided. Must be a positive integer.")

        # Determine the board ID if not provided
        if service_board_id is None:
            try:
                # Get ticket details to extract board_id
                ticket_fields = "id,board/id"
                ticket = manage_api_client.service.tickets.id(ticket_id).get(params={"fields": ticket_fields})
                if not ticket:
                    return ChangeStatusResult(success=False, message=f"Ticket with ID {ticket_id} not found.")

                # Extract board_id from ticket
                service_board_id = getattr(getattr(ticket, 'board', None), 'id', None)

                if not service_board_id:
                    return ChangeStatusResult(success=False, message=f"Could not determine board ID for ticket {ticket_id}.")

                logger.info(f"Automatically determined board ID {service_board_id} for ticket {ticket_id}")
            except Exception as e:
                logger.error(f"Error getting board ID for ticket {ticket_id}: {e}")
                return ChangeStatusResult(success=False, message=f"Error determining board ID: {str(e)}")

        # Validate service_board_id
        if service_board_id <= 0:
            return ChangeStatusResult(success=False, message="Invalid board ID.")

        # Fetch statuses for the board
        try:
            statuses_raw = manage_api_client.service.boards.id(service_board_id).statuses.get()
            if not statuses_raw or len(statuses_raw) == 0:
                return ChangeStatusResult(success=False, message=f"No statuses found for board {service_board_id}.")

            # Log available statuses for debugging
            status_names = [getattr(s, 'name', 'Unknown') for s in statuses_raw]
            logger.info(f"Available statuses on board {service_board_id}: {status_names}")

            # Match status name to ID using robust matching
            status_obj = None

            # 1. Try exact case-insensitive match
            for s in statuses_raw:
                status_name = getattr(s, 'name', None)
                if status_name and status_name.lower() == new_status_name.lower():
                    status_obj = s
                    logger.info(f"Found exact case-insensitive match: '{status_name}' matches '{new_status_name}'")
                    break

            # 2. If no match, try without asterisks
            if not status_obj:
                clean_status_name = new_status_name.replace('*', '').strip()
                for s in statuses_raw:
                    status_name = getattr(s, 'name', None)
                    if status_name:
                        clean_status = status_name.replace('*', '').strip()
                        if clean_status.lower() == clean_status_name.lower():
                            status_obj = s
                            logger.info(f"Found match after removing asterisks: '{status_name}' matches '{clean_status_name}'")
                            break

            # If no matching status found, return error
            if not status_obj:
                return ChangeStatusResult(
                    success=False,
                    message=f"Status '{new_status_name}' not found on Board {service_board_id}. Available statuses: {', '.join(status_names)}"
                )

            # Extract the status ID and call the implementation function
            status_id = getattr(status_obj, 'id', None)
            if not status_id:
                return ChangeStatusResult(success=False, message=f"Found status '{new_status_name}' but it has no ID.")

            logger.info(f"Matched status name '{new_status_name}' to ID {status_id}")
            return change_ticket_status_impl(ticket_id=ticket_id, status_id=status_id)

        except Exception as e:
            logger.error(f"Error fetching statuses for board {service_board_id}: {e}")
            return ChangeStatusResult(success=False, message=f"Error fetching statuses: {str(e)}")

    except Exception as e:
        logger.error(f"Error in change_ticket_status: {e}")
        return ChangeStatusResult(success=False, message=f"Unexpected error: {str(e)}")

# --- Undecorated Helper for Core Logic ---
def create_new_ticket_impl(summary: str, company_name: str, service_board_id: int, contact_name: Optional[str] = None, priority_id: Optional[int] = None, details: Optional[str] = None) -> CreateTicketResult:
    """Core logic to create a new service ticket with the given summary, company, board, etc."""
    if not manage_api_client:
        return CreateTicketResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Creating ticket on board {service_board_id} for company '{company_name}'")
    try:
        if not summary or not company_name or service_board_id <= 0:
            raise ValueError("Summary, company name, and a valid board ID are required to create a ticket.")
        # Find company ID by name
        comp = manage_api_client.company.companies.get(params={"conditions": f"name=\"{company_name}\""}) # type: ignore[arg-type]
        company = comp[0] if comp else None
        if not company:
            raise ValueError(f"Company '{company_name}' not found.")
        company_id = getattr(company, "id", None)
        contact_id = None
        if contact_name:
            # Find contact in that company
            contacts = manage_api_client.company.contacts.get(params={ # type: ignore[arg-type]
                "conditions": f"company/id = {company_id} AND (name contains \"{contact_name}\" OR email contains \"{contact_name}\")"
            })
            contact = contacts[0] if contacts else None
            if not contact:
                raise ValueError(f"Contact '{contact_name}' not found in company ID {company_id}.")
            contact_id = getattr(contact, "id", None)
        # Build ticket payload
        ticket_payload = {
            "summary": summary,
            "company": {"id": company_id},
            "board": {"id": service_board_id}
        }
        if contact_id:
            ticket_payload["contact"] = {"id": contact_id}
        if priority_id:
            ticket_payload["priority"] = {"id": priority_id}
        if details:
            ticket_payload["initialDescription"] = details
        new_ticket = manage_api_client.service.tickets.post(ticket_payload) # type: ignore[arg-type]
        ticket_id = getattr(new_ticket, "id", None)
        if ticket_id:
            logger.info(f"Logic: New ticket {ticket_id} created on board {service_board_id} for company {company_name}.")
            return CreateTicketResult(success=True, message=f"Ticket {ticket_id} created successfully.", ticket_id=ticket_id)
        else:
            return CreateTicketResult(success=False, error_type="APIError", message="Ticket creation failed without a response ID.")
    except Exception as e:
        return _handle_cw_error(e, "create_new_ticket_impl", CreateTicketResult, summary=summary, company=company_name, board=service_board_id)

# --- Agent Tool Definition ---
@function_tool()
def create_new_ticket(summary: str, company_name: str, service_board_id: int, contact_name: Optional[str] = None, priority_id: Optional[int] = None, details: Optional[str] = None) -> CreateTicketResult:
    """Create a new service ticket with the given summary, company, board, etc.

    Required parameters:
    - summary: Brief description of the ticket issue (title)
    - company_name: Name of the company the ticket is for
    - service_board_id: ID of the service board to create the ticket on

    Optional parameters:
    - contact_name: Name of the primary contact for this ticket
    - priority_id: Priority ID for the ticket (if not provided, default priority will be used)
    - details: Detailed description of the issue
    """
    logger.info("Tool 'create_new_ticket' called, delegating to implementation function.")
    return create_new_ticket_impl(summary=summary, company_name=company_name, service_board_id=service_board_id, contact_name=contact_name, priority_id=priority_id, details=details)

# --- Undecorated Helper for Core Logic ---
def close_ticket_impl(ticket_id: int, service_board_id: int) -> CloseTicketResult:
    """Core logic to close a ticket."""
    if not manage_api_client:
        return CloseTicketResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Closing ticket {ticket_id} on board {service_board_id}")
    try:
        if ticket_id <= 0 or service_board_id <= 0:
            raise ValueError("Invalid ticket or board ID.")
        # Check if ticket already closed
        ticket = manage_api_client.service.tickets.id(ticket_id).get(params={"fields": "status/name,closedFlag"})
        if not ticket:
            raise ValueError(f"Ticket {ticket_id} not found.")
        if getattr(ticket, "closedFlag", False) is True:
            return CloseTicketResult(success=True, message=f"Ticket {ticket_id} is already closed.", already_closed=True)
        # Attempt to close - typically, ConnectWise might require setting a status to a "Closed" status
        statuses = manage_api_client.service.boards.id(service_board_id).statuses.get()

        # Get current status name
        current_status_name = getattr(getattr(ticket, 'status', None), 'name', '')

        # Define mapping for completed statuses to closed statuses
        closed_status_map = {
            "Completed": "Closed",
            "Completed*": "Closed",
            "Completed(FCR)": "Closed(FCR)",
            "Completed(FCR)*": "Closed(FCR)",
            "Completed(No Response)": "Closed(No Response)",
            "Completed(No Response)*": "Closed(No Response)",
        }

        # Try to find the appropriate closed status based on current status
        target_closed_status_name = closed_status_map.get(current_status_name, "Closed")

        # Try to find the status by name first
        closed_status = next((s for s in statuses if getattr(s, "name", "") == target_closed_status_name), None)

        # If not found, fall back to any closed status
        if not closed_status:
            closed_status = next((s for s in statuses if getattr(s, "closedFlag", False)), None)

        if not closed_status:
            raise ValueError("No 'closed' status found for this board.")

        closed_status_id = getattr(closed_status, "id")
        logger.info(f"Using closed status '{getattr(closed_status, 'name', 'Unknown')}' (ID: {closed_status_id}) for ticket {ticket_id}")
        # Create patches to update both status and closedFlag
        patches = [
            {"op": "replace", "path": "/status/id", "value": closed_status_id},
            {"op": "replace", "path": "/closedFlag", "value": True}
        ]
        manage_api_client.service.tickets.id(ticket_id).patch(patches) # type: ignore[arg-type]
        logger.info(f"Logic: Ticket {ticket_id} closed (status set to ID {closed_status_id}).")
        return CloseTicketResult(success=True, message=f"Ticket {ticket_id} closed successfully.")
    except Exception as e:
        return _handle_cw_error(e, "close_ticket_impl", CloseTicketResult, ticket_id=ticket_id, board_id=service_board_id)

# --- Agent Tool Definition ---
@function_tool()
def close_ticket(ticket_id: int, service_board_id: int) -> CloseTicketResult:
    """Close a ticket. Requires service board ID to validate the closure (some boards have specific close statuses).

    Required parameters:
    - ticket_id: The ID of the ticket to close (must be a positive integer)
    - service_board_id: The ID of the service board the ticket belongs to (must be a positive integer)
    """
    logger.info("Tool 'close_ticket' called, delegating to implementation function.")
    return close_ticket_impl(ticket_id=ticket_id, service_board_id=service_board_id)

# --- Undecorated Helper for Core Logic ---
def list_service_boards_impl() -> ListBoardsResult: # Revert return type
    """Core logic to list active service boards."""
    if not manage_api_client:
        return ListBoardsResult(success=False, message="ConnectWise client not configured.")

    # Check cache first
    cached_result = cache_get('boards')
    if cached_result is not None:
        logger.info("Using cached service boards")
        return cached_result

    try:
        boards_raw = manage_api_client.service.boards.get(params={"conditions": "inactiveFlag=false"})
        # --- DEBUG LOGGING START ---
        if boards_raw and isinstance(boards_raw, list) and len(boards_raw) > 0:
            first_board_raw = boards_raw[0]
            logger.info(f"Raw board object attributes: {dir(first_board_raw)}")
            try:
                 logger.info(f"Raw board sample data: id={getattr(first_board_raw, 'id', 'N/A')}, name={getattr(first_board_raw, 'name', 'N/A')}, identifier={getattr(first_board_raw, 'identifier', 'N/A')}")
                 if hasattr(first_board_raw, '_attrs'):
                     logger.info(f"Raw board _attrs: {first_board_raw._attrs}")
            except Exception as log_e:
                 logger.warning(f"Could not log raw board details: {log_e}")
        # --- DEBUG LOGGING END ---

        # Use direct getattr based on debug logs
        board_list = []
        for board in boards_raw or []:
            board_id = getattr(board, 'id', None)
            board_name = getattr(board, 'name', None)
            if board_id is not None: # Ensure ID is not null
                 board_list.append(BoardDetail(id=board_id, name=board_name))
            else:
                 logger.warning(f"Skipping board due to missing ID: {board}")

        result = ListBoardsResult(success=True, boards=board_list)

        # Cache the result
        cache_set('boards', result)

        logger.info(f"Logic: Successfully fetched and formatted {len(board_list)} active service boards.")
        return result
    except Exception as e:
        return _handle_cw_error(e, "list_service_boards_impl", ListBoardsResult)

# --- Agent Tool Definition ---
@function_tool()
def list_service_boards() -> ListBoardsResult:
    """List all active service boards available to the CW member."""
    # The decorated tool now simply calls the core logic helper
    logger.info("Tool 'list_service_boards' called, delegating to implementation function.")
    return list_service_boards_impl() # Call renamed helper

# --- Undecorated Helper for Core Logic ---
def list_ticket_statuses_impl(service_board_id: int) -> ListStatusesResult:
    """Core logic to list statuses for a given service board."""
    if not manage_api_client:
        return ListStatusesResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Fetching statuses for board_id={service_board_id}")
    logger.debug(f"DEVELOPMENT_MODE is {config.DEVELOPMENT_MODE}")
    try:
        if service_board_id <= 0:
            raise ValueError("Invalid board ID.")

        # For development mode, return comprehensive sample data
        if config.DEVELOPMENT_MODE:
            logger.warning(f"Using sample statuses for development mode (board_id={service_board_id})")
            status_list = [
                StatusDetail(id=1, name="New", is_closed=False),
                StatusDetail(id=2, name="In Progress", is_closed=False),
                StatusDetail(id=3, name="Waiting Customer", is_closed=False),
                StatusDetail(id=4, name="Waiting Vendor", is_closed=False),
                StatusDetail(id=5, name="Waiting Internal", is_closed=False),
                StatusDetail(id=6, name="On Hold", is_closed=False),
                StatusDetail(id=7, name="Scheduled", is_closed=False),
                StatusDetail(id=8, name="Escalated", is_closed=False),
                StatusDetail(id=9, name="Pending Approval", is_closed=False),
                StatusDetail(id=10, name="Approved", is_closed=False),
                StatusDetail(id=11, name="Rejected", is_closed=False),
                StatusDetail(id=12, name="In Review", is_closed=False),
                StatusDetail(id=13, name="Testing", is_closed=False),
                StatusDetail(id=14, name="Deployed", is_closed=False),
                StatusDetail(id=15, name="Resolved", is_closed=False),
                StatusDetail(id=16, name="Closed", is_closed=True),
                StatusDetail(id=17, name="Canceled", is_closed=True),
                StatusDetail(id=18, name="Duplicate", is_closed=True),
                StatusDetail(id=19, name="Reopened", is_closed=False),
                StatusDetail(id=20, name="Waiting Materials", is_closed=False),
                StatusDetail(id=21, name="Ready for Pickup", is_closed=False),
                StatusDetail(id=22, name="Picked Up", is_closed=True),
                StatusDetail(id=23, name="Remote Session", is_closed=False),
                StatusDetail(id=24, name="Dispatched", is_closed=False),
                StatusDetail(id=25, name="Arrived On Site", is_closed=False),
                StatusDetail(id=26, name="Completed On Site", is_closed=False),
                StatusDetail(id=27, name="Waiting Parts", is_closed=False),
                StatusDetail(id=28, name="Parts Received", is_closed=False),
                StatusDetail(id=29, name="Waiting Documentation", is_closed=False),
                StatusDetail(id=30, name="Documentation Complete", is_closed=False)
            ]
            logger.info(f"Development mode: Generated {len(status_list)} sample statuses")
        else:
            # In production, fetch from API
            logger.info(f"Production mode: Fetching statuses from API for board {service_board_id}")
            try:
                statuses_raw = manage_api_client.service.boards.id(service_board_id).statuses.get()
                logger.info(f"API returned statuses_raw type: {type(statuses_raw)}")

                # Log more details about the response
                if statuses_raw:
                    if isinstance(statuses_raw, list):
                        logger.info(f"API returned {len(statuses_raw)} statuses")
                        if len(statuses_raw) > 0:
                            first_status = statuses_raw[0]
                            logger.info(f"First status attributes: {dir(first_status)}")
                            logger.info(f"First status id: {getattr(first_status, 'id', None)}")
                            logger.info(f"First status name: {getattr(first_status, 'name', None)}")
                    else:
                        logger.info(f"API returned non-list statuses_raw: {statuses_raw}")
                else:
                    logger.info("API returned empty statuses_raw")

                # Process the statuses using direct attribute access
                status_list = [
                    StatusDetail(
                        id=getattr(status, 'id', None),
                        name=getattr(status, 'name', 'Unknown'),
                        is_closed=getattr(status, 'closedFlag', False)
                    )
                    for status in statuses_raw or [] if hasattr(status, 'id') and status.id is not None
                ]
                logger.info(f"Processed {len(status_list)} statuses from API response")

                # If API returned empty list, use development mode fallback
                if not status_list and config.DEVELOPMENT_MODE:
                    logger.warning(f"API returned empty statuses list, using development fallback for board {service_board_id}")
                    status_list = [
                        StatusDetail(id=1, name="New", is_closed=False),
                        StatusDetail(id=2, name="In Progress", is_closed=False),
                        StatusDetail(id=3, name="Waiting Customer", is_closed=False),
                        StatusDetail(id=16, name="Closed", is_closed=True),
                    ]
            except Exception as api_error:
                logger.error(f"Error fetching statuses from API: {api_error}")
                if config.DEVELOPMENT_MODE:
                    logger.warning(f"Using development fallback due to API error for board {service_board_id}")
                    status_list = [
                        StatusDetail(id=1, name="New", is_closed=False),
                        StatusDetail(id=2, name="In Progress", is_closed=False),
                        StatusDetail(id=3, name="Waiting Customer", is_closed=False),
                        StatusDetail(id=16, name="Closed", is_closed=True),
                    ]
                else:
                    # Re-raise the error if not in development mode
                    raise

        logger.info(f"Logic: Successfully fetched {len(status_list)} statuses for board {service_board_id}.")
        return ListStatusesResult(success=True, statuses=status_list)
    except Exception as e:
        return _handle_cw_error(e, "list_ticket_statuses_impl", ListStatusesResult, board_id=service_board_id)

# --- Agent Tool Definition ---
@function_tool()
def list_ticket_statuses(service_board_id: int) -> ListStatusesResult:
    """List all statuses for a given service board.

    Required parameters:
    - service_board_id: The ID of the service board to get statuses for (must be a positive integer)
    """
    logger.info("Tool 'list_ticket_statuses' called, delegating to implementation function.")
    return list_ticket_statuses_impl(service_board_id=service_board_id)

# --- Undecorated Helper for Core Logic ---
def get_ticket_statuses_impl(ticket_id: int) -> ListStatusesResult:
    """Core logic to get available statuses for a specific ticket by determining its board ID."""
    if not manage_api_client:
        return ListStatusesResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Getting available statuses for ticket {ticket_id}")

    # Check cache first
    cached_result = cache_get('ticket_statuses', ticket_id=ticket_id)
    if cached_result is not None:
        logger.info(f"Using cached statuses for ticket {ticket_id}")
        return cached_result

    try:
        # Get the ticket to determine its board ID
        try:
            # First try with minimal fields
            ticket_fields = "id,board/id"
            ticket = manage_api_client.service.tickets.id(ticket_id).get(params={"fields": ticket_fields})
        except Exception as e:
            logger.warning(f"Error getting ticket with minimal fields: {e}. Trying with all fields.")
            # If that fails, try getting the full ticket
            ticket = manage_api_client.service.tickets.id(ticket_id).get()

        if not ticket:
            return ListStatusesResult(success=False, message=f"Ticket with ID {ticket_id} not found.")

        # Extract board_id from ticket
        service_board_id = None

        # Log ticket details for debugging
        logger.info(f"Ticket attributes: {dir(ticket)}")
        logger.info(f"Ticket has board attribute: {hasattr(ticket, 'board')}")

        if hasattr(ticket, 'board') and ticket.board:
            logger.info(f"Board attributes: {dir(ticket.board)}")
            service_board_id = getattr(ticket.board, 'id', None)
            logger.info(f"Extracted board ID: {service_board_id}")
        else:
            logger.info("Ticket does not have a valid board attribute")

        if not service_board_id:
            # For development/testing, use a default board ID
            if config.DEVELOPMENT_MODE:
                logger.warning(f"Could not determine board ID for ticket {ticket_id}. Using default board ID 31 for development.")
                service_board_id = 31
            else:
                return ListStatusesResult(success=False, message=f"Could not determine board ID for ticket {ticket_id}.")

        # Now get the statuses for this board
        result = list_ticket_statuses_impl(service_board_id)

        # Cache the result if successful
        if result.success and result.statuses:
            cache_set('ticket_statuses', result, ticket_id=ticket_id)

        return result
    except Exception as e:
        return _handle_cw_error(e, "get_ticket_statuses_impl", ListStatusesResult, ticket_id=ticket_id)

# --- Agent Tool Definition ---
@function_tool()
def get_ticket_statuses(ticket_id: int) -> ListStatusesResult:
    """Get all available statuses for a specific ticket. This automatically determines the ticket's board ID."""
    logger.info(f"Tool 'get_ticket_statuses' called for ticket {ticket_id}, delegating to implementation function.")
    return get_ticket_statuses_impl(ticket_id=ticket_id)

# --- Undecorated Helper for Core Logic ---
def list_ticket_priorities_impl(board_id: Optional[int] = None) -> ListPrioritiesResult:
   """Core logic to list ticket priorities.

   Args:
       board_id: Optional board ID to filter priorities (currently not used as priorities are global)
   """
   if not manage_api_client:
       return ListPrioritiesResult(success=False, message="ConnectWise client not configured.")

   # Check cache first
   cache_key = f'priorities_{board_id}' if board_id else 'priorities_global'
   cached_result = cache_get(cache_key)
   if cached_result is not None:
       logger.info(f"Using cached priorities for board_id={board_id}")
       return cached_result

   try:
       # In ConnectWise Manage, priorities are typically global, not board-specific
       # But we still use board_id in the cache key for future flexibility
       logger.info(f"Fetching priorities (board_id={board_id})")
       logger.debug(f"DEVELOPMENT_MODE is {config.DEVELOPMENT_MODE}")

       # For development mode, return sample data
       if config.DEVELOPMENT_MODE:
           logger.warning("Using sample priorities for development mode")
           priority_list = [
               PriorityDetail(id=1, name="Low", sort=10),
               PriorityDetail(id=2, name="Medium", sort=20),
               PriorityDetail(id=3, name="High", sort=30),
               PriorityDetail(id=4, name="Critical", sort=40)
           ]
           logger.info(f"Development mode: Generated {len(priority_list)} sample priorities")
       else:
           # In production, fetch from API
           logger.info("Production mode: Fetching priorities from API")
           try:
               priorities_raw = manage_api_client.service.priorities.get() # Order by sort order
               logger.debug(f"API returned priorities_raw: {priorities_raw}")
               priority_list = [
                   PriorityDetail(
                       id=safe_get(p, "id"),
                       name=safe_get(p, "name"),
                       sort=safe_get(p, "sort")
                   )
                   for p in priorities_raw or [] if safe_get(p, "id") is not None # Ensure ID exists
               ]
               logger.info(f"Processed {len(priority_list)} priorities from API response")

               # If API returned empty list, use development mode fallback
               if not priority_list and config.DEVELOPMENT_MODE:
                   logger.warning("API returned empty priorities list, using development fallback")
                   priority_list = [
                       PriorityDetail(id=1, name="Low", sort=10),
                       PriorityDetail(id=2, name="Medium", sort=20),
                       PriorityDetail(id=3, name="High", sort=30),
                       PriorityDetail(id=4, name="Critical", sort=40)
                   ]
           except Exception as api_error:
               logger.error(f"Error fetching priorities from API: {api_error}")
               if config.DEVELOPMENT_MODE:
                   logger.warning("Using development fallback due to API error")
                   priority_list = [
                       PriorityDetail(id=1, name="Low", sort=10),
                       PriorityDetail(id=2, name="Medium", sort=20),
                       PriorityDetail(id=3, name="High", sort=30),
                       PriorityDetail(id=4, name="Critical", sort=40)
                   ]
               else:
                   # Re-raise the error if not in development mode
                   raise

       result = ListPrioritiesResult(success=True, priorities=priority_list)

       # Cache the result
       cache_set(cache_key, result)

       logger.info(f"Successfully fetched {len(priority_list)} priorities.")
       return result
   except Exception as e:
       return _handle_cw_error(e, "list_ticket_priorities_impl", ListPrioritiesResult, board_id=board_id)

# --- Undecorated Helper for Core Logic ---
def get_ticket_priorities_impl(ticket_id: int) -> ListPrioritiesResult:
    """Core logic to get available priorities for a specific ticket by determining its board ID."""
    if not manage_api_client:
        return ListPrioritiesResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Getting available priorities for ticket {ticket_id}")

    # Check cache first
    cached_result = cache_get('ticket_priorities', ticket_id=ticket_id)
    if cached_result is not None:
        logger.info(f"Using cached priorities for ticket {ticket_id}")
        return cached_result

    try:
        # Get the ticket to determine its board ID
        try:
            # First try with minimal fields
            ticket_fields = "id,board/id"
            ticket = manage_api_client.service.tickets.id(ticket_id).get(params={"fields": ticket_fields})
        except Exception as e:
            logger.warning(f"Error getting ticket with minimal fields: {e}. Trying with all fields.")
            # If that fails, try getting the full ticket
            ticket = manage_api_client.service.tickets.id(ticket_id).get()

        if not ticket:
            return ListPrioritiesResult(success=False, message=f"Ticket with ID {ticket_id} not found.")

        # Extract board_id from ticket
        board_id = None
        if hasattr(ticket, 'board') and ticket.board:
            board_id = getattr(ticket.board, 'id', None)

        if not board_id:
            # For development/testing, use a default board ID
            if config.DEVELOPMENT_MODE:
                logger.warning(f"Could not determine board ID for ticket {ticket_id}. Using default board ID 31 for development.")
                board_id = 31
            else:
                return ListPrioritiesResult(success=False, message=f"Could not determine board ID for ticket {ticket_id}.")

        # Now get the priorities (currently not filtered by board, but could be in the future)
        result = list_ticket_priorities_impl(board_id)

        # Cache the result if successful
        if result.success and result.priorities:
            cache_set('ticket_priorities', result, ticket_id=ticket_id)

        return result
    except Exception as e:
        return _handle_cw_error(e, "get_ticket_priorities_impl", ListPrioritiesResult, ticket_id=ticket_id)

# --- Agent Tool Definition ---
@function_tool()
def list_ticket_priorities(board_id: Optional[int] = None) -> ListPrioritiesResult:
   """Lists all available ticket priorities."""
   logger.info("Tool 'list_ticket_priorities' called, delegating to implementation function.")
   return list_ticket_priorities_impl(board_id=board_id)

# --- Agent Tool Definition ---
@function_tool()
def get_ticket_priorities(ticket_id: int) -> ListPrioritiesResult:
   """Get all available priorities for a specific ticket. This automatically determines the ticket's board ID."""
   logger.info(f"Tool 'get_ticket_priorities' called for ticket {ticket_id}, delegating to implementation function.")
   return get_ticket_priorities_impl(ticket_id=ticket_id)

# --- Undecorated Helper for Core Logic ---
def get_board_types_impl(board_id: int) -> ListTypesResult:
    """Core logic to list all available types for a specific service board."""
    if not manage_api_client:
        return ListTypesResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Listing types for board_id={board_id}")
    try:
        if board_id <= 0:
            raise ValueError("Invalid Board ID.")
        # Get types for the board
        types_raw = manage_api_client.service.boards.id(board_id).types.get() # type: ignore[attr-defined]
        types = []
        for t in types_raw:
            types.append(TypeDetail(
                id=getattr(t, 'id', None),
                name=getattr(t, 'name', None),
                board_id=board_id,
                inactive_flag=getattr(t, 'inactiveFlag', False),
            ))
        logger.info(f"Logic: Found {len(types)} types for board_id={board_id}")
        return ListTypesResult(success=True, types=types)
    except Exception as e:
        logger.error(f"Logic: Failed to list types for board_id={board_id}: {e}")
        return ListTypesResult(success=False, message=f"Failed to list types: {str(e)}")

# --- Agent Tool Definition ---
@function_tool()
def get_board_types(board_id: int) -> ListTypesResult:
    """List all available types for a specific service board.

    Required parameters:
    - board_id: The ID of the service board to get types for (must be a positive integer)
    """
    logger.info(f"Tool 'get_board_types' called for board {board_id}, delegating to implementation function.")
    return get_board_types_impl(board_id=board_id)

# --- Undecorated Helper for Core Logic ---
def get_type_subtypes_impl(board_id: int, type_id: int) -> ListSubtypesResult:
    """Core logic to list all available subtypes for a specific service board type."""
    if not manage_api_client:
        return ListSubtypesResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Listing subtypes for board_id={board_id}, type_id={type_id}")
    try:
        if board_id <= 0 or type_id <= 0:
            raise ValueError("Invalid Board ID or Type ID.")
        # Get subtypes for the type
        subtypes_raw = manage_api_client.service.boards.id(board_id).types.id(type_id).subtypes.get() # type: ignore[attr-defined]
        subtypes = []
        for st in subtypes_raw:
            subtypes.append(SubtypeDetail(
                id=getattr(st, 'id', None),
                name=getattr(st, 'name', None),
                type_id=type_id,
                inactive_flag=getattr(st, 'inactiveFlag', False),
            ))
        logger.info(f"Logic: Found {len(subtypes)} subtypes for board_id={board_id}, type_id={type_id}")
        return ListSubtypesResult(success=True, subtypes=subtypes)
    except Exception as e:
        logger.error(f"Logic: Failed to list subtypes for board_id={board_id}, type_id={type_id}: {e}")
        return ListSubtypesResult(success=False, message=f"Failed to list subtypes: {str(e)}")

# --- Agent Tool Definition ---
@function_tool()
def get_type_subtypes(board_id: int, type_id: int) -> ListSubtypesResult:
    """List all available subtypes for a specific service board type.

    Required parameters:
    - board_id: The ID of the service board (must be a positive integer)
    - type_id: The ID of the type to get subtypes for (must be a positive integer)
    """
    logger.info(f"Tool 'get_type_subtypes' called for board {board_id}, type {type_id}, delegating to implementation function.")
    return get_type_subtypes_impl(board_id=board_id, type_id=type_id)

# --- Undecorated Helper for Core Logic ---
def get_subtype_items_impl(board_id: int, subtype_id: int) -> ListItemsResult:
    """Core logic to list all available items for a specific service board subtype."""
    if not manage_api_client:
        return ListItemsResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Listing items for board_id={board_id}, subtype_id={subtype_id}")
    try:
        if board_id <= 0 or subtype_id <= 0:
            raise ValueError("Invalid Board ID or Subtype ID.")
        # Get items for the subtype
        # Note: We need to find the type_id first since the API requires the full path
        # This is a bit inefficient but necessary for the ConnectWise API structure

        # First, get all types for the board
        types_raw = manage_api_client.service.boards.id(board_id).types.get() # type: ignore[attr-defined]

        # Find which type contains this subtype
        type_id = None
        for t in types_raw:
            subtypes_raw = manage_api_client.service.boards.id(board_id).types.id(t.id).subtypes.get() # type: ignore[attr-defined, arg-type]
            for st in subtypes_raw:
                if st.id == subtype_id:
                    type_id = t.id
                    break
            if type_id:
                break

        if not type_id:
            raise ValueError(f"Could not find type containing subtype_id={subtype_id} for board_id={board_id}")

        # Now get the items
        items_raw = manage_api_client.service.boards.id(board_id).types.id(type_id).subtypes.id(subtype_id).items.get() # type: ignore[attr-defined]
        items = []
        for item in items_raw:
            items.append(ItemDetail(
                id=getattr(item, 'id', None),
                name=getattr(item, 'name', None),
                subtype_id=subtype_id,
                inactive_flag=getattr(item, 'inactiveFlag', False),
            ))
        logger.info(f"Logic: Found {len(items)} items for board_id={board_id}, type_id={type_id}, subtype_id={subtype_id}")
        return ListItemsResult(success=True, items=items)
    except Exception as e:
        logger.error(f"Logic: Failed to list items for board_id={board_id}, subtype_id={subtype_id}: {e}")
        return ListItemsResult(success=False, message=f"Failed to list items: {str(e)}")

# --- Agent Tool Definition ---
@function_tool()
def get_subtype_items(board_id: int, subtype_id: int) -> ListItemsResult:
    """List all available items for a specific service board subtype.

    Required parameters:
    - board_id: The ID of the service board (must be a positive integer)
    - subtype_id: The ID of the subtype to get items for (must be a positive integer)
    """
    logger.info(f"Tool 'get_subtype_items' called for board {board_id}, subtype {subtype_id}, delegating to implementation function.")
    return get_subtype_items_impl(board_id=board_id, subtype_id=subtype_id)



# --- Undecorated Helper for Core Logic ---
def find_company_impl(company_name_or_identifier: str) -> FindCompanyResult:
    """Core logic to find a company by name or identifier."""
    if not manage_api_client:
        return FindCompanyResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Searching for company with name/identifier: '{company_name_or_identifier}'")
    try:
        if not company_name_or_identifier:
            raise ValueError("Company name or identifier cannot be empty.")
            
        # Minimum character requirement for fuzzy search - 2 characters
        if len(company_name_or_identifier) < 2:
            return FindCompanyResult(
                success=False, 
                message="Please enter at least 2 characters for company search."
            )

        # Cast manage_api_client to avoid None type errors
        api_client = cast(ConnectWiseClient, manage_api_client)

        # Modified search logic for fuzzy search:
        # Use LIKE operator for name to get more matches with '%' wildcards on both ends
        # Keep identifier as exact match for when we know the precise identifier
        conditions = f"(name like '%{company_name_or_identifier}%') or (identifier = '{company_name_or_identifier}')"
        fields = "id,name,identifier,types/name,phoneNumber,website"
        
        # Increase result limit to show more potential matches
        params = {"conditions": conditions, "pageSize": 10, "fields": fields}

        companies_raw = api_client.company.companies.get(params=params)

        # Return multiple company matches if found
        if companies_raw and isinstance(companies_raw, list):
            if len(companies_raw) > 0:
                # For single match, return the same response format as before
                if len(companies_raw) == 1:
                    company_data = companies_raw[0]
                    company_detail = CompanyDetail(
                        id=safe_get(company_data, "id"),
                        name=safe_get(company_data, "name"),
                        identifier=safe_get(company_data, "identifier"),
                        type_name=safe_get(company_data, "types.name"),
                        phone_number=safe_get(company_data, "phoneNumber"),
                        website=safe_get(company_data, "website")
                    )
                    if company_detail.id:
                        logger.info(f"Logic: Found exact company match '{company_detail.name}' (ID: {company_detail.id})")
                        return FindCompanyResult(success=True, found=True, company=company_detail)
                    else:
                        logger.error(f"Logic: Found company record for '{company_name_or_identifier}' but missing ID: {company_data}")
                        return FindCompanyResult(success=True, found=False, message=f"Found company record for '{company_name_or_identifier}' but it's incomplete.")
                
                # For multiple matches, return all of them in the matches field
                else:
                    companies = []
                    for company_data in companies_raw:
                        company_detail = CompanyDetail(
                            id=safe_get(company_data, "id"),
                            name=safe_get(company_data, "name"),
                            identifier=safe_get(company_data, "identifier"),
                            type_name=safe_get(company_data, "types.name"),
                            phone_number=safe_get(company_data, "phoneNumber"),
                            website=safe_get(company_data, "website")
                        )
                        if company_detail.id:
                            companies.append(company_detail)
                    
                    logger.info(f"Logic: Found {len(companies)} potential company matches for '{company_name_or_identifier}'")
                    # Use the first company as the main result for backward compatibility
                    return FindCompanyResult(
                        success=True, 
                        found=True, 
                        company=companies[0], 
                        matches=companies,
                        message=f"Found {len(companies)} potential matches."
                    )
        
        logger.info(f"Logic: No company found matching '{company_name_or_identifier}'.")
        return FindCompanyResult(success=True, found=False, message=f"No company found matching '{company_name_or_identifier}'.")

    except Exception as e:
        return _handle_cw_error(e, "find_company_impl", FindCompanyResult, company_query=company_name_or_identifier)

# --- Agent Tool Definition ---
@function_tool()
def find_company(company_name_or_identifier: str) -> FindCompanyResult:
    """Find a company by its name or identifier."""
    logger.info(f"Tool 'find_company' called for '{company_name_or_identifier}', delegating to implementation.")
    return find_company_impl(company_name_or_identifier=company_name_or_identifier)

# --- Undecorated Helper for Core Logic ---
def find_contact_impl(company_id: int, contact_name: str) -> FindContactResult:
    """Core logic to find a contact by name within a given company."""
    if not manage_api_client:
        return FindContactResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Searching for contact '{contact_name}' in company ID {company_id}")
    try:
        if company_id <= 0 or not contact_name:
            raise ValueError("Company ID and contact name are required.")
            
        # Minimum character requirement for fuzzy search - 2 characters
        if len(contact_name) < 2:
            return FindContactResult(
                success=False, 
                message="Please enter at least 2 characters for contact search."
            )

        # Construct a simpler conditions parameter with the correct syntax for ConnectWise API
        # Use LIKE operator for fuzzy matching with wildcards on both ends 
        conditions = f"company/id={company_id} AND name like '%{contact_name}%'"

        # Add detailed logging before the API call
        logger.info(f"API Request: Searching contacts with conditions: {conditions}")

        # Prepare params with conditions and fields to retrieve
        # Include more fields for better contact information
        params = {
            "conditions": conditions,
            "fields": "id,name,firstName,lastName,communicationItems,title,emailAddress,phoneNumber,mobilePhone",
            "pageSize": 10  # Increase page size to show more potential matches
        }
        logger.debug(f"API Request params: {params}")

        contacts = manage_api_client.company.contacts.get(params=params) # type: ignore[arg-type]

        logger.info(f"API Response: Found {len(contacts) if contacts else 0} contacts matching '{contact_name}' in company {company_id}")

        if contacts and len(contacts) > 0:
            # For multiple contacts, return all matches
            if len(contacts) > 1:
                contact_list = []
                for contact in contacts:
                    # Extract email from communicationItems if available
                    email = getattr(contact, "emailAddress", None)
                    if not email:
                        comm_items = getattr(contact, "communicationItems", [])
                        if comm_items and len(comm_items) > 0:
                            for item in comm_items:
                                if getattr(item, "communicationType", "") == "Email":
                                    email = getattr(item, "value", None)
                                    break
                    
                    contact_detail = ContactDetail(
                        id=getattr(contact, "id", None),
                        name=getattr(contact, "name", None),
                        first_name=getattr(contact, "firstName", None),
                        last_name=getattr(contact, "lastName", None),
                        email=email,
                        phone_number=getattr(contact, "phoneNumber", None),
                        mobile_number=getattr(contact, "mobilePhone", None),
                        title=getattr(contact, "title", None),
                        company_id=company_id
                    )
                    contact_list.append(contact_detail)
                
                # Return the first contact as the main result for backward compatibility
                # Include all matches in the matches field
                return FindContactResult(
                    success=True, 
                    found=True, 
                    contact=contact_list[0],
                    matches=contact_list,
                    message=f"Found {len(contact_list)} potential contact matches."
                )
            
            # For a single contact, use the previous format
            contact = contacts[0]
            email = getattr(contact, "emailAddress", None)
            if not email:
                comm_items = getattr(contact, "communicationItems", [])
                if comm_items and len(comm_items) > 0:
                    for item in comm_items:
                        if getattr(item, "communicationType", "") == "Email":
                            email = getattr(item, "value", None)
                            break

            contact_details = ContactDetail(
                id=getattr(contact, "id", None),
                name=getattr(contact, "name", None),
                first_name=getattr(contact, "firstName", None),
                last_name=getattr(contact, "lastName", None),
                email=email,
                phone_number=getattr(contact, "phoneNumber", None),
                mobile_number=getattr(contact, "mobilePhone", None),
                title=getattr(contact, "title", None),
                company_id=company_id
            )
            return FindContactResult(success=True, found=True, contact=contact_details)
        else:
            return FindContactResult(success=True, found=False, message=f"No contact found matching '{contact_name}' in company {company_id}.")
    except Exception as e:
        logger.error(f"Error in find_contact_impl: {str(e)}")
        return _handle_cw_error(e, "find_contact_impl", FindContactResult, company_id=company_id, name=contact_name)

# --- Agent Tool Definition ---
@function_tool()
def find_contact(company_id: int, contact_name: str) -> FindContactResult:
    """Find a contact by name within a given company (by company_id)."""
    logger.info("Tool 'find_contact' called, delegating to implementation function.")
    return find_contact_impl(company_id=company_id, contact_name=contact_name)

# --- Undecorated Helper for Core Logic ---
# find_company_impl already exists above

# --- Agent Tool Definition ---
# find_company already exists above

# --- Undecorated Helper for Core Logic ---
# find_contact_impl already exists above

# --- Agent Tool Definition ---
# find_contact already exists above

# --- Undecorated Helper for Core Logic ---
def get_company_details_impl(company_id: int) -> GetCompanyDetailsResult:
    """Core logic to get detailed information about a company."""
    if not manage_api_client:
        return GetCompanyDetailsResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Getting detailed information for company ID {company_id}")
    try:
        if company_id <= 0:
            raise ValueError("Invalid company ID.")

        # Get company details with expanded fields
        fields = "id,name,identifier,status/name,addressLine1,addressLine2,city,state,zip,country/name,phoneNumber,faxNumber,website,types/name,territory/name"
        company_raw = manage_api_client.company.companies.id(company_id).get(params={"fields": fields})

        if not company_raw:
            return GetCompanyDetailsResult(success=False, message=f"Company with ID {company_id} not found.")

        # Extract company details
        company_detail = CompanyDetail(
            id=getattr(company_raw, "id", None),
            name=getattr(company_raw, "name", None),
            identifier=getattr(company_raw, "identifier", None),
            status=safe_get(company_raw, "status.name"),
            address_line1=getattr(company_raw, "addressLine1", None),
            address_line2=getattr(company_raw, "addressLine2", None),
            city=getattr(company_raw, "city", None),
            state=getattr(company_raw, "state", None),
            zip=getattr(company_raw, "zip", None),
            country=safe_get(company_raw, "country.name"),
            phone_number=getattr(company_raw, "phoneNumber", None),
            fax_number=getattr(company_raw, "faxNumber", None),
            website=getattr(company_raw, "website", None),
            type_name=safe_get(company_raw, "types.name"),
            territory_name=safe_get(company_raw, "territory.name")
        )

        return GetCompanyDetailsResult(success=True, company=company_detail)
    except Exception as e:
        return _handle_cw_error(e, "get_company_details_impl", GetCompanyDetailsResult, company_id=company_id)

# --- Agent Tool Definition ---
@function_tool()
def get_company_details(company_id: int) -> GetCompanyDetailsResult:
    """Get detailed information about a company by its ID."""
    logger.info(f"Tool 'get_company_details' called for company ID {company_id}, delegating to implementation.")
    return get_company_details_impl(company_id=company_id)

# --- Undecorated Helper for Core Logic ---
def get_company_contacts_impl(company_id: int) -> GetCompanyContactsResult:
    """Core logic to get all contacts for a company."""
    if not manage_api_client:
        return GetCompanyContactsResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Getting contacts for company ID {company_id}")
    try:
        if company_id <= 0:
            raise ValueError("Invalid company ID.")

        # Get company name first
        company_raw = manage_api_client.company.companies.id(company_id).get(params={"fields": "id,name"})
        if not company_raw:
            return GetCompanyContactsResult(success=False, message=f"Company with ID {company_id} not found.")

        company_name = getattr(company_raw, "name", None)

        # Get contacts for the company
        fields = "id,firstName,lastName,title,phoneNumber,mobilePhone,faxNumber,emailAddress,addressLine1,addressLine2,city,state,zip,country,company/id,company/name,site/id,site/name,inactiveFlag"
        contacts_raw = manage_api_client.company.contacts.get(params={
            "conditions": f"company/id = {company_id}",
            "fields": fields,
            "pageSize": 100
        })

        if not contacts_raw:
            return GetCompanyContactsResult(
                success=True,
                contacts=[],
                total_count=0,
                company_id=company_id,
                company_name=company_name
            )

        # Process contacts
        contacts = []
        for contact in contacts_raw:
            contact_detail = ContactDetail(
                id=getattr(contact, "id", None),
                name=f"{getattr(contact, 'firstName', '')} {getattr(contact, 'lastName', '')}".strip(),
                first_name=getattr(contact, "firstName", None),
                last_name=getattr(contact, "lastName", None),
                email=getattr(contact, "emailAddress", None),
                title=getattr(contact, "title", None),
                phone_number=getattr(contact, "phoneNumber", None),
                mobile_number=getattr(contact, "mobilePhone", None),
                fax_number=getattr(contact, "faxNumber", None),
                address_line1=getattr(contact, "addressLine1", None),
                address_line2=getattr(contact, "addressLine2", None),
                city=getattr(contact, "city", None),
                state=getattr(contact, "state", None),
                zip=getattr(contact, "zip", None),
                country=getattr(contact, "country", None),
                company_id=company_id,
                company_name=company_name,
                site_id=safe_get(contact, "site.id"),
                site_name=safe_get(contact, "site.name"),
                inactive_flag=getattr(contact, "inactiveFlag", False)
            )
            contacts.append(contact_detail)

        return GetCompanyContactsResult(
            success=True,
            contacts=contacts,
            total_count=len(contacts),
            company_id=company_id,
            company_name=company_name
        )
    except Exception as e:
        return _handle_cw_error(e, "get_company_contacts_impl", GetCompanyContactsResult, company_id=company_id)

# --- Agent Tool Definition ---
@function_tool()
def get_company_contacts(company_id: int) -> GetCompanyContactsResult:
    """Get all contacts for a company by its ID."""
    logger.info(f"Tool 'get_company_contacts' called for company ID {company_id}, delegating to implementation.")
    return get_company_contacts_impl(company_id=company_id)

# --- Undecorated Helper for Core Logic ---
def get_company_tickets_impl(company_id: int, board_id: Optional[int] = None) -> QueryTicketsResult:
    """Core logic to get tickets for a company, optionally filtered by service board ID."""
    if not manage_api_client:
        return QueryTicketsResult(success=False, tickets=[], total_found=0, message="ConnectWise client not configured.")
    logger.info(f"Logic: Getting tickets for company ID {company_id}" + (f" filtered by board ID {board_id}" if board_id else ""))
    try:
        if company_id <= 0:
            raise ValueError("Invalid company ID.")

        # Build conditions
        conditions = [f"company/id = {company_id}"]
        if board_id is not None and board_id > 0:
            conditions.append(f"board/id = {board_id}")

        # Get tickets
        fields = "id,summary,status/name,board/id,board/name,company/id,company/name,contact/id,contact/name,owner/identifier,priority/name,dateEntered,type/name,subType/name,item/name"
        tickets_raw = manage_api_client.service.tickets.get(params={
            "conditions": " AND ".join(conditions),
            "fields": fields,
            "pageSize": 100,
            "orderBy": "dateEntered desc"
        })

        if not tickets_raw:
            return QueryTicketsResult(success=True, tickets=[], total_found=0)

        # Process tickets
        tickets = []
        for ticket in tickets_raw:
            ticket_summary = TicketSummary(
                ticket_id=getattr(ticket, "id", None),
                summary=getattr(ticket, "summary", None),
                status=safe_get(ticket, "status.name"),
                board_id=safe_get(ticket, "board.id"),
                board_name=safe_get(ticket, "board.name"),
                company_id=safe_get(ticket, "company.id"),
                company_name=safe_get(ticket, "company.name"),
                contact_id=safe_get(ticket, "contact.id"),
                contact_name=safe_get(ticket, "contact.name"),
                owner_identifier=safe_get(ticket, "owner.identifier"),
                priority=safe_get(ticket, "priority.name"),
                date_entered=getattr(ticket, "dateEntered", None),
                # Use the correct field names as defined in the TicketSummary model
                ticket_type=safe_get(ticket, "type.name"),
                ticket_subtype=safe_get(ticket, "subType.name"),
                ticket_item=safe_get(ticket, "item.name")
            )
            tickets.append(ticket_summary)

        return QueryTicketsResult(success=True, tickets=tickets, total_found=len(tickets))
    except Exception as e:
        return _handle_cw_error(e, "get_company_tickets_impl", QueryTicketsResult, company_id=company_id, board_id=board_id)

# --- Agent Tool Definition ---
@function_tool()
def get_company_tickets(company_id: int, board_id: Optional[int] = None) -> QueryTicketsResult:
    """Get tickets for a company, optionally filtered by service board ID."""
    logger.info(f"Tool 'get_company_tickets' called for company ID {company_id}" + (f" filtered by board ID {board_id}" if board_id else "") + ", delegating to implementation.")
    return get_company_tickets_impl(company_id=company_id, board_id=board_id)

# Undecorated helper function for direct use (e.g., in auth context)
def _find_member_details_sync(member_identifier: str) -> Optional[Dict[str, Any]]:
    """
    Synchronously finds member details by identifier (username) or office email, mimicking old version.
    Returns details dict or None.
    """
    if not manage_api_client:
        logger.error("Cannot find member details: ConnectWise client not configured.")
        return None
    if not member_identifier:
        logger.error("Cannot find member details: Member identifier is required.")
        return None
        
    # Minimum character requirement for fuzzy search - 2 characters
    if len(member_identifier) < 2:
        logger.warning("Member search requires at least 2 characters.")
        return None

    # Check cache first
    cached_result = cache_get('members', member_identifier=member_identifier)
    if cached_result is not None:
        logger.info(f"Using cached member details for '{member_identifier}'")
        return cached_result

    logger.info(f"Attempting to find CW member by identifier or email: '{member_identifier}'")
    fields_to_get = "id,identifier,firstName,lastName,officeEmail,inactiveFlag"
    endpoint = manage_api_client.system.members
    found_members = []

    # 1. Try fuzzy search using LIKE operator
    try:
        # Use a more flexible search condition with wildcards
        fuzzy_condition = f"identifier like '%{member_identifier}%' OR firstName like '%{member_identifier}%' OR lastName like '%{member_identifier}%' OR officeEmail like '%{member_identifier}%'"
        params_fuzzy = {"conditions": fuzzy_condition, "pageSize": 10, "fields": fields_to_get}
        logger.debug(f"Searching members with fuzzy conditions: {fuzzy_condition}")
        
        response_fuzzy = endpoint._make_request("GET", params=params_fuzzy)
        response_fuzzy.raise_for_status()
        members_fuzzy = response_fuzzy.json()
        
        if members_fuzzy and isinstance(members_fuzzy, list) and len(members_fuzzy) > 0:
            logger.info(f"Found {len(members_fuzzy)} potential member matches")
            # Filter out inactive members
            active_members = [m for m in members_fuzzy if not m.get('inactiveFlag', False)]
            found_members = active_members
    except ConnectWiseException as cw_e:
        log_level = logging.WARNING
        logger.log(log_level, f"API error in fuzzy member search for '{member_identifier}': {cw_e}", exc_info=False)
    except Exception as e:
        logger.error(f"Unexpected error in fuzzy member search for '{member_identifier}': {e}", exc_info=True)
        
    # Process found members (if any)
    if found_members:
        # Sort by most relevant - exact identifier matches first, then by firstName+lastName
        exact_identifier_matches = [m for m in found_members if m.get('identifier', '').lower() == member_identifier.lower()]
        if exact_identifier_matches:
            member_data = exact_identifier_matches[0]  # Prioritize exact identifier match
        else:
            member_data = found_members[0]  # Otherwise, take the first result
            
        member_id = safe_get(member_data, 'id')
        identifier = safe_get(member_data, 'identifier')
        is_inactive = safe_get(member_data, 'inactiveFlag', False)
        
        if member_id and identifier and not is_inactive:
            logger.info(f"Successfully matched ACTIVE CW Member: {identifier} (ID: {member_id})")
            result = {
                "id": member_id,
                "identifier": identifier,
                "name": f"{safe_get(member_data, 'firstName', '')} {safe_get(member_data, 'lastName', '')}".strip(),
                "email": safe_get(member_data, 'officeEmail'),
                "matches": found_members if len(found_members) > 1 else None  # Include all matches if multiple found
            }
            # Cache the result
            cache_set('members', result, member_identifier=member_identifier)
            return result
    
    logger.warning(f"No active member found for '{member_identifier}'.")
    return None

# --- Undecorated Helper for Core Logic ---
def find_member_impl(member_identifier: str) -> FindMemberResult:
    """Core logic to find a member by identifier (username or email)."""
    logger.info(f"Logic: Searching for member with identifier: '{member_identifier}'")
    
    # Basic validation
    if not member_identifier:
        return FindMemberResult(
            success=False, 
            found=False, 
            message="Member identifier cannot be empty."
        )
    
    # Minimum character requirement for fuzzy search
    if len(member_identifier) < 2:
        return FindMemberResult(
            success=False, 
            found=False, 
            message="Please enter at least 2 characters for member search."
        )
    
    member_details_dict = _find_member_details_sync(member_identifier)

    if member_details_dict:
        # Check if we have multiple matches
        matches = member_details_dict.get('matches')
        if matches and len(matches) > 1:
            # Process multiple matches
            member_details = []
            for member_data in matches:
                member_detail = MemberDetail(
                    id=safe_get(member_data, 'id'),
                    identifier=safe_get(member_data, 'identifier'),
                    name=f"{safe_get(member_data, 'firstName', '')} {safe_get(member_data, 'lastName', '')}".strip(),
                    email=safe_get(member_data, 'officeEmail')
                )
                member_details.append(member_detail)
            
            # Create a response with the primary match and all potential matches
            primary_member = MemberDetail(
                id=member_details_dict['id'],
                identifier=member_details_dict['identifier'],
                name=member_details_dict['name'],
                email=member_details_dict.get('email')
            )
            
            return FindMemberResult(
                success=True, 
                found=True, 
                member=primary_member, 
                matches=member_details,
                message=f"Found {len(member_details)} potential member matches."
            )
        else:
            # Single match case - return as before
            member_details_model = MemberDetail(**{k: v for k, v in member_details_dict.items() if k != 'matches'})
            return FindMemberResult(success=True, found=True, member=member_details_model)
    elif member_details_dict is None and manage_api_client:
        return FindMemberResult(success=True, found=False, message=f"No member found for identifier '{member_identifier}'.")
    else:
        return FindMemberResult(success=False, found=False, message="Failed to search for member due to an internal error.")

# --- Agent Tool Definition ---
@function_tool()
def find_member(member_identifier: str) -> FindMemberResult:
    """Find a member (employee/user) by their identifier (username or email). This is a tool for the agent."""
    logger.info("Tool 'find_member' called, delegating to implementation function.")
    return find_member_impl(member_identifier=member_identifier)

# --- Undecorated Helper for Core Logic ---
def add_time_entry_impl(context: ToolContext, ticket_id: int, notes: str, actual_hours: float, billable_option: str,
                       time_start: Optional[str] = None, time_end: Optional[str] = None,
                       work_type_id: Optional[int] = None, work_role_id: Optional[int] = None,
                       location_id: Optional[int] = None, email_contact: Optional[bool] = None,
                       email_resource: Optional[bool] = None, email_cc: Optional[bool] = None,
                       new_status_id: Optional[int] = None) -> AddTimeEntryResult:
    """Core logic to add a time entry to a ticket."""
    if not manage_api_client:
        return AddTimeEntryResult(success=False, message="ConnectWise client not configured.")
    member_info: Optional[CwMemberInfo] = context.cw_member_info if context else None
    member_id = member_info.id if member_info else None
    if not member_id:
        logger.error("Member info missing in context; cannot add time entry.")
        return AddTimeEntryResult(success=False, error_type="AuthError", message="No member info in context to attribute time entry.")
    logger.info(f"Logic: Adding time entry by member {member_id} on ticket {ticket_id} ({actual_hours}h, {billable_option})")
    try:
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID.")
        if not notes:
            raise ValueError("Time entry notes cannot be empty.")
        if billable_option not in {"Billable", "DoNotBill", "NoCharge"}:
            raise ValueError("billable_option must be 'Billable', 'DoNotBill', or 'NoCharge'.")

        # Get current time in UTC for timeStart and timeEnd if not provided
        current_time = datetime.now(timezone.utc)

        # Calculate timeEnd based on actual_hours (add hours to timeStart)
        time_start_dt = None
        if time_start:
            try:
                if time_start.lower() == "now":
                    time_start_dt = current_time
                else:
                    time_start_dt = datetime.fromisoformat(time_start.replace("Z", "+00:00"))
            except Exception as e:
                logger.warning(f"Could not parse time_start '{time_start}', using current time. Error: {e}")
                time_start_dt = current_time
        else:
            time_start_dt = current_time

        # Use provided time_end or calculate it based on actual_hours
        time_end_dt = None
        if time_end:
            try:
                time_end_dt = datetime.fromisoformat(time_end.replace("Z", "+00:00"))
            except Exception as e:
                logger.warning(f"Could not parse time_end '{time_end}', calculating from time_start and actual_hours. Error: {e}")
                time_end_dt = None

        if not time_end_dt:
            # Calculate timeEnd by adding actual_hours to timeStart
            hours_delta = timedelta(hours=float(actual_hours))
            time_end_dt = time_start_dt + hours_delta

        # Format times as ISO 8601 strings
        time_start_str = time_start_dt.strftime("%Y-%m-%dT%H:%M:%SZ")
        time_end_str = time_end_dt.strftime("%Y-%m-%dT%H:%M:%SZ")

        # Create time entry payload according to PyConnectWise API requirements
        entry_data = {
            "ticketId": ticket_id,
            "notes": notes,
            "timeStart": time_start_str,
            "timeEnd": time_end_str,
            "billableOption": billable_option,
            "member": {"identifier": member_info.identifier if member_info and member_info.identifier else None}
        }

        # Add optional fields if provided
        if work_type_id is not None and work_type_id > 0:
            entry_data["workType"] = {"id": work_type_id}

        if work_role_id is not None and work_role_id > 0:
            entry_data["workRole"] = {"id": work_role_id}

        if location_id is not None and location_id > 0:
            entry_data["locationId"] = location_id

        # Add email notification flags if provided
        if email_contact is not None:
            entry_data["emailContactFlag"] = email_contact

        if email_resource is not None:
            entry_data["emailResourceFlag"] = email_resource

        if email_cc is not None:
            entry_data["emailCcFlag"] = email_cc

        # Log the payload for debugging
        logger.info(f"Time entry payload: {entry_data}")

        created_entry = manage_api_client.time.entries.post(entry_data) # type: ignore[arg-type]
        entry_id = getattr(created_entry, "id", None)

        # If a new status is provided, update the ticket status after adding the time entry
        if entry_id and new_status_id is not None and new_status_id > 0:
            logger.info(f"Updating ticket {ticket_id} status to {new_status_id} after adding time entry")
            status_result = change_ticket_status_impl(ticket_id=ticket_id, status_id=new_status_id)
            if not status_result.success:
                logger.warning(f"Failed to update ticket status after adding time entry: {status_result.message}")
                # Continue anyway since the time entry was successful

        if entry_id:
            logger.info(f"Logic: Time entry {entry_id} added to ticket {ticket_id}.")
            return AddTimeEntryResult(success=True, message=f"Time entry added to ticket {ticket_id}.", entry_id=entry_id)
        else:
            logger.error("Logic: Time entry creation returned no ID.")
            return AddTimeEntryResult(success=False, error_type="APIError", message="Failed to confirm time entry creation.")
    except Exception as e:
        return _handle_cw_error(e, "add_time_entry_impl", AddTimeEntryResult, ticket_id=ticket_id, hours=actual_hours, billable=billable_option)

# --- Agent Tool Definition ---
@function_tool()
# Remove 'context: ToolContext' from signature as it's retrieved via contextvar now
def add_time_entry(ticket_id: int, notes: str, actual_hours: float, billable_option: str,
                 time_start: Optional[str] = None, time_end: Optional[str] = None,
                 work_type_id: Optional[int] = None, work_role_id: Optional[int] = None,
                 location_id: Optional[int] = None, email_contact: Optional[bool] = None,
                 email_resource: Optional[bool] = None, email_cc: Optional[bool] = None,
                 new_status_id: Optional[int] = None) -> AddTimeEntryResult:
    """Add a time entry to a ticket. Uses the member info from the current request context.

    Required parameters:
    - ticket_id: The ID of the ticket to add time to (must be a positive integer)
    - notes: Description of the work performed (cannot be empty)
    - actual_hours: Number of hours worked (e.g., 0.5 for 30 minutes)
    - billable_option: Must be one of: 'Billable', 'DoNotBill', or 'NoCharge'

    Optional parameters:
    - time_start: Start time in ISO format (e.g., '2025-04-01T14:30:00Z') or 'now'. Defaults to current time if omitted.
    - time_end: End time in ISO format. If not provided, calculated from time_start + actual_hours.
    - work_type_id: ID of the work type to associate with this time entry.
    - work_role_id: ID of the work role to associate with this time entry.
    - location_id: ID of the location where the work was performed.
    - email_contact: Whether to email the contact about this time entry.
    - email_resource: Whether to email the resource about this time entry.
    - email_cc: Whether to email CCs about this time entry.
    - new_status_id: ID of the status to set the ticket to after adding the time entry.
    """
    logger.info("Tool 'add_time_entry' called.")
    # Retrieve context from the context variable
    context = current_tool_context.get()
    if not context:
        logger.error("Tool 'add_time_entry': Failed to retrieve ToolContext from context variable.")
        return AddTimeEntryResult(success=False, error_type="InternalError", message="Internal context error.")
    logger.debug(f"Tool 'add_time_entry': Retrieved context with member_info: {context.cw_member_info}")
    return add_time_entry_impl(context, ticket_id, notes, actual_hours, billable_option,
                             time_start, time_end, work_type_id, work_role_id,
                             location_id, email_contact, email_resource, email_cc, new_status_id)

# --- Undecorated Helper for Core Logic ---
def search_tickets_tool_impl(
    board_id: Optional[int] = None,
    company_name: Optional[str] = None,
    contact_name: Optional[str] = None,
    status_name: Optional[str] = None, # Handles 'open'/'closed' or specific names
    days_range: Optional[int] = None,
    search_term: Optional[str] = None, # Searches summary
    limit: Optional[int] = None,  # Removed default value
) -> QueryTicketsResult: # Use the correct Pydantic result type from models.py
    """
    Core logic to search for tickets based on multiple criteria.
    """
    if not manage_api_client:
        return QueryTicketsResult(success=False, tickets=[], total_found=0, message="ConnectWise client not available.") # Updated model

    logger.info(f"Logic: Searching tickets with: board={board_id}, company={company_name}, contact={contact_name}, status={status_name}, days={days_range}, term={search_term}, limit={limit}") # Changed log prefix

    try:
        conditions = []

        if board_id:
            if not isinstance(board_id, int) or board_id <= 0:
                raise ValueError("board_id must be a positive integer.")
            conditions.append(f"board/id = {board_id}")

        if company_name:
            # Find company ID directly using the client
            comp_search_params = {"conditions": f"name contains '{company_name}'", "pageSize": 1} # Prioritize exact match if possible, but contains is simpler here
            companies_raw = manage_api_client.company.companies.get(params=comp_search_params) # type: ignore[arg-type]
            company = companies_raw[0] if companies_raw and isinstance(companies_raw, list) else None
            if company:
                company_id = safe_get(company, "id")
                if company_id:
                    conditions.append(f"company/id = {company_id}")
                    logger.info(f"Found company '{safe_get(company, 'name')}' with ID {company_id} for filter '{company_name}'.")
                else:
                    logger.warning(f"Found company matching '{company_name}' but it has no ID. Using name filter.")
                    conditions.append(f"company/name contains '{company_name}'") # Fallback to name contains
            else:
                logger.warning(f"Could not find company matching '{company_name}'. Adding 'contains' condition as fallback.")
                conditions.append(f"company/name contains '{company_name}'") # Fallback if no company found


        if contact_name:
            # Contact search is less reliable without company context, use contains
            conditions.append(f"contact/name contains '{contact_name}'")

        if status_name:
            status_lower = status_name.lower()
            if status_lower == 'open':
                 conditions.append("closedFlag = false")
            elif status_lower == 'closed':
                 conditions.append("closedFlag = true")
            else:
                 conditions.append(f"status/name contains '{status_name}'") # Partial match for specific status names
        else:
            conditions.append("closedFlag = false") # Default to open tickets

        if days_range:
            if not isinstance(days_range, int) or days_range <= 0:
                raise ValueError("days_range must be a positive integer.")
            start_date = datetime.now(timezone.utc) - timedelta(days=days_range)
            start_date_str = start_date.strftime('%Y-%m-%dT00:00:00Z')
            conditions.append(f"dateEntered > [{start_date_str}]")
            logger.info(f"Searching tickets created after {start_date_str}")

        if search_term:
            conditions.append(f"summary contains '{search_term}'")

        # Add condition to filter out child tickets
        conditions.append("parentTicketId = null")

        combined_conditions = " AND ".join(conditions) if conditions else "closedFlag = false AND parentTicketId = null" # Ensure we always have a condition (default open)

        # Set default limit to 50 if not provided or invalid
        if limit is None:
            limit = 50  # Set default dynamically if not provided
        page_size = 50
        if limit is not None:
            if 0 < limit <= 1000:
                page_size = limit
        api_params = {
            "conditions": combined_conditions,
            "orderBy": "id desc", # Or dateEntered desc? Old used id desc.
            "fields": "id,summary,status/name,company/name,contact/name,dateEntered,board/name,board/id,owner/identifier", # Added fields needed for TicketSummary
            "pageSize": page_size
        }

        logger.info(f"Searching tickets with conditions: {combined_conditions}")
        tickets_raw = manage_api_client.service.tickets.get(params=api_params) # type: ignore[arg-type]

        ticket_list = []
        if tickets_raw and isinstance(tickets_raw, list):
            for ticket in tickets_raw:
                 # Map raw data to the TicketSummary Pydantic model
                 summary = TicketSummary(
                     ticket_id=safe_get(ticket, "id"),
                     summary=safe_get(ticket, "summary"),
                     status=safe_get(ticket, "status.name"),
                     board_id=safe_get(ticket, "board.id"),
                     board_name=safe_get(ticket, "board.name"),
                     company_name=safe_get(ticket, "company.name"),
                     contact_name=safe_get(ticket, "contact.name"),
                     owner_identifier=safe_get(ticket, "owner.identifier"),
                     date_entered=format_datetime(safe_get(ticket, "dateEntered")),
                     # Add other fields if needed and available
                 )
                 ticket_list.append(summary)
            logger.info(f"Found {len(ticket_list)} tickets matching criteria.")
            # TODO: Implement proper pagination logic here if needed for the tool itself
            # For now, returning a single page result matching PaginatedTicketsResult structure
            return QueryTicketsResult(success=True, tickets=ticket_list, total_found=len(ticket_list), message=f"Found {len(ticket_list)} tickets.") # Updated model
        else:
             logger.info("No tickets found matching criteria.")
             return QueryTicketsResult(success=True, tickets=[], total_found=0, message="No tickets found.") # Updated model

    except Exception as e:
        # Use the new result model type for error handling
        # Use the implementation function name in the error log
        return _handle_cw_error(e, "search_tickets_tool_impl", QueryTicketsResult, board_id=board_id, company_name=company_name, contact_name=contact_name, status_name=status_name, days_range=days_range, search_term=search_term, limit=limit) # Updated model

# Renamed from query_tickets, incorporating logic from old search_tickets
@function_tool() # Removed 'name' argument; tool name will be 'search_tickets_tool'
def search_tickets_tool(
    board_id: Optional[int] = None,
    company_name: Optional[str] = None,
    contact_name: Optional[str] = None,
    status_name: Optional[str] = None, # Handles 'open'/'closed' or specific names
    days_range: Optional[int] = None,
    search_term: Optional[str] = None, # Searches summary
    limit: Optional[int] = None  # No default value in the function signature
) -> QueryTicketsResult:
    """
    Searches for tickets based on multiple criteria. All parameters are optional filters.

    Optional parameters (at least one should be provided):
    - board_id: Filter by specific service board ID
    - company_name: Filter by company name (tries exact then partial match)
    - contact_name: Filter by contact name (uses partial match)
    - status_name: Filter by status name (can use 'open' or 'closed' as special values)
    - days_range: Filter to tickets updated within this many days
    - search_term: Search in ticket summary and description
    - limit: Maximum number of tickets to return (max 1000, defaults to 50 if not specified)
    """
    logger.info("Tool 'search_tickets_tool' called, delegating to implementation.")
    return search_tickets_tool_impl(
        board_id=board_id,
        company_name=company_name,
        contact_name=contact_name,
        status_name=status_name,
        days_range=days_range,
        search_term=search_term,
        limit=limit,
    )

# Removed create_company and create_contact functions as requested



# --- Undecorated Helper for Core Logic ---
def update_ticket_contact_impl(ticket_id: int, new_contact_id: int) -> UpdateTicketContactResult:
    """Core logic to update the primary contact associated with a specific ticket."""
    if not manage_api_client:
        return UpdateTicketContactResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Updating contact for ticket_id={ticket_id} to contact_id={new_contact_id}")
    try:
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID.")
        if new_contact_id <= 0:
            raise ValueError("Invalid Contact ID.")
        patch_operations = [{"op": "replace", "path": "/contact/id", "value": new_contact_id}]
        manage_api_client.service.tickets.id(ticket_id).patch(patch_operations) # type: ignore[arg-type]
        logger.info(f"Logic: Ticket {ticket_id} contact updated to ID {new_contact_id}.")
        return UpdateTicketContactResult(success=True, message=f"Ticket {ticket_id} contact updated successfully.")
    except ConnectWiseException as cw_e:
         if getattr(cw_e, "status_code", None) == 400 and "Invalid value" in getattr(cw_e, "message", ""):
              logger.error(f"Logic: Failed to update contact for ticket {ticket_id}: Contact ID {new_contact_id} likely invalid or not associated with the ticket's company.")
              return UpdateTicketContactResult(success=False, error_type="ValueError", message=f"Failed to update contact: Contact ID {new_contact_id} might be invalid or not belong to the ticket's company.")
         return _handle_cw_error(cw_e, "update_ticket_contact_impl", UpdateTicketContactResult, ticket_id=ticket_id, contact_id=new_contact_id)
    except Exception as e:
        return _handle_cw_error(e, "update_ticket_contact_impl", UpdateTicketContactResult, ticket_id=ticket_id, contact_id=new_contact_id)

# --- Agent Tool Definition ---
@function_tool()
def update_ticket_contact(ticket_id: int, new_contact_id: int) -> UpdateTicketContactResult:
    """Updates the primary contact associated with a specific ticket."""
    logger.info("Tool 'update_ticket_contact' called, delegating to implementation function.")
    return update_ticket_contact_impl(ticket_id=ticket_id, new_contact_id=new_contact_id)

# --- Undecorated Helper for Core Logic ---
# Removed find_company_impl, find_company, find_contact_impl, find_contact definitions from here.
# They will be inserted before update_ticket_owner_impl.

# [Removed duplicate find_company_impl and find_company definitions]
# --- Undecorated Helper for Core Logic ---
# [Removed duplicate find_contact_impl and find_contact definitions]

# --- Undecorated Helper for Core Logic ---
# [Removed duplicate find_company_impl and find_company definitions]

# --- Undecorated Helper for Core Logic ---
# [Removed duplicate find_contact_impl and find_contact definitions]

# --- Undecorated Helper for Core Logic ---
def update_ticket_owner_impl(ticket_id: int, member_identifier: str) -> UpdateTicketOwnerResult:
    """Core logic to assign or reassign the owner (member) of a specific ticket."""
    if not manage_api_client:
        return UpdateTicketOwnerResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Updating owner for ticket_id={ticket_id} to member='{member_identifier}'")
    try:
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID.")
        if not member_identifier:
            raise ValueError("Member identifier is required.")
        # Find the member ID using the existing helper function
        member_details = _find_member_details_sync(member_identifier)
        if not member_details or not member_details.get("id"):
            logger.error(f"Logic: Failed to find member '{member_identifier}' to assign to ticket {ticket_id}.")
            return UpdateTicketOwnerResult(success=False, error_type="ValueError", message=f"Member '{member_identifier}' not found.")
        member_id = member_details["id"]
        patch_operations = [{"op": "replace", "path": "/owner/id", "value": member_id}]
        manage_api_client.service.tickets.id(ticket_id).patch(patch_operations) # type: ignore[arg-type]
        logger.info(f"Logic: Ticket {ticket_id} owner updated to member ID {member_id} ('{member_identifier}').")
        return UpdateTicketOwnerResult(success=True, message=f"Ticket {ticket_id} owner assigned to '{member_identifier}'.")
    except Exception as e:
        return _handle_cw_error(e, "update_ticket_owner_impl", UpdateTicketOwnerResult, ticket_id=ticket_id, member_identifier=member_identifier)

# --- Agent Tool Definition ---
@function_tool()
def update_ticket_owner(ticket_id: int, member_identifier: str) -> UpdateTicketOwnerResult:
    """Assigns or reassigns the owner (member) of a specific ticket."""
    logger.info("Tool 'update_ticket_owner' called, delegating to implementation function.")
    return update_ticket_owner_impl(ticket_id=ticket_id, member_identifier=member_identifier)

# --- Undecorated Helper for Core Logic ---
def update_ticket_summary_impl(ticket_id: int, new_summary: str) -> UpdateTicketResult:
    """Core logic to update the summary field of a specific ticket."""
    if not manage_api_client:
        return UpdateTicketResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Updating summary for ticket_id={ticket_id}")
    try:
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID.")
        if not new_summary:
            raise ValueError("New summary cannot be empty.")
        patch_operations = [{"op": "replace", "path": "/summary", "value": new_summary}]
        manage_api_client.service.tickets.id(ticket_id).patch(patch_operations) # type: ignore[arg-type]
        logger.info(f"Logic: Ticket {ticket_id} summary updated.")
        return UpdateTicketResult(success=True, message=f"Ticket {ticket_id} summary updated successfully.")
    except Exception as e:
        return _handle_cw_error(e, "update_ticket_summary_impl", UpdateTicketResult, ticket_id=ticket_id)

# --- Agent Tool Definition ---
@function_tool()
def update_ticket_summary(ticket_id: int, new_summary: str) -> UpdateTicketResult:
    """Updates the summary field of a specific ticket."""
    logger.info("Tool 'update_ticket_summary' called, delegating to implementation function.")
    return update_ticket_summary_impl(ticket_id=ticket_id, new_summary=new_summary)

# --- Undecorated Helper for Core Logic ---
def update_ticket_priority_impl(ticket_id: int, priority_id: int) -> UpdateTicketResult:
    """Core logic to update the priority of a specific ticket using the priority ID."""
    if not manage_api_client:
        return UpdateTicketResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Updating priority for ticket_id={ticket_id} to priority_id={priority_id}")
    try:
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID.")
        if priority_id <= 0:
            raise ValueError("Invalid Priority ID.") # Basic check
        # We could add a check here to see if the priority ID exists, but CW might handle it
        patch_operations = [{"op": "replace", "path": "/priority/id", "value": priority_id}]
        manage_api_client.service.tickets.id(ticket_id).patch(patch_operations) # type: ignore[arg-type]
        logger.info(f"Logic: Ticket {ticket_id} priority updated to ID {priority_id}.")
        return UpdateTicketResult(success=True, message=f"Ticket {ticket_id} priority updated successfully.")
    except Exception as e:
        return _handle_cw_error(e, "update_ticket_priority_impl", UpdateTicketResult, ticket_id=ticket_id, priority_id=priority_id)

# --- Agent Tool Definition ---
@function_tool()
def update_ticket_priority(ticket_id: int, priority_id: int) -> UpdateTicketResult:
    """Updates the priority of a specific ticket using the priority ID."""
    logger.info("Tool 'update_ticket_priority' called, delegating to implementation function.")
    return update_ticket_priority_impl(ticket_id=ticket_id, priority_id=priority_id)



# --- Undecorated Helper for Core Logic ---
def update_ticket_type_impl(ticket_id: int, type_id: int) -> UpdateTicketResult:
    """Core logic to update the type of a specific ticket using the type ID."""
    if not manage_api_client:
        return UpdateTicketResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Updating type for ticket_id={ticket_id} to type_id={type_id}")
    try:
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID.")
        if type_id <= 0:
            raise ValueError("Invalid Type ID.") # Basic check
        # We could add a check here to see if the type ID exists, but CW might handle it
        patch_operations = [{"op": "replace", "path": "/type/id", "value": type_id}]
        manage_api_client.service.tickets.id(ticket_id).patch(patch_operations) # type: ignore[arg-type]
        logger.info(f"Logic: Ticket {ticket_id} type updated to ID {type_id}.")
        return UpdateTicketResult(success=True, message=f"Ticket {ticket_id} type updated successfully.")
    except Exception as e:
        return _handle_cw_error(e, "update_ticket_type_impl", UpdateTicketResult, ticket_id=ticket_id, type_id=type_id)

# --- Agent Tool Definition ---
@function_tool()
def update_ticket_type(ticket_id: int, type_id: int) -> UpdateTicketResult:
    """Updates the type of a specific ticket using the type ID."""
    logger.info("Tool 'update_ticket_type' called, delegating to implementation function.")
    return update_ticket_type_impl(ticket_id=ticket_id, type_id=type_id)

# --- Undecorated Helper for Core Logic ---
def update_ticket_subtype_impl(ticket_id: int, subtype_id: int) -> UpdateTicketResult:
    """Core logic to update the subtype of a specific ticket using the subtype ID."""
    if not manage_api_client:
        return UpdateTicketResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Updating subtype for ticket_id={ticket_id} to subtype_id={subtype_id}")
    try:
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID.")
        if subtype_id <= 0:
            raise ValueError("Invalid Subtype ID.") # Basic check
        # We could add a check here to see if the subtype ID exists, but CW might handle it
        patch_operations = [{"op": "replace", "path": "/subType/id", "value": subtype_id}]
        manage_api_client.service.tickets.id(ticket_id).patch(patch_operations) # type: ignore[arg-type]
        logger.info(f"Logic: Ticket {ticket_id} subtype updated to ID {subtype_id}.")
        return UpdateTicketResult(success=True, message=f"Ticket {ticket_id} subtype updated successfully.")
    except Exception as e:
        return _handle_cw_error(e, "update_ticket_subtype_impl", UpdateTicketResult, ticket_id=ticket_id, subtype_id=subtype_id)

# --- Agent Tool Definition ---
@function_tool()
def update_ticket_subtype(ticket_id: int, subtype_id: int) -> UpdateTicketResult:
    """Updates the subtype of a specific ticket using the subtype ID."""
    logger.info("Tool 'update_ticket_subtype' called, delegating to implementation function.")
    return update_ticket_subtype_impl(ticket_id=ticket_id, subtype_id=subtype_id)

# --- Undecorated Helper for Core Logic ---
def update_ticket_item_impl(ticket_id: int, item_id: int) -> UpdateTicketResult:
    """Core logic to update the item of a specific ticket using the item ID."""
    if not manage_api_client:
        return UpdateTicketResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Updating item for ticket_id={ticket_id} to item_id={item_id}")
    try:
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID.")
        if item_id <= 0:
            raise ValueError("Invalid Item ID.") # Basic check
        # We could add a check here to see if the item ID exists, but CW might handle it
        patch_operations = [{"op": "replace", "path": "/item/id", "value": item_id}]
        manage_api_client.service.tickets.id(ticket_id).patch(patch_operations) # type: ignore[arg-type]
        logger.info(f"Logic: Ticket {ticket_id} item updated to ID {item_id}.")
        return UpdateTicketResult(success=True, message=f"Ticket {ticket_id} item updated successfully.")
    except Exception as e:
        return _handle_cw_error(e, "update_ticket_item_impl", UpdateTicketResult, ticket_id=ticket_id, item_id=item_id)

# --- Agent Tool Definition ---
@function_tool()
def update_ticket_item(ticket_id: int, item_id: int) -> UpdateTicketResult:
    """Updates the item of a specific ticket using the item ID."""
    logger.info("Tool 'update_ticket_item' called, delegating to implementation function.")
    return update_ticket_item_impl(ticket_id=ticket_id, item_id=item_id)


# --- Undecorated Helper for Core Logic ---
def update_ticket_company_impl(ticket_id: int, new_company_name: str) -> UpdateTicketResult:
    """Core logic to update the company associated with a specific ticket."""
    if not manage_api_client:
        return UpdateTicketResult(success=False, message="ConnectWise client not configured.")
    logger.info(f"Logic: Updating company for ticket_id={ticket_id} to company='{new_company_name}'")
    try:
        if ticket_id <= 0:
            raise ValueError("Invalid Ticket ID.")
        if not new_company_name:
            raise ValueError("New company name cannot be empty.")
        # Find the company ID using the implementation function
        company_lookup = find_company_impl(new_company_name) # Call _impl version
        if not company_lookup.success or not company_lookup.found or not company_lookup.company:
            logger.error(f"Logic: Failed to find company '{new_company_name}' to assign to ticket {ticket_id}. Message: {company_lookup.message}")
            return UpdateTicketResult(success=False, error_type="ValueError", message=f"Company '{new_company_name}' not found.")
        new_company_id = company_lookup.company.id
        patch_operations = [{"op": "replace", "path": "/company/id", "value": new_company_id}]
        manage_api_client.service.tickets.id(ticket_id).patch(patch_operations) # type: ignore[arg-type]
        logger.info(f"Logic: Ticket {ticket_id} company updated to ID {new_company_id} ('{new_company_name}').")
        return UpdateTicketResult(success=True, message=f"Ticket {ticket_id} company updated successfully to '{new_company_name}'.")
    except Exception as e:
        return _handle_cw_error(e, "update_ticket_company_impl", UpdateTicketResult, ticket_id=ticket_id, company_name=new_company_name)

# --- Agent Tool Definition ---
@function_tool()
def update_ticket_company(ticket_id: int, new_company_name: str) -> UpdateTicketResult:
    """Updates the company associated with a specific ticket."""
    logger.info("Tool 'update_ticket_company' called, delegating to implementation function.")
    return update_ticket_company_impl(ticket_id=ticket_id, new_company_name=new_company_name)


# --- Resource Management Tools ---

# --- Implementation Function ---
def assign_resource_to_ticket_impl(ticket_id: int, member_id: int) -> AssignResourceResult:
    """Assign a resource (member) to a ticket."""
    if not manage_api_client:
        return AssignResourceResult(success=False, message="ConnectWise client not available.")

    try:
        # Cast manage_api_client to avoid None type errors
        api_client = cast(ConnectWiseClient, manage_api_client)
        
        # Get current resources
        resources_response = api_client.service.tickets.id(ticket_id).get_child("resources")

        # Check if member is already assigned
        for resource in resources_response:
            if getattr(getattr(resource, 'member', None), 'id', None) == member_id:
                return AssignResourceResult(
                    success=True,
                    message=f"Member {member_id} is already assigned to ticket {ticket_id}.",
                    ticket_id=ticket_id,
                    resource_id=member_id
                )

        # Add the new resource
        new_resource = {
            "member": {
                "id": member_id
            }
        }

        # Create the resource
        response = api_client.service.tickets.id(ticket_id).post_child("resources", new_resource)

        return AssignResourceResult(
            success=True,
            message=f"Successfully assigned member {member_id} to ticket {ticket_id}.",
            ticket_id=ticket_id,
            resource_id=member_id
        )
    except Exception as e:
        return _handle_cw_error(e, "assign_resource_to_ticket_impl", AssignResourceResult, ticket_id=ticket_id, member_id=member_id)

# --- Agent Tool Definition ---
@function_tool()
def assign_resource_to_ticket(ticket_id: int, member_id: int) -> AssignResourceResult:
    """Assign a resource (member) to a ticket.

    Required parameters:
    - ticket_id: The ID of the ticket to assign the resource to
    - member_id: The ID of the member to assign to the ticket
    """
    logger.info(f"Tool 'assign_resource_to_ticket' called with ticket_id={ticket_id}, member_id={member_id}")
    return assign_resource_to_ticket_impl(ticket_id=ticket_id, member_id=member_id)

# --- Implementation Function ---
def remove_resource_from_ticket_impl(ticket_id: int, member_id: int) -> RemoveResourceResult:
    """Remove a resource (member) from a ticket."""
    if not manage_api_client:
        return RemoveResourceResult(success=False, message="ConnectWise client not available.")

    try:
        # Cast manage_api_client to avoid None type errors
        api_client = cast(ConnectWiseClient, manage_api_client)
        
        # Get current resources
        resources_response = api_client.service.tickets.id(ticket_id).get_child("resources")

        # Find the resource to remove
        resource_id = None
        for resource in resources_response:
            if getattr(getattr(resource, 'member', None), 'id', None) == member_id:
                resource_id = getattr(resource, 'id', None)
                break

        if not resource_id:
            return RemoveResourceResult(
                success=False,
                message=f"Member {member_id} is not assigned to ticket {ticket_id}.",
                ticket_id=ticket_id,
                resource_id=None
            )

        # Delete the resource
        api_client.service.tickets.id(ticket_id).id(resource_id).delete_child("resources")

        return RemoveResourceResult(
            success=True,
            message=f"Successfully removed member {member_id} from ticket {ticket_id}.",
            ticket_id=ticket_id,
            resource_id=member_id
        )
    except Exception as e:
        return _handle_cw_error(e, "remove_resource_from_ticket_impl", RemoveResourceResult, ticket_id=ticket_id, member_id=member_id)

# --- Agent Tool Definition ---
@function_tool()
def remove_resource_from_ticket(ticket_id: int, member_id: int) -> RemoveResourceResult:
    """Remove a resource (member) from a ticket.

    Required parameters:
    - ticket_id: The ID of the ticket to remove the resource from
    - member_id: The ID of the member to remove from the ticket
    """
    logger.info(f"Tool 'remove_resource_from_ticket' called with ticket_id={ticket_id}, member_id={member_id}")
    return remove_resource_from_ticket_impl(ticket_id=ticket_id, member_id=member_id)

# --- Contact Creation Tool ---

# --- Implementation Function ---
def create_contact_impl(company_id: int, first_name: str, last_name: str, email: Optional[str] = None, phone: Optional[str] = None) -> CreateContactResult:
    """Create a new contact for a company."""
    if not manage_api_client:
        return CreateContactResult(success=False, message="ConnectWise client not available.")

    try:
        # Validate required inputs
        if not company_id or company_id <= 0:
            return CreateContactResult(success=False, message="Valid company ID is required.")
        if not first_name or not first_name.strip():
            return CreateContactResult(success=False, message="First name is required.")
        if not last_name or not last_name.strip():
            return CreateContactResult(success=False, message="Last name is required.")

        # Construct the contact payload
        contact_payload = {
            "firstName": first_name,
            "lastName": last_name,
            "company": {
                "id": company_id
            }
        }

        # Add optional fields if provided
        if email:
            # Use the correct field name for email
            contact_payload["emailAddress"] = email

        if phone:
            # Use the correct field name for phone
            contact_payload["phoneNumber"] = phone

        # Log the payload for debugging
        logger.info(f"Creating contact with payload: {contact_payload}")

        # Create the contact
        response = manage_api_client.company.contacts.post(contact_payload) # type: ignore

        contact_id = getattr(response, 'id', None)
        return CreateContactResult(success=True, contact_id=contact_id, message=f"Successfully created contact {first_name} {last_name} for company {company_id}.")
    except Exception as e:
        logger.error(f"Error creating contact: {str(e)}")
        return _handle_cw_error(e, "create_contact_impl", CreateContactResult, company_id=company_id, first_name=first_name, last_name=last_name)

# --- Agent Tool Definition ---
@function_tool()
def create_contact(company_id: int, first_name: str, last_name: str, email: Optional[str] = None, phone: Optional[str] = None) -> CreateContactResult:
    """Create a new contact for a company.

    Required parameters:
    - company_id: The ID of the company to create the contact for
    - first_name: The first name of the contact
    - last_name: The last name of the contact

    Optional parameters:
    - email: The email address of the contact
    - phone: The phone number of the contact
    """
    logger.info(f"Tool 'create_contact' called with company_id={company_id}, first_name={first_name}, last_name={last_name}")
    return create_contact_impl(company_id=company_id, first_name=first_name, last_name=last_name, email=email, phone=phone)

# --- Ticket Moving Tool ---

# --- Implementation Function ---
def move_ticket_to_board_impl(ticket_id: int, new_board_id: int) -> UpdateTicketResult:
    """Move a ticket to a different service board."""
    if not manage_api_client:
        return UpdateTicketResult(success=False, message="ConnectWise client not available.")

    try:
        # Construct the patch operation
        patch_payload = [
            {
                "op": "replace",
                "path": "/board/id",
                "value": new_board_id
            }
        ]

        # Update the ticket
        manage_api_client.service.tickets.id(ticket_id).patch(patch_payload) # type: ignore

        return UpdateTicketResult(success=True, message=f"Successfully moved ticket {ticket_id} to board {new_board_id}.")
    except Exception as e:
        return _handle_cw_error(e, "move_ticket_to_board_impl", UpdateTicketResult, ticket_id=ticket_id, new_board_id=new_board_id)

# --- Agent Tool Definition ---
@function_tool()
def move_ticket_to_board(ticket_id: int, new_board_id: int) -> UpdateTicketResult:
    """Move a ticket to a different service board.

    Required parameters:
    - ticket_id: The ID of the ticket to move
    - new_board_id: The ID of the service board to move the ticket to
    """
    logger.info(f"Tool 'move_ticket_to_board' called with ticket_id={ticket_id}, new_board_id={new_board_id}")
    return move_ticket_to_board_impl(ticket_id=ticket_id, new_board_id=new_board_id)

# --- Attachment Retrieval Tool ---

# --- Implementation Function ---
def get_ticket_attachments_impl(ticket_id: int) -> GetTicketAttachmentsResult:
    """Get attachments for a ticket."""
    if not manage_api_client:
        return GetTicketAttachmentsResult(success=False, message="ConnectWise client not available.")

    try:
        # Get attachments
        params = {
            "conditions": f"recordType='Ticket' AND recordId={ticket_id}"
        }
        response = manage_api_client.system.documents.get(params=params) # type: ignore

        # Map response to AttachmentInfo objects
        attachments = []
        for attachment in response:
            attachments.append(AttachmentInfo(
                id=getattr(attachment, 'id', None),
                file_name=getattr(attachment, 'fileName', None),
                title=getattr(attachment, 'title', None),
                size=getattr(attachment, 'size', None),
                upload_date=format_datetime(getattr(attachment, 'uploadDate', None)),
                uploaded_by=getattr(getattr(attachment, 'owner', None), 'name', None),
                content_type=getattr(attachment, 'contentType', None),
                url=f"/system/documents/{getattr(attachment, 'id', None)}/download"
            ))

        return GetTicketAttachmentsResult(
            success=True,
            ticket_id=ticket_id,
            attachments=attachments,
            message=f"Found {len(attachments)} attachments for ticket {ticket_id}."
        )
    except Exception as e:
        return _handle_cw_error(e, "get_ticket_attachments_impl", GetTicketAttachmentsResult, ticket_id=ticket_id)

# --- Agent Tool Definition ---
@function_tool()
def get_ticket_attachments(ticket_id: int) -> GetTicketAttachmentsResult:
    """Get attachments for a ticket.

    Required parameters:
    - ticket_id: The ID of the ticket to get attachments for
    """
    logger.info(f"Tool 'get_ticket_attachments' called with ticket_id={ticket_id}")
    return get_ticket_attachments_impl(ticket_id=ticket_id)

# --- Work Types, Work Roles, and Locations Tools ---

# --- Implementation Function ---
def list_work_types_impl() -> ListWorkTypesResult:
    """Get all work types from ConnectWise."""
    if not manage_api_client:
        return ListWorkTypesResult(success=False, message="ConnectWise client not available.")

    # Check cache first
    cached_result = cache_get('work_types')
    if cached_result is not None:
        logger.info("Using cached work types")
        return cached_result

    try:
        # In development mode, return sample data
        if config.DEVELOPMENT_MODE:
            logger.warning("Using sample work types for development mode")
            work_types = [
                WorkTypeDetail(id=1, name="Remote Support", inactive_flag=False),
                WorkTypeDetail(id=2, name="On-Site Support", inactive_flag=False),
                WorkTypeDetail(id=3, name="Project Work", inactive_flag=False)
            ]
            result = ListWorkTypesResult(
                success=True,
                work_types=work_types,
                message=f"Found {len(work_types)} work types (mock data)."
            )
            cache_set('work_types', result)
            return result
        
        # API endpoint access might differ between versions
        try:
            # First try the direct endpoint approach (newer versions)
            api_client = cast(ConnectWiseClient, manage_api_client)
            # Use the lower level _make_request method on time endpoint
            response = api_client.time._make_request("GET", path="worktypes")
            if response.status_code == 200:
                work_types_data = response.json()
            else:
                raise ConnectWiseException(f"Failed to get work types: {response.status_code}")
        except (AttributeError, ConnectWiseException) as e:
            logger.warning(f"Could not get work types via direct API path: {e}")
            # Fallback to mock data
            work_types_data = [
                {"id": 1, "name": "Remote Support", "inactiveFlag": False},
                {"id": 2, "name": "On-Site Support", "inactiveFlag": False},
                {"id": 3, "name": "Project Work", "inactiveFlag": False}
            ]

        # Map response to WorkTypeDetail objects
        work_types = []
        for work_type in work_types_data:
            # Handle both object and dictionary response formats
            if isinstance(work_type, dict):
                work_type_id = work_type.get('id')
                work_type_name = work_type.get('name')
                inactive_flag = work_type.get('inactiveFlag', False)
            else:
                work_type_id = getattr(work_type, 'id', None)
                work_type_name = getattr(work_type, 'name', None)
                inactive_flag = getattr(work_type, 'inactiveFlag', False)
                
            work_types.append(WorkTypeDetail(
                id=work_type_id,
                name=work_type_name,
                inactive_flag=inactive_flag
            ))

        result = ListWorkTypesResult(
            success=True,
            work_types=work_types,
            message=f"Found {len(work_types)} work types."
        )

        # Cache the result
        cache_set('work_types', result)

        return result
    except Exception as e:
        return _handle_cw_error(e, "list_work_types_impl", ListWorkTypesResult)

# --- Agent Tool Definition ---
@function_tool()
def list_work_types() -> ListWorkTypesResult:
    """Get all work types from ConnectWise.

    Work types are used for time entries to categorize the type of work performed.
    """
    logger.info("Tool 'list_work_types' called")
    return list_work_types_impl()

# --- Implementation Function ---
def list_work_roles_impl() -> ListWorkRolesResult:
    """Get all work roles from ConnectWise."""
    if not manage_api_client:
        return ListWorkRolesResult(success=False, message="ConnectWise client not available.")

    # Check cache first
    cached_result = cache_get('work_roles')
    if cached_result is not None:
        logger.info("Using cached work roles")
        return cached_result

    try:
        # In development mode, return sample data
        if config.DEVELOPMENT_MODE:
            logger.warning("Using sample work roles for development mode")
            work_roles = [
                WorkRoleDetail(id=1, name="Project Manager", inactive_flag=False),
                WorkRoleDetail(id=2, name="Engineer", inactive_flag=False),
                WorkRoleDetail(id=3, name="Technician", inactive_flag=False)
            ]
            result = ListWorkRolesResult(
                success=True,
                work_roles=work_roles,
                message=f"Found {len(work_roles)} work roles (mock data)."
            )
            cache_set('work_roles', result)
            return result
            
        # API endpoint access might differ between versions
        try:
            # First try the direct endpoint approach (newer versions)
            api_client = cast(ConnectWiseClient, manage_api_client)
            # Use the lower level _make_request method on time endpoint
            response = api_client.time._make_request("GET", path="workroles")
            if response.status_code == 200:
                work_roles_data = response.json()
            else:
                raise ConnectWiseException(f"Failed to get work roles: {response.status_code}")
        except (AttributeError, ConnectWiseException) as e:
            logger.warning(f"Could not get work roles via direct API path: {e}")
            # Fallback to mock data
            work_roles_data = [
                {"id": 1, "name": "Project Manager", "inactiveFlag": False},
                {"id": 2, "name": "Engineer", "inactiveFlag": False},
                {"id": 3, "name": "Technician", "inactiveFlag": False}
            ]

        # Map response to WorkRoleDetail objects
        work_roles = []
        for work_role in work_roles_data:
            # Handle both object and dictionary response formats
            if isinstance(work_role, dict):
                work_role_id = work_role.get('id')
                work_role_name = work_role.get('name')
                inactive_flag = work_role.get('inactiveFlag', False)
            else:
                work_role_id = getattr(work_role, 'id', None)
                work_role_name = getattr(work_role, 'name', None)
                inactive_flag = getattr(work_role, 'inactiveFlag', False)
                
            work_roles.append(WorkRoleDetail(
                id=work_role_id,
                name=work_role_name,
                inactive_flag=inactive_flag
            ))

        result = ListWorkRolesResult(
            success=True,
            work_roles=work_roles,
            message=f"Found {len(work_roles)} work roles."
        )

        # Cache the result
        cache_set('work_roles', result)

        return result
    except Exception as e:
        return _handle_cw_error(e, "list_work_roles_impl", ListWorkRolesResult)

# --- Agent Tool Definition ---
@function_tool()
def list_work_roles() -> ListWorkRolesResult:
    """Get all work roles from ConnectWise.

    Work roles are used for time entries to categorize the role of the person performing the work.
    """
    logger.info("Tool 'list_work_roles' called")
    return list_work_roles_impl()

# --- Implementation Function ---
def assign_resource_to_ticket_impl(ticket_id: int, member_identifier: str) -> AssignResourceResult:
    """Assign a resource (member) to a ticket."""
    if not manage_api_client:
        return AssignResourceResult(success=False, message="ConnectWise client not available.")

    logger.info(f"Logic: Assigning resource '{member_identifier}' to ticket {ticket_id}")

    try:
        # First, find the member by identifier
        member_result = find_member_impl(member_identifier)
        if not member_result.success or not member_result.found:
            return AssignResourceResult(
                success=False,
                message=f"Could not find member with identifier '{member_identifier}'",
                ticket_id=ticket_id
            )

        member_id = member_result.member.id
        if not member_id:
            return AssignResourceResult(
                success=False,
                message="Member found but has no ID",
                ticket_id=ticket_id
            )

        # Get the current ticket to check if it exists
        ticket = manage_api_client.service.tickets.get_by_id(ticket_id)
        if not ticket:
            return AssignResourceResult(
                success=False,
                message=f"Ticket {ticket_id} not found",
                ticket_id=ticket_id
            )

        # Create a resource assignment
        resource_data = {
            "ticketId": ticket_id,
            "member": {"id": member_id}
        }

        # Check if the resource is already assigned
        existing_resources = manage_api_client.service.tickets.resources.get(ticket_id)
        for resource in existing_resources:
            if getattr(resource, "member", {}).get("id") == member_id:
                return AssignResourceResult(
                    success=True,
                    message=f"Member '{member_identifier}' is already assigned to ticket {ticket_id}",
                    ticket_id=ticket_id,
                    resource_id=member_id
                )

        # Add the resource
        response = manage_api_client.service.tickets.resources.post(ticket_id, resource_data)

        return AssignResourceResult(
            success=True,
            message=f"Successfully assigned member '{member_identifier}' to ticket {ticket_id}",
            ticket_id=ticket_id,
            resource_id=member_id
        )
    except Exception as e:
        return _handle_cw_error(e, "assign_resource_to_ticket_impl", AssignResourceResult, ticket_id=ticket_id)

# --- Agent Tool Definition ---
@function_tool()
def assign_resource_to_ticket(ticket_id: int, member_identifier: str) -> AssignResourceResult:
    """Assign a resource (member) to a ticket.

    Required parameters:
    - ticket_id: The ID of the ticket to assign the resource to
    - member_identifier: The identifier (username) of the member to assign
    """
    logger.info(f"Tool 'assign_resource_to_ticket' called for ticket {ticket_id}, member {member_identifier}")
    return assign_resource_to_ticket_impl(ticket_id=ticket_id, member_identifier=member_identifier)

# --- Implementation Function ---
def remove_resource_from_ticket_impl(ticket_id: int, member_identifier: str) -> RemoveResourceResult:
    """Remove a resource (member) from a ticket."""
    if not manage_api_client:
        return RemoveResourceResult(success=False, message="ConnectWise client not available.")

    logger.info(f"Logic: Removing resource '{member_identifier}' from ticket {ticket_id}")

    try:
        # First, find the member by identifier
        member_result = find_member_impl(member_identifier)
        if not member_result.success or not member_result.found:
            return RemoveResourceResult(
                success=False,
                message=f"Could not find member with identifier '{member_identifier}'",
                ticket_id=ticket_id
            )

        member_id = member_result.member.id
        if not member_id:
            return RemoveResourceResult(
                success=False,
                message="Member found but has no ID",
                ticket_id=ticket_id
            )

        # Get the current ticket to check if it exists
        ticket = manage_api_client.service.tickets.get_by_id(ticket_id)
        if not ticket:
            return RemoveResourceResult(
                success=False,
                message=f"Ticket {ticket_id} not found",
                ticket_id=ticket_id
            )

        # Check if the resource is assigned and get the resource ID
        existing_resources = manage_api_client.service.tickets.resources.get(ticket_id)
        resource_id = None
        for resource in existing_resources:
            if getattr(resource, "member", {}).get("id") == member_id:
                resource_id = getattr(resource, "id", None)
                break

        if not resource_id:
            return RemoveResourceResult(
                success=True,
                message=f"Member '{member_identifier}' is not assigned to ticket {ticket_id}",
                ticket_id=ticket_id,
                resource_id=member_id
            )

        # Remove the resource
        manage_api_client.service.tickets.resources.delete(ticket_id, resource_id)

        return RemoveResourceResult(
            success=True,
            message=f"Successfully removed member '{member_identifier}' from ticket {ticket_id}",
            ticket_id=ticket_id,
            resource_id=member_id
        )
    except Exception as e:
        return _handle_cw_error(e, "remove_resource_from_ticket_impl", RemoveResourceResult, ticket_id=ticket_id)

# --- Agent Tool Definition ---
@function_tool()
def remove_resource_from_ticket(ticket_id: int, member_identifier: str) -> RemoveResourceResult:
    """Remove a resource (member) from a ticket.

    Required parameters:
    - ticket_id: The ID of the ticket to remove the resource from
    - member_identifier: The identifier (username) of the member to remove
    """
    logger.info(f"Tool 'remove_resource_from_ticket' called for ticket {ticket_id}, member {member_identifier}")
    return remove_resource_from_ticket_impl(ticket_id=ticket_id, member_identifier=member_identifier)

# --- Implementation Function ---
def list_locations_impl() -> ListLocationsResult:
    """Get all locations from ConnectWise."""
    if not manage_api_client:
        return ListLocationsResult(success=False, message="ConnectWise client not available.")

    # Check cache first
    cached_result = cache_get('locations')
    if cached_result is not None:
        logger.info("Using cached locations")
        return cached_result

    try:
        # Get locations
        response = manage_api_client.system.locations.get()

        # Map response to LocationDetail objects
        locations = []
        for location in response:
            locations.append(LocationDetail(
                id=getattr(location, 'id', None),
                name=getattr(location, 'name', None),
                inactive_flag=getattr(location, 'inactiveFlag', False)
            ))

        result = ListLocationsResult(
            success=True,
            locations=locations,
            message=f"Found {len(locations)} locations."
        )

        # Cache the result
        cache_set('locations', result)

        return result
    except Exception as e:
        return _handle_cw_error(e, "list_locations_impl", ListLocationsResult)

# --- Agent Tool Definition ---
@function_tool()
def list_locations() -> ListLocationsResult:
    """Get all locations from ConnectWise.

    Locations are used for time entries to indicate where the work was performed.
    """
    logger.info("Tool 'list_locations' called")
    return list_locations_impl()
</file>

<file path="cw_tools/error_handling.py">
"""
Enhanced error handling for ConnectWise tools.

This module provides comprehensive error handling for all ConnectWise tools,
including detailed error messages, error categorization, and fallback behaviors.
"""

import logging
import traceback
from typing import Any, Dict, Type, Optional, TypeVar, cast, Union
from pydantic import BaseModel, ValidationError
from pyconnectwise.exceptions import ConnectWiseException  # type: ignore

# Define a type variable for the result model
T = TypeVar('T', bound=BaseModel)

logger = logging.getLogger(__name__)

# Error categories
class ErrorCategory:
    """Error categories for better error handling and user feedback."""
    AUTHENTICATION = "AuthenticationError"  # Authentication issues
    AUTHORIZATION = "AuthorizationError"    # Permission issues
    VALIDATION = "ValidationError"          # Input validation issues
    NOT_FOUND = "NotFoundError"             # Resource not found
    API_ERROR = "APIError"                  # ConnectWise API errors
    RATE_LIMIT = "RateLimitError"           # Rate limiting issues
    NETWORK = "NetworkError"                # Network connectivity issues
    TIMEOUT = "TimeoutError"                # Request timeout
    INTERNAL = "InternalError"              # Internal server errors
    UNKNOWN = "UnknownError"                # Unclassified errors

# User-friendly error messages
ERROR_MESSAGES = {
    ErrorCategory.AUTHENTICATION: "Your session may have expired. Please refresh the page or log out and log back in.",
    ErrorCategory.AUTHORIZATION: "You don't have permission to perform this action. Please contact your administrator.",
    ErrorCategory.VALIDATION: "The provided information is invalid or incomplete.",
    ErrorCategory.NOT_FOUND: "The requested resource could not be found.",
    ErrorCategory.API_ERROR: "There was an error communicating with ConnectWise.",
    ErrorCategory.RATE_LIMIT: "Too many requests. Please try again later.",
    ErrorCategory.NETWORK: "Network connection issue. Please check your internet connection.",
    ErrorCategory.TIMEOUT: "The request timed out. Please try again.",
    ErrorCategory.INTERNAL: "An internal server error occurred.",
    ErrorCategory.UNKNOWN: "An unexpected error occurred."
}

def categorize_error(exception: Exception) -> str:
    """
    Categorize an exception into one of the defined error categories.
    
    Args:
        exception: The exception to categorize
        
    Returns:
        The error category as a string
    """
    if isinstance(exception, ConnectWiseException):
        status_code = getattr(exception, "status_code", None)
        if status_code:
            if status_code == 401:
                return ErrorCategory.AUTHENTICATION
            elif status_code == 403:
                return ErrorCategory.AUTHORIZATION
            elif status_code == 404:
                return ErrorCategory.NOT_FOUND
            elif status_code == 429:
                return ErrorCategory.RATE_LIMIT
            elif 400 <= status_code < 500:
                return ErrorCategory.VALIDATION
            elif 500 <= status_code < 600:
                return ErrorCategory.API_ERROR
        return ErrorCategory.API_ERROR
    elif isinstance(exception, ValidationError):
        return ErrorCategory.VALIDATION
    elif isinstance(exception, ValueError):
        return ErrorCategory.VALIDATION
    elif isinstance(exception, TimeoutError):
        return ErrorCategory.TIMEOUT
    elif isinstance(exception, ConnectionError):
        return ErrorCategory.NETWORK
    else:
        return ErrorCategory.UNKNOWN

def get_user_friendly_message(error_category: str, exception: Exception) -> str:
    """
    Get a user-friendly error message based on the error category.
    
    Args:
        error_category: The error category
        exception: The original exception
        
    Returns:
        A user-friendly error message
    """
    base_message = ERROR_MESSAGES.get(error_category, ERROR_MESSAGES[ErrorCategory.UNKNOWN])
    
    # Add specific details for certain error types
    if error_category == ErrorCategory.VALIDATION:
        if isinstance(exception, ValidationError):
            # Extract field names from validation error
            field_errors = []
            for error in exception.errors():
                field = ".".join(str(loc) for loc in error["loc"])
                field_errors.append(f"{field}: {error['msg']}")
            
            if field_errors:
                return f"{base_message} Please check the following fields: {', '.join(field_errors)}"
    
    # For API errors, include the status code if available
    if error_category == ErrorCategory.API_ERROR and isinstance(exception, ConnectWiseException):
        status_code = getattr(exception, "status_code", None)
        if status_code:
            return f"{base_message} (Status code: {status_code})"
    
    return base_message

def handle_error(exception: Exception, tool_name: str, result_model_type: Type[T], **kwargs) -> T:
    """
    Enhanced error handling for ConnectWise tools.
    
    Args:
        exception: The exception that occurred
        tool_name: The name of the tool that raised the exception
        result_model_type: The Pydantic model type for the result
        **kwargs: Additional context information
        
    Returns:
        An instance of the result model with error information
    """
    # Get stack trace for logging
    stack_trace = traceback.format_exc()
    
    # Categorize the error
    error_category = categorize_error(exception)
    
    # Get user-friendly message
    user_message = get_user_friendly_message(error_category, exception)
    
    # Get technical details for logging
    technical_details = str(exception)
    
    # Log the error with appropriate level based on category
    log_msg = f"Error in ConnectWise tool '{tool_name}'"
    if kwargs:
        log_msg += f" with args: {kwargs}"
    
    if error_category in [ErrorCategory.INTERNAL, ErrorCategory.UNKNOWN]:
        logger.error(f"{log_msg}. {error_category}: {technical_details}\n{stack_trace}")
    elif error_category in [ErrorCategory.API_ERROR, ErrorCategory.NETWORK, ErrorCategory.TIMEOUT]:
        logger.error(f"{log_msg}. {error_category}: {technical_details}")
    else:
        logger.warning(f"{log_msg}. {error_category}: {technical_details}")
    
    # Prepare error information for the result model
    error_info: Dict[str, Any] = {
        "success": False,
        "error_type": error_category,
        "message": user_message
    }
    
    # Add status code for API errors
    if error_category == ErrorCategory.API_ERROR and isinstance(exception, ConnectWiseException):
        status_code = getattr(exception, "status_code", None)
        if status_code:
            error_info["status_code"] = status_code
    
    # Try to instantiate the result model
    try:
        return cast(T, result_model_type(**error_info))
    except Exception as model_e:
        # Log the error and fall back to a generic error
        logger.error(f"Failed to instantiate error model {result_model_type.__name__}: {model_e}")
        
        # Try with minimal fields
        try:
            return cast(T, result_model_type(success=False, message=user_message))
        except Exception:
            # If all else fails, return a dictionary (will likely cause type errors, but better than crashing)
            logger.critical(f"Could not create any error response for {tool_name}. This is a serious issue.")
            return cast(T, error_info)  # type: ignore

def with_error_handling(func):
    """
    Decorator to add error handling to a function.
    
    Args:
        func: The function to decorate
        
    Returns:
        The decorated function with error handling
    """
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            # Get the result model type from the function's return type annotation
            result_model_type = getattr(func, "__annotations__", {}).get("return")
            if not result_model_type or not issubclass(result_model_type, BaseModel):
                # Fall back to a generic BaseModel if no valid return type annotation
                logger.warning(f"Function {func.__name__} has no valid return type annotation. Using generic error handling.")
                result_model_type = BaseModel
            
            return handle_error(e, func.__name__, result_model_type, **kwargs)
    
    return wrapper

def get_fallback_value(error: Exception, default_value: Any) -> Any:
    """
    Get a fallback value when an error occurs.
    
    Args:
        error: The exception that occurred
        default_value: The default value to return
        
    Returns:
        The fallback value
    """
    logger.warning(f"Using fallback value due to error: {error}")
    return default_value

# Export the public API
__all__ = [
    "ErrorCategory",
    "handle_error",
    "with_error_handling",
    "get_fallback_value",
    "categorize_error",
    "get_user_friendly_message"
]
</file>

<file path="cw_tools/member_utils.py">
"""
Utility functions for ConnectWise member operations.
Includes caching and error handling for member lookups.
"""
import logging
from typing import Dict, Any, Optional, Tuple

from ..cw_tools.api_client import manage_api_client, cache_get, cache_set

logger = logging.getLogger(__name__)

def find_member_by_email(email: str) -> Tuple[bool, Optional[Any], str]:
    """
    Find a ConnectWise member by email address with caching.

    Args:
        email: The email address to search for

    Returns:
        Tuple containing:
        - success: Boolean indicating if the operation was successful
        - member: The member object if found, None otherwise
        - message: A message describing the result or error
    """
    if not email:
        return False, None, "No email provided"

    if not manage_api_client:
        return False, None, "ConnectWise API client not initialized"

    # Check cache first
    cached_member = cache_get('member_by_email', email=email)
    if cached_member:
        logger.info(f"Found member for email {email} in cache")
        return True, cached_member, "Member found in cache"

    try:
        logger.info(f"Searching for member with email: {email}")
        fields_to_get = "id,identifier,firstName,lastName,officeEmail,inactiveFlag,emailAddress"
        found_member_data = None

        # First try by exact officeEmail match
        try:
            logger.info(f"Trying to find member by exact officeEmail match: {email}")
            params = {
                "conditions": f"officeEmail='{email}'",
                "pageSize": 1,
                "fields": fields_to_get
            }
            response = manage_api_client.system.members._make_request("GET", params=params)
            response.raise_for_status()
            members_raw = response.json()

            if members_raw and isinstance(members_raw, list) and len(members_raw) > 0:
                found_member_data = members_raw[0]
                logger.info(f"Found member by exact officeEmail match: {email}")
        except Exception as e:
            logger.debug(f"Error searching member by exact officeEmail '{email}': {e}")

        # Then try by identifier (some companies use email as identifier)
        if not found_member_data:
            try:
                logger.info(f"Trying to find member by identifier: {email}")
                params = {
                    "conditions": f"identifier='{email}'",
                    "pageSize": 1,
                    "fields": fields_to_get
                }
                response = manage_api_client.system.members._make_request("GET", params=params)
                response.raise_for_status()
                members_raw = response.json()

                if members_raw and isinstance(members_raw, list) and len(members_raw) > 0:
                    found_member_data = members_raw[0]
                    logger.info(f"Found member by identifier: {email}")
            except Exception as e:
                logger.debug(f"Error searching member by identifier '{email}': {e}")

        # Try with 'contains' for partial match on officeEmail
        if not found_member_data:
            try:
                logger.info(f"Trying to find member by partial officeEmail match: {email}")
                params = {
                    "conditions": f"officeEmail contains '{email}'",
                    "pageSize": 10,
                    "fields": fields_to_get
                }
                response = manage_api_client.system.members._make_request("GET", params=params)
                response.raise_for_status()
                members_raw = response.json()

                if members_raw and isinstance(members_raw, list) and len(members_raw) > 0:
                    # Log all potential matches
                    for m in members_raw[:5]:  # Just log the first 5 to avoid flooding logs
                        logger.info(f"Potential partial match: {m.get('identifier', 'unknown')} with officeEmail={m.get('officeEmail', 'None')}")

                    found_member_data = members_raw[0]
                    logger.info(f"Found member by partial officeEmail match: {email}")
            except Exception as e:
                logger.debug(f"Error searching member by partial officeEmail '{email}': {e}")

        # Try with domain match if email contains @
        if not found_member_data and '@' in email:
            try:
                domain = email.split('@')[1]
                logger.info(f"Trying to find member by email domain: {domain}")
                params = {
                    "conditions": f"officeEmail contains '@{domain}'",
                    "pageSize": 10,
                    "fields": fields_to_get,
                    "inactiveFlag": False  # Only get active members
                }
                response = manage_api_client.system.members._make_request("GET", params=params)
                response.raise_for_status()
                members_raw = response.json()

                if members_raw and isinstance(members_raw, list) and len(members_raw) > 0:
                    # Log all potential matches
                    for m in members_raw[:5]:  # Just log the first 5 to avoid flooding logs
                        logger.info(f"Potential domain match: {m.get('identifier', 'unknown')} with officeEmail={m.get('officeEmail', 'None')}")

                    found_member_data = members_raw[0]
                    logger.info(f"Found member by email domain: {domain}")
            except Exception as e:
                logger.debug(f"Error searching member by email domain '{domain}': {e}")

        # Process the found member data
        if found_member_data and isinstance(found_member_data, dict):
            # Check if member is inactive
            is_inactive = found_member_data.get('inactiveFlag', False)
            if is_inactive:
                logger.warning(f"Found member for email {email} but they are INACTIVE")
                return False, None, f"Member found for email {email} but they are inactive"

            # Create member object from API response
            member = type('Member', (), {})()
            for key, value in found_member_data.items():
                setattr(member, key, value)

            # Cache the member
            cache_set('member_by_email', member, email=email)
            return True, member, f"Found member by email: {email}"
        else:
            logger.warning(f"No member found for email: {email}")
            return False, None, f"No member found for email: {email}"

    except Exception as e:
        logger.error(f"Error searching for member by email {email}: {str(e)}", exc_info=True)
        return False, None, f"Error searching for member: {str(e)}"

def find_member_by_name(name: str) -> Tuple[bool, Optional[Any], str]:
    """
    Find a ConnectWise member by name with caching.

    Args:
        name: The name to search for

    Returns:
        Tuple containing:
        - success: Boolean indicating if the operation was successful
        - member: The member object if found, None otherwise
        - message: A message describing the result or error
    """
    if not name:
        return False, None, "No name provided"

    if not manage_api_client:
        return False, None, "ConnectWise API client not initialized"

    # Check cache first
    cached_member = cache_get('member_by_name', name=name)
    if cached_member:
        logger.info(f"Found member for name {name} in cache")
        return True, cached_member, "Member found in cache"

    try:
        logger.info(f"Searching for member with name: {name}")
        fields_to_get = "id,identifier,firstName,lastName,name,officeEmail,inactiveFlag"
        found_member_data = None

        # First try by exact name match
        try:
            logger.info(f"Trying to find member by exact name match: {name}")
            params = {
                "conditions": f"name='{name}'",
                "pageSize": 1,
                "fields": fields_to_get
            }
            response = manage_api_client.system.members._make_request("GET", params=params)
            response.raise_for_status()
            members_raw = response.json()

            if members_raw and isinstance(members_raw, list) and len(members_raw) > 0:
                found_member_data = members_raw[0]
                logger.info(f"Found member by exact name match: {name}")
        except Exception as e:
            logger.debug(f"Error searching member by exact name '{name}': {e}")

        # Try with 'contains' for partial match on name
        if not found_member_data:
            try:
                logger.info(f"Trying to find member by partial name match: {name}")
                params = {
                    "conditions": f"name contains '{name}'",
                    "pageSize": 10,
                    "fields": fields_to_get
                }
                response = manage_api_client.system.members._make_request("GET", params=params)
                response.raise_for_status()
                members_raw = response.json()

                if members_raw and isinstance(members_raw, list) and len(members_raw) > 0:
                    # Log all potential matches
                    for m in members_raw[:5]:  # Just log the first 5 to avoid flooding logs
                        logger.info(f"Potential partial match: {m.get('identifier', 'unknown')} with name={m.get('name', 'None')}")

                    found_member_data = members_raw[0]
                    logger.info(f"Found member by partial name match: {name}")
            except Exception as e:
                logger.debug(f"Error searching member by partial name '{name}': {e}")

        # Try with firstName/lastName combination
        if not found_member_data and ' ' in name:
            try:
                # Split the name into first and last
                name_parts = name.split(' ', 1)
                first_name = name_parts[0]
                last_name = name_parts[1] if len(name_parts) > 1 else ''

                logger.info(f"Trying to find member by firstName/lastName: {first_name}/{last_name}")
                params = {
                    "conditions": f"firstName='{first_name}' AND lastName='{last_name}'",
                    "pageSize": 1,
                    "fields": fields_to_get
                }
                response = manage_api_client.system.members._make_request("GET", params=params)
                response.raise_for_status()
                members_raw = response.json()

                if members_raw and isinstance(members_raw, list) and len(members_raw) > 0:
                    found_member_data = members_raw[0]
                    logger.info(f"Found member by firstName/lastName: {first_name}/{last_name}")
            except Exception as e:
                logger.debug(f"Error searching member by firstName/lastName: {e}")

        # Process the found member data
        if found_member_data and isinstance(found_member_data, dict):
            # Check if member is inactive
            is_inactive = found_member_data.get('inactiveFlag', False)
            if is_inactive:
                logger.warning(f"Found member for name {name} but they are INACTIVE")
                return False, None, f"Member found for name {name} but they are inactive"

            # Create member object from API response
            member = type('Member', (), {})()
            for key, value in found_member_data.items():
                setattr(member, key, value)

            # Cache the member
            cache_set('member_by_name', member, name=name)
            return True, member, f"Found member by name: {name}"
        else:
            logger.warning(f"No member found for name: {name}")
            return False, None, f"No member found for name: {name}"

    except Exception as e:
        logger.error(f"Error searching for member by name {name}: {str(e)}", exc_info=True)
        return False, None, f"Error searching for member: {str(e)}"

def get_member_info(user_email: str, user_name: str) -> Dict[str, Any]:
    """
    Get member information for a user based on email or name.

    Args:
        user_email: The user's email address
        user_name: The user's name

    Returns:
        Dictionary with member information or default values if not found
    """
    logger.info(f"Getting member info for user: {user_name} ({user_email})")

    # Try by email first (most reliable method)
    if user_email:
        success, member, message = find_member_by_email(user_email)
        if success and member:
            logger.info(f"Found member by email: {user_email}")
            return {
                "id": getattr(member, "id", None),
                "identifier": getattr(member, "identifier", None),
                "firstName": getattr(member, "firstName", None),
                "lastName": getattr(member, "lastName", None),
                "name": f"{getattr(member, 'firstName', '')} {getattr(member, 'lastName', '')}".strip(),
                "email": getattr(member, "officeEmail", user_email),
                "message": message
            }
        else:
            logger.warning(f"Could not find member by email: {user_email}")

    # Try by name if email lookup failed
    if user_name:
        success, member, message = find_member_by_name(user_name)
        if success and member:
            logger.info(f"Found member by name: {user_name}")
            return {
                "id": getattr(member, "id", None),
                "identifier": getattr(member, "identifier", None),
                "firstName": getattr(member, "firstName", None),
                "lastName": getattr(member, "lastName", None),
                "name": f"{getattr(member, 'firstName', '')} {getattr(member, 'lastName', '')}".strip(),
                "email": getattr(member, "officeEmail", user_email),
                "message": message
            }
        else:
            logger.warning(f"Could not find member by name: {user_name}")

    # Do NOT use the first member as fallback - only use Azure AD identity
    # If we have user information, use that even without a ConnectWise member match
    if user_email or user_name:
        logger.info(f"Using provided Azure AD user information: {user_name} ({user_email})")
        return {
            "id": None,
            "identifier": user_email or user_name,
            "name": user_name or user_email,
            "email": user_email,
            "message": "Using Azure AD user information (no ConnectWise member found)"
        }

    # Ultimate fallback to default member info
    return {
        "id": None,
        "identifier": None,
        "name": user_name,
        "email": user_email,
        "message": "No member found in ConnectWise"
    }
</file>

<file path="cw_tools/models.py">
from typing import Dict, Any, List, Optional, Union
from pydantic import BaseModel, Field
from dataclasses import dataclass

# --- Context Models ---

class CwMemberInfo(BaseModel):
    """Model for ConnectWise member information."""
    id: Optional[int] = None
    identifier: Optional[str] = None
    name: Optional[str] = None
    email: Optional[str] = None

class UIState(BaseModel):
    """Model for UI state context."""
    current_view: Optional[str] = None
    entity_id: Optional[Union[int, str]] = None # Can be ticket ID (int) or other ID (str)
    active_tab: Optional[str] = None
    # Add other relevant UI state fields as needed
    class Config:
        extra = 'ignore' # Ignore extra fields if passed

class TicketContextData(BaseModel):
    """Model for additional ticket-specific context."""
    # Define fields expected in ticket_context if any
    # Example: related_ticket_ids: Optional[List[int]] = None
    class Config:
        extra = 'ignore' # Ignore extra fields if passed

@dataclass
class ToolContext:
    """Context for ConnectWise tools, used to pass information between tools and the agent."""
    cw_member_info: Optional[CwMemberInfo] = None
    ui_state: Optional[UIState] = None # Use specific Pydantic model
    ticket_context: Optional[TicketContextData] = None # Use specific Pydantic model

# --- Base and Detail Models ---

class BaseToolResult(BaseModel):
    """Base model for ConnectWise tool results."""
    success: bool
    message: Optional[str] = None
    error_type: Optional[str] = None
    status_code: Optional[int] = None

class NoteDetail(BaseModel):
    """Model for ConnectWise ticket note details."""
    note_id: Optional[int] = None
    date: Optional[str] = None
    member: Optional[str] = None
    text: Optional[str] = None
    is_internal: Optional[bool] = None
    is_resolution: Optional[bool] = None

class TimeEntryDetail(BaseModel):
    """Model for ConnectWise time entry details."""
    entry_id: Optional[int] = None
    date: Optional[str] = None
    member: Optional[str] = None
    hours: Optional[float] = None
    notes: Optional[str] = None

class BoardDetail(BaseModel):
    """Model for ConnectWise service board details."""
    id: Optional[int] = None
    name: Optional[str] = None

class StatusDetail(BaseModel):
    """Model for ConnectWise status details."""
    id: Optional[int] = None
    name: Optional[str] = None
    is_closed: Optional[bool] = None

class PriorityDetail(BaseModel):
    """Model for ConnectWise priority details."""
    id: Optional[int] = None
    name: Optional[str] = None
    sort: Optional[int] = None # Add other relevant fields if needed

class TypeDetail(BaseModel):
    """Model for ticket type information."""
    id: Optional[int] = None
    name: Optional[str] = None
    board_id: Optional[int] = None
    inactive_flag: Optional[bool] = None

class SubtypeDetail(BaseModel):
    """Model for ticket subtype information."""
    id: Optional[int] = None
    name: Optional[str] = None
    type_id: Optional[int] = None
    inactive_flag: Optional[bool] = None

class ItemDetail(BaseModel):
    """Model for ticket item information."""
    id: Optional[int] = None
    name: Optional[str] = None
    subtype_id: Optional[int] = None
    inactive_flag: Optional[bool] = None

class CompanyDetail(BaseModel):
    """Model for ConnectWise company details."""
    id: Optional[int] = None
    name: Optional[str] = None
    identifier: Optional[str] = None
    status: Optional[str] = None
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    zip: Optional[str] = None
    country: Optional[str] = None
    phone_number: Optional[str] = None
    fax_number: Optional[str] = None
    website: Optional[str] = None
    type_name: Optional[str] = None
    territory_name: Optional[str] = None

class ContactDetail(BaseModel):
    """Model for ConnectWise contact details."""
    id: Optional[int] = None
    name: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    email: Optional[str] = None
    title: Optional[str] = None
    phone_number: Optional[str] = None
    mobile_number: Optional[str] = None
    fax_number: Optional[str] = None
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    zip: Optional[str] = None
    country: Optional[str] = None
    company_id: Optional[int] = None
    company_name: Optional[str] = None
    site_id: Optional[int] = None
    site_name: Optional[str] = None
    inactive_flag: Optional[bool] = None

class MemberDetail(BaseModel):
    """Model for ConnectWise member details."""
    id: Optional[int] = None
    identifier: Optional[str] = None
    name: Optional[str] = None
    email: Optional[str] = None

class TicketSummary(BaseModel):
    """Model for summarized ticket information (e.g., for tables)."""
    ticket_id: Optional[int] = None
    summary: Optional[str] = None
    status: Optional[str] = None
    board_id: Optional[int] = None
    board_name: Optional[str] = None
    company_id: Optional[int] = None
    company_name: Optional[str] = None
    contact_id: Optional[int] = None
    contact_name: Optional[str] = None
    owner_identifier: Optional[str] = None # Assigned Resource
    priority: Optional[str] = None
    date_entered: Optional[str] = None
    # Additional ticket metadata
    ticket_type: Optional[str] = None
    ticket_subtype: Optional[str] = None
    ticket_item: Optional[str] = None

# --- Specific Tool Result Models ---

class GetTicketDetailsResult(BaseToolResult):
    """Result model for get_ticket_details tool."""
    ticket_id: Optional[int] = None
    summary: str = ""  # Make required but provide default
    status: Optional[str] = None
    board_id: Optional[int] = None
    board_name: Optional[str] = None
    company_id: Optional[int] = None
    company_name: Optional[str] = None
    contact_id: Optional[int] = None
    contact_name: Optional[str] = None
    owner_identifier: Optional[str] = None
    owner_name: Optional[str] = None
    owner_id: Optional[int] = None
    priority: Optional[str] = None
    is_closed: Optional[bool] = None
    date_entered: Optional[str] = None
    initial_description: Optional[str] = None
    notes: Optional[List[NoteDetail]] = None
    time_entries: Optional[List[TimeEntryDetail]] = None

    class Config:
        # Allow extra fields to be included in the model
        extra = "ignore"

class AddNoteResult(BaseToolResult):
    """Result model for add_ticket_note tool."""
    note_id: Optional[int] = None

class ChangeStatusResult(BaseToolResult):
    """Result model for change_ticket_status tool."""
    pass # Only success/message needed

class CreateTicketResult(BaseToolResult):
    """Result model for create_new_ticket tool."""
    ticket_id: Optional[int] = None

class CloseTicketResult(BaseToolResult):
    """Result model for close_ticket tool."""
    already_closed: Optional[bool] = None

class ListBoardsResult(BaseToolResult):
    """Result model for list_service_boards tool."""
    boards: Optional[List[BoardDetail]] = None

class ListStatusesResult(BaseToolResult):
    """Result model for list_ticket_statuses tool."""
    statuses: Optional[List[StatusDetail]] = None

class ListPrioritiesResult(BaseToolResult):
    """Result model for list_ticket_priorities tool."""
    priorities: Optional[List[PriorityDetail]] = None

class ListTypesResult(BaseToolResult):
    """Result model for get_board_types tool."""
    types: Optional[List[TypeDetail]] = None

class ListSubtypesResult(BaseToolResult):
    """Result model for get_type_subtypes tool."""
    subtypes: Optional[List[SubtypeDetail]] = None

class ListItemsResult(BaseToolResult):
    """Result model for get_subtype_items tool."""
    items: Optional[List[ItemDetail]] = None

class FindCompanyResult(BaseToolResult):
    """Result model for find_company tool."""
    found: Optional[bool] = None
    company: Optional[CompanyDetail] = None
    matches: Optional[List[CompanyDetail]] = None  # Added for fuzzy search results

class FindContactResult(BaseToolResult):
    """Result model for find_contact tool."""
    found: Optional[bool] = None
    contact: Optional[ContactDetail] = None
    matches: Optional[List[ContactDetail]] = None  # Added for fuzzy search results

class FindMemberResult(BaseToolResult):
    """Result model for find_member tool."""
    found: Optional[bool] = None
    member: Optional[MemberDetail] = None
    matches: Optional[List[MemberDetail]] = None  # Added for fuzzy search results

class AddTimeEntryResult(BaseToolResult):
    """Result model for add_time_entry tool."""
    entry_id: Optional[int] = None

class QueryTicketsResult(BaseToolResult):
    """Result model for search_tickets_tool."""
    tickets: Optional[List[TicketSummary]] = None
    total_found: Optional[int] = None

class CreateCompanyResult(BaseToolResult):
    """Result model for create_company tool."""
    company_id: Optional[int] = None
    company_identifier: Optional[str] = None

class CreateContactResult(BaseToolResult):
    """Result model for create_contact tool."""
    contact_id: Optional[int] = None

class UpdateTicketContactResult(BaseToolResult):
    """Result model for update_ticket_contact tool."""
    pass # Only success/message needed

class GetCompanyDetailsResult(BaseToolResult):
    """Result model for get_company_details tool."""
    company: Optional[CompanyDetail] = None

class GetCompanyContactsResult(BaseToolResult):
    """Result model for get_company_contacts tool."""
    contacts: Optional[List[ContactDetail]] = None
    total_count: Optional[int] = None
    company_id: Optional[int] = None
    company_name: Optional[str] = None


# --- Activity Models ---

class ActivityItem(BaseModel):
    """Model for a single activity item (note, time entry, etc.)."""
    type: str  # "note", "time_entry", "status_change", etc.
    date: str
    actor: Any  # Member name/identifier - can be string or MemberReference object
    description: str
    details: Optional[Dict[str, Any]] = None

    def model_dump(self):
        """Custom serialization to handle MemberReference objects."""
        data = super().model_dump()
        # Convert actor to string if it's not already
        if hasattr(data['actor'], 'name'):
            data['actor'] = data['actor'].name
        return data

class TicketActivityResult(BaseToolResult):
    """Result model for get_ticket_activity tool."""
    ticket_id: Optional[int] = None
    activity: List[ActivityItem] = []
    days: Optional[int] = None

class UpdateTicketOwnerResult(BaseToolResult):
    """Result model for update_ticket_owner tool."""
    pass # Only success/message needed

class UpdateTicketResult(BaseToolResult):
    """Generic result model for simple ticket updates (summary, priority)."""
    pass # Only success/message needed

class AttachmentInfo(BaseModel):
    """Model for ticket attachment information."""
    id: Optional[int] = None
    file_name: Optional[str] = None
    title: Optional[str] = None
    size: Optional[int] = None
    upload_date: Optional[str] = None
    uploaded_by: Optional[str] = None
    content_type: Optional[str] = None
    url: Optional[str] = None

class GetTicketAttachmentsResult(BaseToolResult):
    """Result model for get_ticket_attachments tool."""
    ticket_id: Optional[int] = None
    attachments: List[AttachmentInfo] = []


class WorkTypeDetail(BaseModel):
    """Model for ConnectWise work type details."""
    id: Optional[int] = None
    name: Optional[str] = None
    inactive_flag: Optional[bool] = None

class ListWorkTypesResult(BaseToolResult):
    """Result model for list_work_types tool."""
    work_types: Optional[List[WorkTypeDetail]] = None

class WorkRoleDetail(BaseModel):
    """Model for ConnectWise work role details."""
    id: Optional[int] = None
    name: Optional[str] = None
    inactive_flag: Optional[bool] = None

class ListWorkRolesResult(BaseToolResult):
    """Result model for list_work_roles tool."""
    work_roles: Optional[List[WorkRoleDetail]] = None

class LocationDetail(BaseModel):
    """Model for ConnectWise location details."""
    id: Optional[int] = None
    name: Optional[str] = None
    inactive_flag: Optional[bool] = None

class ListLocationsResult(BaseToolResult):
    """Result model for list_locations tool."""
    locations: Optional[List[LocationDetail]] = None

class ResourceDetail(BaseModel):
    """Model for ConnectWise resource details."""
    id: Optional[int] = None
    name: Optional[str] = None
    member_id: Optional[int] = None
    identifier: Optional[str] = None
    email: Optional[str] = None

class AssignResourceResult(BaseToolResult):
    """Result model for assign_resource_to_ticket tool."""
    ticket_id: Optional[int] = None
    resource_id: Optional[int] = None

class RemoveResourceResult(BaseToolResult):
    """Result model for remove_resource_from_ticket tool."""
    ticket_id: Optional[int] = None
    resource_id: Optional[int] = None

class MoveTicketResult(BaseToolResult):
    """Result model for move_ticket_to_board tool."""
    ticket_id: Optional[int] = None
    new_board_id: Optional[int] = None
    new_ticket_id: Optional[int] = None
</file>

<file path="cw_tools/README.md">
# ConnectWise Tools Module

This module provides tools for interacting with the ConnectWise Manage API. It is designed to be used by both the OpenAI Agents SDK and the FastAPI routes.

## Overview

The ConnectWise Tools module is structured to solve a specific architectural challenge: how to make the same functionality available to both the AI agent (which uses the OpenAI Agents SDK) and the API endpoints.

The OpenAI Agents SDK uses a `@function_tool()` decorator to define tools that the AI agent can use. However, this decorator transforms the function into a `FunctionTool` object, which is not directly callable. This creates a challenge when we want to use the same functionality in our API endpoints.

## Architecture

We've implemented a Tool Adapter pattern to solve this problem:

1. **Implementation Functions**: Core logic functions with names ending in `_impl` (e.g., `get_ticket_details_impl`)
2. **Decorated Tools**: Functions decorated with `@function_tool()` that the AI agent uses (e.g., `get_ticket_details`)
3. **Tool Adapter**: A class that maps function names to their implementation functions

## Files

- `__init__.py`: Exports the necessary classes and functions
- `activity.py`: Functions for working with ticket activity
- `api_client.py`: Client for the ConnectWise Manage API
- `cw_tools_main.py`: Main implementation of the ConnectWise tools
- `models.py`: Pydantic models for the tools
- `tool_adapter.py`: Adapter for accessing implementation functions

## Usage

### For the AI Agent

The AI agent uses the decorated tools:

```python
from app.cw_tools import get_ticket_details

# The agent will call this function through the OpenAI Agents SDK
```

### For API Routes

API routes use the Tool Adapter:

```python
from app.cw_tools.tool_adapter import tool_adapter

# Call the implementation function directly
result = tool_adapter.call_impl("get_ticket_details", ticket_id=123)
```

Or use dedicated helper functions:

```python
from app.cw_tools.cw_tools_main import get_ticket_details_for_api

# Call the helper function directly
result = get_ticket_details_for_api(ticket_id=123)
```

## Adding New Tools

To add a new tool:

1. Add the implementation function in `cw_tools_main.py`:

```python
def new_tool_impl(param1: str, param2: int) -> NewToolResult:
    """Core logic for the new tool."""
    # Implementation code...
```

2. Add the decorated tool in `cw_tools_main.py`:

```python
@function_tool()
def new_tool(param1: str, param2: int) -> NewToolResult:
    """Description of what the tool does."""
    logger.info(f"Tool 'new_tool' called with params: {param1}, {param2}")
    return new_tool_impl(param1=param1, param2=param2)
```

3. Add the mapping in `tool_adapter.py`:

```python
impl_map: Dict[str, Callable[..., Any]] = {
    # Existing mappings...
    "new_tool": new_tool_impl,
}
```

4. If needed, add a helper function for API routes:

```python
def new_tool_for_api(param1: str, param2: int) -> Dict[str, Any]:
    """Helper function for API routes."""
    result = new_tool_impl(param1=param1, param2=param2)
    if hasattr(result, "dict"):
        return result.dict()
    return dict(result)
```

## Best Practices

1. Keep the core logic in the implementation functions
2. Use descriptive names for functions and parameters
3. Add comprehensive docstrings
4. Handle errors gracefully
5. Log important information
6. Use type hints for better IDE support
7. Write tests for the implementation functions
</file>

<file path="cw_tools/tool_adapter.py">
"""
Tool adapter module to handle the OpenAI Agents SDK function_tool decorator.

This module provides a way to access both the decorated tools (for the agent)
and the implementation functions (for the API routes) in a unified way.
"""

import logging
from typing import Any, Dict, Callable, TypeVar, Optional

# Import the FunctionTool type for proper handling
try:
    from agents.tool import FunctionTool  # type: ignore
    _HAS_FUNCTION_TOOL = True
except ImportError:
    _HAS_FUNCTION_TOOL = False
    logging.warning("Could not import FunctionTool from agents.tool. Tool adapter will use fallback methods.")

# Import all the implementation functions
from .cw_tools_main import (
    # Ticket operations
    get_ticket_details_impl,
    create_new_ticket_impl,
    change_ticket_status_impl,
    update_ticket_summary_impl,
    update_ticket_priority_impl,
    update_ticket_contact_impl,
    update_ticket_owner_impl,
    update_ticket_type_impl,
    update_ticket_subtype_impl,
    update_ticket_item_impl,
    close_ticket_impl,
    add_ticket_note_impl,
    add_time_entry_impl,

    # Search operations
    find_company_impl,
    find_contact_impl,
    _find_member_details_sync,

    # Metadata operations
    list_service_boards_impl,
    list_ticket_statuses_impl,
    list_ticket_priorities_impl,
    get_ticket_statuses_impl,
    get_ticket_priorities_impl,
    get_board_types_impl,
    get_type_subtypes_impl,
    get_subtype_items_impl,
    list_work_types_impl,
    list_work_roles_impl,
    list_locations_impl,

    # Resource management
    assign_resource_to_ticket_impl,
    remove_resource_from_ticket_impl,

    # Contact management
    create_contact_impl,

    # Ticket management
    move_ticket_to_board_impl,
    get_ticket_attachments_impl,

    # Models
    ChangeStatusResult,
)

# Import all the decorated tools
from .cw_tools_main import (
    # Ticket operations
    get_ticket_details,
    create_new_ticket,
    change_ticket_status,
    update_ticket_summary,
    update_ticket_priority,
    update_ticket_contact,
    update_ticket_owner,
    update_ticket_type,
    update_ticket_subtype,
    update_ticket_item,
    close_ticket,
    add_ticket_note,
    add_time_entry,
    get_ticket_statuses,
    get_ticket_priorities,

    # Search operations
    find_company,
    find_contact,
    find_member,

    # Metadata operations
    list_service_boards,
    list_ticket_statuses,
    list_ticket_priorities,
    get_board_types,
    get_type_subtypes,
    get_subtype_items,
    list_work_types,
    list_work_roles,
    list_locations,

    # Resource management
    assign_resource_to_ticket,
    remove_resource_from_ticket,

    # Contact management
    create_contact,

    # Ticket management
    move_ticket_to_board,
    get_ticket_attachments
)

logger = logging.getLogger(__name__)

# Type variable for function return types
T = TypeVar('T')

class ToolAdapter:
    """
    Adapter class that provides access to both the decorated tools and the implementation functions.

    This allows the API routes to call the implementation functions directly,
    while the agent can use the decorated tools.
    """

    @staticmethod
    def get_tool_function(tool: Any) -> Optional[Callable[..., Any]]:
        """
        Extract the actual function from a FunctionTool object.

        This is needed because the @function_tool decorator wraps the original function
        in a FunctionTool object, which is not directly callable.

        Args:
            tool: A FunctionTool object or a regular function

        Returns:
            The underlying function if tool is a FunctionTool, otherwise the tool itself
        """
        if _HAS_FUNCTION_TOOL and isinstance(tool, FunctionTool):
            # Access the on_invoke_tool method which contains the original function
            return tool.on_invoke_tool
        return tool

    @staticmethod
    def get_all_tools() -> Dict[str, Any]:
        """
        Get all available tools with their names.

        Returns:
            A dictionary mapping tool names to tool functions
        """
        return {
            # Ticket operations
            "get_ticket_details": get_ticket_details,
            "create_new_ticket": create_new_ticket,
            "change_ticket_status": change_ticket_status,
            "update_ticket_summary": update_ticket_summary,
            "update_ticket_priority": update_ticket_priority,
            "update_ticket_contact": update_ticket_contact,
            "update_ticket_owner": update_ticket_owner,
            "update_ticket_type": update_ticket_type,
            "update_ticket_subtype": update_ticket_subtype,
            "update_ticket_item": update_ticket_item,
            "close_ticket": close_ticket,
            "add_ticket_note": add_ticket_note,
            "add_time_entry": add_time_entry,
            "get_ticket_statuses": get_ticket_statuses,
            "get_ticket_priorities": get_ticket_priorities,

            # Search operations
            "find_company": find_company,
            "find_contact": find_contact,
            "find_member": find_member,

            # Metadata operations
            "list_service_boards": list_service_boards,
            "list_ticket_statuses": list_ticket_statuses,
            "list_ticket_priorities": list_ticket_priorities,
            "get_board_types": get_board_types,
            "get_type_subtypes": get_type_subtypes,
            "get_subtype_items": get_subtype_items,
            "list_work_types": list_work_types,
            "list_work_roles": list_work_roles,
            "list_locations": list_locations,

            # Resource management
            "assign_resource_to_ticket": assign_resource_to_ticket,
            "remove_resource_from_ticket": remove_resource_from_ticket,

            # Contact management
            "create_contact": create_contact,

            # Ticket management
            "move_ticket_to_board": move_ticket_to_board,
            "get_ticket_attachments": get_ticket_attachments,
        }

    @staticmethod
    def call_impl(func_name: str, *args: Any, **kwargs: Any) -> Any:
        """
        Call the implementation function directly.

        Args:
            func_name: The name of the function to call
            *args: Positional arguments to pass to the function
            **kwargs: Keyword arguments to pass to the function

        Returns:
            The result of the function call
        """
        # Map function names to their implementation functions
        impl_map: Dict[str, Callable[..., Any]] = {
            # Ticket operations
            "get_ticket_details": get_ticket_details_impl,
            "create_new_ticket": create_new_ticket_impl,
            "change_ticket_status": change_ticket_status_impl,
            "change_ticket_status_impl": change_ticket_status_impl,  # Direct access for API
            "update_ticket_summary": update_ticket_summary_impl,
            "update_ticket_priority": update_ticket_priority_impl,
            "update_ticket_contact": update_ticket_contact_impl,
            "update_ticket_owner": update_ticket_owner_impl,
            "update_ticket_type": update_ticket_type_impl,
            "update_ticket_subtype": update_ticket_subtype_impl,
            "update_ticket_item": update_ticket_item_impl,
            "close_ticket": close_ticket_impl,
            "add_ticket_note": add_ticket_note_impl,
            "add_time_entry": add_time_entry_impl,

            # Search operations
            "find_company": find_company_impl,
            "find_contact": find_contact_impl,
            "find_member": _find_member_details_sync,

            # Metadata operations
            "list_service_boards": list_service_boards_impl,
            "list_ticket_statuses": list_ticket_statuses_impl,
            "list_ticket_priorities": list_ticket_priorities_impl,
            "get_ticket_statuses": get_ticket_statuses_impl,
            "get_ticket_priorities": get_ticket_priorities_impl,
            "get_board_types": get_board_types_impl,
            "get_type_subtypes": get_type_subtypes_impl,
            "get_subtype_items": get_subtype_items_impl,
            "list_work_types": list_work_types_impl,
            "list_work_roles": list_work_roles_impl,
            "list_locations": list_locations_impl,

            # Resource management
            "assign_resource_to_ticket": assign_resource_to_ticket_impl,
            "remove_resource_from_ticket": remove_resource_from_ticket_impl,

            # Contact management
            "create_contact": create_contact_impl,

            # Ticket management
            "move_ticket_to_board": move_ticket_to_board_impl,
            "get_ticket_attachments": get_ticket_attachments_impl,
        }

        if func_name not in impl_map:
            logger.error(f"Function {func_name} not found in implementation map")
            raise ValueError(f"Function {func_name} not found")

        logger.info(f"Calling implementation function {func_name}")

        # Special case for change_ticket_status which can accept either status_id or new_status_name
        if func_name == "change_ticket_status":
            # If status_id is provided directly, use it
            if "status_id" in kwargs:
                # Just pass through to the implementation function
                ticket_id = kwargs.get('ticket_id')
                status_id = kwargs.get('status_id')

                # Validate parameters
                if ticket_id is None or not isinstance(ticket_id, int):
                    return ChangeStatusResult(success=False, message="Invalid or missing ticket_id parameter")

                if status_id is None or not isinstance(status_id, int):
                    return ChangeStatusResult(success=False, message="Invalid or missing status_id parameter")

                return change_ticket_status_impl(ticket_id=int(ticket_id), status_id=int(status_id))

            # Otherwise, handle the case with new_status_name
            if "new_status_name" in kwargs:
                # Extract the parameters we need
                ticket_id = kwargs.get('ticket_id')
                new_status_name = kwargs.get('new_status_name')
                service_board_id = kwargs.get('service_board_id')

                # Validate parameters
                if ticket_id is None or not isinstance(ticket_id, int):
                    return ChangeStatusResult(success=False, message="Invalid or missing ticket_id parameter")

                if new_status_name is None or not isinstance(new_status_name, str):
                    return ChangeStatusResult(success=False, message="Invalid or missing new_status_name parameter")

                # First, we need to determine the board ID if not provided
                if service_board_id is None:
                    logger.info(f"Determining board ID for ticket {ticket_id}")
                    try:
                        # Get ticket details to extract board_id
                        ticket_details = get_ticket_details_impl(ticket_id)
                        if not ticket_details.success:
                            return ticket_details
                        service_board_id = ticket_details.board_id
                        if not service_board_id:
                            return ChangeStatusResult(success=False, message=f"Could not determine board ID for ticket {ticket_id}.")
                        logger.info(f"Determined board ID {service_board_id} for ticket {ticket_id}")
                    except Exception as e:
                        logger.error(f"Error determining board ID: {e}")
                        return ChangeStatusResult(success=False, message=f"Error determining board ID: {str(e)}")

                # Validate service_board_id
                if not isinstance(service_board_id, int) or service_board_id <= 0:
                    return ChangeStatusResult(success=False, message=f"Invalid board ID: {service_board_id}")

                # Now fetch the statuses for this board
                statuses_result = list_ticket_statuses_impl(service_board_id)
                if not statuses_result.success:
                    return statuses_result

                # Validate statuses
                if not statuses_result.statuses or len(statuses_result.statuses) == 0:
                    return ChangeStatusResult(success=False, message=f"No statuses found for board {service_board_id}")

                # Find the matching status
                status_obj = None
                for status in statuses_result.statuses:
                    if not hasattr(status, 'name') or not status.name:
                        continue

                    # Try exact case-insensitive match
                    if status.name.lower() == new_status_name.lower():
                        status_obj = status
                        logger.info(f"Found exact case-insensitive match: '{status.name}' matches '{new_status_name}'")
                        break

                # If no match, try without asterisks
                if not status_obj:
                    clean_status_name = new_status_name.replace('*', '').strip()
                    for status in statuses_result.statuses:
                        if not hasattr(status, 'name') or not status.name:
                            continue

                        clean_status = status.name.replace('*', '').strip()
                        if clean_status.lower() == clean_status_name.lower():
                            status_obj = status
                            logger.info(f"Found match after removing asterisks: '{status.name}' matches '{clean_status_name}'")
                            break

                # If no matching status found, return error
                if not status_obj:
                    # Create a safe list of status names
                    status_names = []
                    for s in statuses_result.statuses:
                        if hasattr(s, 'name') and s.name:
                            status_names.append(s.name)

                    return ChangeStatusResult(
                        success=False,
                        message=f"Status '{new_status_name}' not found on Board {service_board_id}. Available statuses: {', '.join(status_names)}"
                    )

                # Validate status_obj has an id
                if not hasattr(status_obj, 'id') or status_obj.id is None:
                    return ChangeStatusResult(success=False, message=f"Found status '{new_status_name}' but it has no ID.")

                # Call the implementation with the status ID
                status_id = int(status_obj.id)  # Ensure it's an int
                logger.info(f"Calling change_ticket_status_impl with ticket_id={ticket_id}, status_id={status_id}")
                return change_ticket_status_impl(ticket_id=ticket_id, status_id=status_id)

        return impl_map[func_name](*args, **kwargs)

# Create a singleton instance of the adapter
tool_adapter = ToolAdapter()

# Export all the decorated tools for the agent
__all__ = [
    # Adapter
    "tool_adapter",

    # Ticket operations
    "get_ticket_details",
    "create_new_ticket",
    "change_ticket_status",
    "update_ticket_summary",
    "update_ticket_priority",
    "update_ticket_contact",
    "update_ticket_owner",
    "update_ticket_type",
    "update_ticket_subtype",
    "update_ticket_item",
    "close_ticket",
    "add_ticket_note",
    "add_time_entry",
    "get_ticket_statuses",
    "get_ticket_priorities",

    # Search operations
    "find_company",
    "find_contact",
    "find_member",

    # Metadata operations
    "list_service_boards",
    "list_ticket_statuses",
    "list_ticket_priorities",
    "get_board_types",
    "get_type_subtypes",
    "get_subtype_items",
    "list_work_types",
    "list_work_roles",
    "list_locations",

    # Resource management
    "assign_resource_to_ticket",
    "remove_resource_from_ticket",

    # Contact management
    "create_contact",

    # Ticket management
    "move_ticket_to_board",
    "get_ticket_attachments",
]
</file>

<file path="experimental/api_updated.py">
"""
Updated API routes with chat enhancements.

This file contains the updated API routes that use the chat enhancements.
To use these routes, replace the existing routes in app/routes/api.py with the ones in this file.
"""

# Import the chat enhancements
from app.chat_enhancements import enhance_message_context

# Update the chat_stream function to use the chat enhancements
@router.get("/agent/chat")
async def chat_stream(
    request: Request,
    prompt: str = Query(..., description="The user's message/prompt for the agent."),
    ticket_id: Optional[int] = Query(None, description="Optional: Ticket ID for context-specific requests."),
    request_type: Optional[str] = Query(None, description="Optional: Specific request type (e.g., 'summary', 'customer_response')."),
    context_type: str = Query("general", description="Context type (ticket, company, general)"),
    active_tab: Optional[str] = Query(None, description="Active tab in the UI"),
    # Use the helper dependency to get user/auth context
    auth_context: Dict[str, Any] = Depends(get_user_context) # Auth handled by dependency
):
    """
    Endpoint for streaming chat responses via Server-Sent Events (SSE).
    Client connects via EventSource. Authentication is handled via Bearer token.
    """
    # Get the singleton agent instance using the refactored function
    cw_agent = agent_module.get_connectwise_agent()
    if not cw_agent or not _HAS_AGENT_SDK or Runner is None:
        raise HTTPException(status_code=503, detail="Agent service or SDK is unavailable.")

    # Create the ToolContext needed by some tools
    # Instantiate CwMemberInfo if details are present
    member_info_dict = auth_context.get("cw_member_info")
    cw_member_info_model = CwMemberInfo(**member_info_dict) if member_info_dict else None
    tool_context = ToolContext(cw_member_info=cw_member_info_model)

    # Enrich context with UI state information
    ui_state = {
        "current_view": context_type,
        "entity_id": ticket_id,
        "active_tab": active_tab
    }

    # Add to tool_context if it has ui_state attribute
    if hasattr(tool_context, "ui_state"):
        # If ToolContext has ui_state attribute, set it directly
        # If ToolContext has ui_state attribute, set it directly using keyword arguments
        # Explicitly type variables before passing to UIState constructor
        current_view_raw = ui_state.get("current_view")
        current_view_val: Optional[str] = str(current_view_raw) if current_view_raw is not None else None # Ensure str | None
        entity_id_val = ui_state.get("entity_id") # Type is int | None
        active_tab_raw = ui_state.get("active_tab")
        active_tab_val: Optional[str] = str(active_tab_raw) if active_tab_raw is not None else None # Ensure str | None

        # Convert entity_id to str | None if needed by model (though model allows int | str | None)
        entity_id_processed: Optional[Union[int, str]] = entity_id_val # Match model type

        tool_context.ui_state = UIState(
            current_view=current_view_val, # Pass explicitly typed variable
            entity_id=entity_id_processed, # Pass explicitly typed variable
            active_tab=active_tab_val      # Pass explicitly typed variable
        )
    else:
        # Otherwise add it as a context variable
        logger.info("Adding UI state information to agent context")

    # Define an async generator to yield events from the agent's run
    async def event_generator():
        final_prompt = prompt # Default to the raw user prompt
        prompt_source = "Raw User Input"

        # --- Ticket-Specific Prompt Generation ---
        if ticket_id and request_type:
            logger.info(f"Ticket-specific request detected: ticket_id={ticket_id}, request_type='{request_type}'")
            # 1. Fetch ticket details
            details_result = cw.get_ticket_details(ticket_id=ticket_id) # Assumes this returns a dict-like object or Pydantic model
            if not details_result.success:
                 logger.error(f"Failed to get details for ticket {ticket_id} to process request '{request_type}'. Error: {details_result.message}")
                 yield {"event": "error", "data": json.dumps({"error": f"Could not fetch details for ticket {ticket_id}: {details_result.message}"})}
                 yield {"event": "end_stream", "data": json.dumps({"message": "Stream ended due to error"})}
                 return # Stop generation

            # Convert Pydantic model to dict if necessary for process_ticket_request
            ticket_details_dict = details_result.dict() if hasattr(details_result, 'dict') else details_result

            # 2. Generate specialized prompt
            prompt_gen_result = agent_module.process_ticket_request(
                agent_instance=cw_agent, # Pass agent instance (needed by function signature)
                ticket_id=ticket_id,
                ticket_details=ticket_details_dict,
                request_type=request_type,
                custom_prompt=prompt # Pass original prompt as potential custom context
            )

            if prompt_gen_result.get("success") and prompt_gen_result.get("generated_prompt"):
                final_prompt = prompt_gen_result["generated_prompt"]
                prompt_source = f"Generated for Ticket {ticket_id} ({request_type})"
                logger.info(f"Using specialized prompt generated by process_ticket_request for type '{request_type}'.")
            else:
                 logger.warning(f"Failed to generate specialized prompt via process_ticket_request for type '{request_type}'. Falling back to raw prompt. Reason: {prompt_gen_result.get('message')}")
                 # Keep final_prompt as the original user prompt

        # --- Enhance the prompt with chat enhancements ---
        # Create context dictionary for chat enhancements
        context_dict = {
            "selected_ticket_id": ticket_id,
            "cw_member_info": member_info_dict
        }
        
        # Enhance the prompt with context
        enhanced_prompt = enhance_message_context(final_prompt, context_dict)
        
        # Use the enhanced prompt instead of the original prompt
        final_prompt = enhanced_prompt
        prompt_source = f"{prompt_source} with Enhanced Context"
        logger.info(f"Using enhanced prompt with context and entity references.")

        # --- Continue with Agent Execution ---
        logger.info(f"Running agent with prompt (Source: {prompt_source}): '{final_prompt[:150]}...'")
        # Yield user prompt back to client (optional - maybe yield the original prompt?)
        yield {"event": "user_message", "data": json.dumps({"text": prompt})} # Show original prompt in UI

        # For testing/development: just send a static response if agent is not available
        if not config.OPENAI_API_KEY:
            logger.warning("OpenAI API key not configured. Sending test response.")
            yield {"event": "assistant_token", "data": "Hello! "}
            yield {"event": "assistant_token", "data": "I'm the "}
            yield {"event": "assistant_token", "data": "ConnectWise AI "}
            yield {"event": "assistant_token", "data": "Assistant. "}
            yield {"event": "assistant_token", "data": "How can I "}
            yield {"event": "assistant_token", "data": "help you today?"}
            yield {"event": "end_stream", "data": json.dumps({"message": "Stream ended"})}
            return

        # Instantiate the SDK Runner
        runner = Runner() # Add tracer=... here if needed

        token = None # Initialize token for finally block
        try:
            # Set the context variable for this agent run
            logger.debug(f"Setting current_tool_context with member_info: {tool_context.cw_member_info}")
            token = current_tool_context.set(tool_context)

            # Run the agent using the SDK's runner
            # The 'context' argument to runner.run might still be useful for other SDK features,
            # but our tools will now rely on the contextvar.
            # Use the final_prompt (which might be specialized or the original)
            result = await runner.run(cw_agent, final_prompt, context=tool_context)

            # --- Streaming Logic Adaptation ---
            # Log the result structure to understand how to stream steps
            logger.info(f"Agent run completed. Result type: {type(result)}, Result: {result!r}")

            # --- Simplified Streaming Logic ---
            # Extract final_output from the RunResult object
            final_output_text = None
            if result and hasattr(result, 'final_output'):
                final_output_text = result.final_output

            if final_output_text:
                 logger.info("Sending final agent output.")
                 # Send the complete final output as a single message event
                 yield {"event": "assistant_message", "data": json.dumps({"text": final_output_text})}
            else:
                 logger.warning("Agent run completed but produced no final output text.")
                 yield {"event": "assistant_message", "data": json.dumps({"text": "[Agent produced no output]"})}
            # TODO: Revisit streaming intermediate steps (tokens, tool calls) later if needed,
            # potentially by inspecting result.new_items or using SDK callbacks if available.

            # Check for disconnection *after* the run completes (for this simple approach)
            if await request.is_disconnected():
                 logger.warning("Client disconnected after agent run completed.")

        except Exception as e:
            logger.exception(f"Error during agent run: {e}")
            yield {"event": "error", "data": json.dumps({"error": f"Error processing request: {str(e)}"})}
        finally:
            # Reset the context variable if it was set
            if token is not None:
                current_tool_context.reset(token)
                logger.debug("Reset current_tool_context after agent run")

            # Signal the end of the stream
            yield {"event": "end_stream", "data": json.dumps({"message": "Stream ended"})}

    # Return the SSE response with the event generator
    return EventSourceResponse(event_generator())
</file>

<file path="experimental/chat_enhancements.py">
"""
Chat Enhancements Module

This module provides functions to enhance the chat experience with dynamic entity references
and improved context awareness.
"""

import logging
import re
from typing import Dict, Any, Optional, List, Tuple

from app.context_enhancement import create_enhanced_context
from app.cw_tools.tool_adapter import tool_adapter

logger = logging.getLogger(__name__)

# Regular expressions for entity references
TICKET_PATTERN = re.compile(r'@ticket(?:[ -]?(\d+))?', re.IGNORECASE)
COMPANY_PATTERN = re.compile(r'@company(?:[ -]?([a-zA-Z0-9 ]+))?', re.IGNORECASE)
CONTACT_PATTERN = re.compile(r'@contact(?:[ -]?([a-zA-Z0-9 ]+))?', re.IGNORECASE)
MEMBER_PATTERN = re.compile(r'@member(?:[ -]?([a-zA-Z0-9 ]+))?', re.IGNORECASE)

def process_entity_references(message: str) -> Tuple[str, Dict[str, Any]]:
    """
    Process entity references in the message and return the processed message
    along with the referenced entities.
    
    Args:
        message: The message to process
        
    Returns:
        A tuple containing the processed message and a dictionary of referenced entities
    """
    logger.info("Processing entity references in message")
    
    # Dictionary to store referenced entities
    referenced_entities = {
        "tickets": [],
        "companies": [],
        "contacts": [],
        "members": []
    }
    
    # Process ticket references
    ticket_matches = TICKET_PATTERN.findall(message)
    for ticket_id in ticket_matches:
        if ticket_id:
            try:
                ticket_id_int = int(ticket_id)
                # Get ticket details
                ticket_result = tool_adapter.call_impl("get_ticket_details", ticket_id=ticket_id_int)
                if ticket_result.success:
                    # Add ticket to referenced entities
                    referenced_entities["tickets"].append({
                        "id": ticket_id_int,
                        "summary": ticket_result.summary,
                        "status": ticket_result.status
                    })
                    # Replace reference with formatted text
                    message = message.replace(
                        f"@ticket{ticket_id}",
                        f"Ticket #{ticket_id} ({ticket_result.summary})"
                    )
            except ValueError:
                # Not a valid ticket ID, ignore
                pass
    
    # Process company references
    company_matches = COMPANY_PATTERN.findall(message)
    for company_name in company_matches:
        if company_name:
            # Get company details
            company_result = tool_adapter.call_impl("find_company", company_name=company_name)
            if company_result.success and company_result.found:
                # Add company to referenced entities
                referenced_entities["companies"].append({
                    "id": company_result.company.id,
                    "name": company_result.company.name
                })
                # Replace reference with formatted text
                message = message.replace(
                    f"@company{company_name}",
                    f"Company: {company_result.company.name}"
                )
    
    # Process contact references
    contact_matches = CONTACT_PATTERN.findall(message)
    for contact_name in contact_matches:
        if contact_name:
            # We need a company ID to find contacts, so we can't process these directly
            # Just add a placeholder for now
            pass
    
    # Process member references
    member_matches = MEMBER_PATTERN.findall(message)
    for member_identifier in member_matches:
        if member_identifier:
            # Get member details
            member_result = tool_adapter.call_impl("find_member", member_identifier=member_identifier)
            if member_result.success and member_result.found:
                # Add member to referenced entities
                referenced_entities["members"].append({
                    "id": member_result.member.id,
                    "name": member_result.member.name,
                    "identifier": member_result.member.identifier
                })
                # Replace reference with formatted text
                message = message.replace(
                    f"@member{member_identifier}",
                    f"Member: {member_result.member.name} ({member_result.member.identifier})"
                )
    
    return message, referenced_entities

def enhance_message_context(message: str, context: Dict[str, Any]) -> str:
    """
    Enhance the message with additional context.
    
    Args:
        message: The message to process
        context: The context information
        
    Returns:
        The enhanced message
    """
    logger.info("Enhancing message context")
    
    # Process entity references
    processed_message, referenced_entities = process_entity_references(message)
    
    # Create enhanced context
    ticket_id = context.get("selected_ticket_id")
    member_identifier = None
    if context.get("cw_member_info"):
        member_identifier = context["cw_member_info"].get("identifier")
    
    enhanced_context = create_enhanced_context(
        ticket_id=ticket_id,
        member_identifier=member_identifier
    )
    
    # Add enhanced context to the message
    if enhanced_context:
        # Format the enhanced context as a system message
        context_message = "\n\nAvailable Context:\n"
        
        # Add user context if available
        if "user_context" in enhanced_context:
            user_ctx = enhanced_context["user_context"]
            context_message += f"\nUser: {user_ctx.get('member_name', 'Unknown')} ({user_ctx.get('member_identifier', 'Unknown')})\n"
            
            # Add recent tickets if available
            if "recent_tickets" in user_ctx and user_ctx["recent_tickets"]:
                context_message += "\nRecent Tickets:\n"
                for ticket in user_ctx["recent_tickets"][:3]:  # Limit to 3 tickets
                    context_message += f"- #{ticket['ticket_id']}: {ticket['summary']} ({ticket['status']})\n"
        
        # Add ticket context if available
        if "ticket_context" in enhanced_context:
            ticket_ctx = enhanced_context["ticket_context"]
            context_message += f"\nCurrent Ticket: #{ticket_ctx.get('ticket_id')}\n"
            context_message += f"Summary: {ticket_ctx.get('summary', 'N/A')}\n"
            context_message += f"Status: {ticket_ctx.get('status', 'N/A')}\n"
            context_message += f"Company: {ticket_ctx.get('company_name', 'N/A')}\n"
            
            # Add type hierarchy if available
            if "type_hierarchy" in ticket_ctx:
                type_hierarchy = ticket_ctx["type_hierarchy"]
                if any(type_hierarchy.values()):
                    context_message += f"Type: {type_hierarchy.get('type', 'N/A')} > {type_hierarchy.get('subtype', 'N/A')} > {type_hierarchy.get('item', 'N/A')}\n"
        
        # Add referenced entities to the context
        if any(referenced_entities.values()):
            context_message += "\nReferenced Entities:\n"
            
            if referenced_entities["tickets"]:
                context_message += "Tickets:\n"
                for ticket in referenced_entities["tickets"]:
                    context_message += f"- #{ticket['id']}: {ticket['summary']} ({ticket['status']})\n"
            
            if referenced_entities["companies"]:
                context_message += "Companies:\n"
                for company in referenced_entities["companies"]:
                    context_message += f"- {company['name']} (ID: {company['id']})\n"
            
            if referenced_entities["members"]:
                context_message += "Members:\n"
                for member in referenced_entities["members"]:
                    context_message += f"- {member['name']} ({member['identifier']})\n"
        
        # Append the context to the message
        processed_message = processed_message + context_message
    
    return processed_message
</file>

<file path="experimental/README.md">
# Experimental Features

This directory contains experimental features that are not yet integrated into the main codebase.

## Files

### chat_enhancements.py

This file contains code for enhancing chat with entity references. It provides functionality to:

- Process entity references in messages (e.g., @ticket123, @company-name)
- Extract referenced entities and provide context for them
- Enhance the chat experience with improved context awareness

### api_updated.py

This file contains an updated version of the API routes that uses the chat enhancements. It's intended to replace the existing routes in `app/routes/api.py` once the chat enhancement functionality is ready for production.

## Integration

These features are planned for future integration into the main codebase. They were previously located in an accidental duplicate `app` folder in the project root, which has been removed.

When integrating these features:

1. Test thoroughly to ensure compatibility with the current codebase
2. Update imports to match the current project structure
3. Ensure proper error handling and edge case coverage
4. Add appropriate documentation and tests
</file>

<file path="main.py">
import uvicorn
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
# Removed duplicate import

import logging # Added import

# Import the API routers from the routes package
from app.routes import api
from app.routes import suggestions  # Import suggestions router
from app.routes import search  # Import search router
from app.routes import generate  # Import generate router
import app.config as config # Import config to potentially use settings

# Configure logging (can be more sophisticated)
logging.basicConfig(level=config.LOG_LEVEL)
logger = logging.getLogger(__name__)

# Create FastAPI app instance
app = FastAPI(
    # Comment removed, arguments follow directly

    title="ConnectWise AI Copilot API",
    version="1.0.0",
    description="API backend for the ConnectWise AI Copilot application, providing agent chat and ConnectWise integration endpoints."
    # Add other FastAPI configurations like docs_url, redoc_url if needed
)

# Configure CORS middleware
# Get allowed origins from config or use a default for development
# In production, this should be restricted to the actual frontend domain(s)
allowed_origins = [
    config.AZURE_AD_REDIRECT_URI or "http://localhost:5173", # Use config or default
    "http://localhost:5173",      # Explicitly allow default Vite dev port
    "http://127.0.0.1:5173",     # Also allow loopback IP
    "http://localhost:5174",      # Allow the new Vite dev port
    "http://127.0.0.1:5174",     # Also allow loopback IP for new port
    "http://localhost:5175",      # Allow additional Vite dev port
    "http://127.0.0.1:5175",     # Allow loopback IP for additional port
    "http://localhost:5176",      # Allow additional Vite dev port
    "http://127.0.0.1:5176",     # Allow loopback IP for additional port
    "http://localhost:8000",      # Allow backend port for potential local development
    "http://localhost:8001",      # Allow new backend port
    # Remove "*" wildcard when specifying explicit origins and allowing credentials
]
# Remove duplicates and potential None values
allowed_origins = list(set(filter(None, allowed_origins)))

logger.info(f"Configuring CORS for origins: {allowed_origins}")

app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins, # Use the specific list
    allow_credentials=True,   # Allow cookies/auth headers
    allow_methods=["*"],      # Allow all standard methods
    allow_headers=["*"],      # Allow all headers
    expose_headers=["Content-Length"],  # Expose necessary headers
    max_age=600  # Cache preflight requests for 10 minutes
)

# Include the API routers
# All routes defined in router files will be available under the app
app.include_router(api.router, prefix="/api/v1") # Main API endpoints
app.include_router(suggestions.router, prefix="/api/v1") # Suggestion endpoints
app.include_router(search.router, prefix="/api/v1") # Search endpoints
app.include_router(generate.router, prefix="/api/v1") # Generate endpoints

# Add a simple root endpoint for health check or basic info
@app.get("/", tags=["Root"])
async def read_root():
    return {"message": "Welcome to the ConnectWise AI Copilot API"}

# If running this module directly (e.g., python -m app.main), start Uvicorn server.
# This is useful for local development. The setup-dev.ps1 script uses uvicorn directly.
if __name__ == "__main__":
    logger.info("Starting Uvicorn server directly from main.py")
    # Use host="0.0.0.0" to be accessible on the network, port 8000 is the standard for this application
    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True, log_level=config.LOG_LEVEL.lower())
</file>

<file path="routes/__init__.py">
# This file makes the 'routes' directory a Python package.
</file>

<file path="routes/api.py">
from fastapi import APIRouter, Depends, HTTPException, Query, Request
# StreamingResponse removed as unused
from sse_starlette.sse import EventSourceResponse # type: ignore
import json
import logging
import math # Added for pagination calculation
from datetime import datetime, timezone, timedelta
from json import JSONEncoder


from pydantic import BaseModel # Removed unused Field
from typing import Optional, Dict, Any, List, Union, Literal # Removed unused cast, Type

# Custom JSON encoder to handle ResponseOutputText objects
class CustomJSONEncoder(JSONEncoder):
    def default(self, obj):
        # Check if the object has a __str__ method
        if hasattr(obj, '__str__'):
            return str(obj)
        # Let the base class default method raise the TypeError
        return JSONEncoder.default(self, obj)

# Import specific models from cw_tools for clarity
from app.cw_tools.models import TicketSummary, UIState
from pyconnectwise.exceptions import ConnectWiseException # type: ignore
# Define Runner with default type hint before try block
Runner: Any = None
# Define MaxTurnsExceeded with default type hint before try block
MaxTurnsExceeded: Any = None
# Import SDK components and refactored agent logic
try:
    from agents import Runner as _SdkRunner # type: ignore
    from agents.exceptions import MaxTurnsExceeded as _MaxTurnsExceeded # type: ignore
    Runner = _SdkRunner # Assign actual type if import succeeds
    MaxTurnsExceeded = _MaxTurnsExceeded # Assign actual type if import succeeds
    _HAS_AGENT_SDK = True
except ImportError:
    # Runner and MaxTurnsExceeded remain None if import fails
    _HAS_AGENT_SDK = False
    logging.critical("OpenAI Agents SDK ('agents' module) not found.")

import app.agent as agent_module # Contains get_connectwise_agent # noqa: E402
from app.cw_tools import ToolContext, CwMemberInfo # Import context and member info models # noqa: E402
import app.cw_tools as cw # noqa: E402
import app.config as config  # noqa: E402
from app.context import current_tool_context # Import the context variable # noqa: E402
from app.cw_tools.tool_adapter import tool_adapter  # noqa: E402

# Authentication dependency (Azure AD token verification)

# Import at the top of the file
from fastapi.security import OAuth2PasswordBearer
from fastapi import Security

# Create a dummy OAuth2 scheme that doesn't actually validate tokens
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token", auto_error=False)

# Check if development mode is enabled
if config.DEVELOPMENT_MODE:
    logging.info("Development mode enabled - authentication is disabled")
    AUTH_ENABLED = False
else:
    # In production, we use Azure AD authentication
    AUTH_ENABLED = True
    logging.info("Production mode - authentication is enabled")

# Define the auth scheme function
async def get_current_user(token: str = Security(oauth2_scheme)):
    # In development mode, always return a dummy user
    if config.DEVELOPMENT_MODE or not AUTH_ENABLED:
        return {"dummy_user": True, "name": "Development User", "email": "dev@example.com"}

    # In production mode, validate the token
    if not token:
        raise HTTPException(
            status_code=401,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"}
        )

    try:
        # Here we would validate the token with Azure AD
        # For now, we'll just check if it's a non-empty string
        if not token.strip():
            raise HTTPException(
                status_code=401,
                detail="Invalid authentication credentials",
                headers={"WWW-Authenticate": "Bearer"}
            )

        # In a real implementation, we would decode the token and extract user info
        # For now, we'll just return a dummy user
        return {"name": "Authenticated User", "email": "user@example.com"}
    except Exception as e:
        logger.error(f"Authentication error: {e}")
        raise HTTPException(
            status_code=401,
            detail="Authentication failed",
            headers={"WWW-Authenticate": "Bearer"}
        )

# Define logger for this module
logger = logging.getLogger(__name__)

# Add a constant for the maximum number of similar consecutive tool calls before warning
MAX_SIMILAR_TOOL_CALLS = 3

router = APIRouter()

# Pydantic models for request payloads

class TicketCreateRequest(BaseModel):
    summary: str
    company_name: str
    service_board_id: int
    contact_name: Optional[str] = None
    priority_id: Optional[int] = None
    details: Optional[str] = None

class TicketStatusUpdateRequest(BaseModel):
    status_id: int
    service_board_id: Optional[int] = None  # Kept for backward compatibility but no longer used

class NoteRequest(BaseModel):
    # Assuming member_identifier comes from the authenticated user context now
    # member_identifier: str  # user identifier (email/username of technician)
    note_text: str
    internal: bool
    resolution: bool
    note_type: Optional[str] = None  # "Discussion", "Internal", or "Resolution"

class TimeEntryRequest(BaseModel):
    # Assuming member_identifier comes from the authenticated user context now
    # member_identifier: str
    notes: str
    actual_hours: float # Made non-optional as per cw_tools usage
    billable_option: str   # "Billable", "DoNotBill", or "NoCharge"
    billable: Optional[bool] = None # Whether the time entry is billable
    time_start: Optional[str] = None # Keep optional
    time_end: Optional[str] = None # Optional end time
    work_type_id: Optional[int] = None # Work type ID
    work_role_id: Optional[int] = None # Work role ID
    location_id: Optional[int] = None # Location ID
    email_contact: Optional[bool] = None # Whether to email the contact
    email_resource: Optional[bool] = None # Whether to email the resource
    email_cc: Optional[bool] = None # Whether to email CCs
    new_status_id: Optional[int] = None # Status to set after adding time

class TicketSummaryUpdateRequest(BaseModel):
   summary: str

class TicketPriorityUpdateRequest(BaseModel):
    priority_id: int

class TicketContactUpdateRequest(BaseModel):
    contact_id: int


class TicketCompanyUpdateRequest(BaseModel):
    new_company_name: str

class TicketOwnerUpdateRequest(BaseModel):
    member_identifier: str


# --- Response Models ---

class PaginatedTicketsResult(BaseModel):
    success: bool
    tickets: List[TicketSummary] # Use the imported model
    total_found: int
    page: int
    total_pages: int
    has_next: bool
    has_previous: bool
    message: Optional[str] = None

# --- Request Schemas ---

# Helper to get user info (including CW member details) from token
async def get_user_context(user: Dict[str, Any] = Depends(get_current_user)) -> Dict[str, Any]:
    """
    Accepts the validated user token dictionary and returns the combined context with CW member details.
    """
    # Create a dummy member info for development
    dev_member_info = {
        "id": 1,
        "identifier": "dev",
        "name": "Development User",
        "email": "dev@example.com"
    }
    return {"user_info": user, "cw_member_info": dev_member_info}


# --- Chat Endpoint (Server-Sent Events) ---

@router.get("/agent/chat")
async def chat_stream(
    request: Request,
    prompt: str = Query(..., description="The user's message/prompt for the agent."),
    ticket_id: Optional[int] = Query(None, description="Optional: Ticket ID for context-specific requests."),
    request_type: Optional[str] = Query(None, description="Optional: Specific request type (e.g., 'summary', 'customer_response')."),
    context_type: str = Query("general", description="Context type (ticket, company, general)"),
    active_tab: Optional[str] = Query(None, description="Active tab in the UI"),
    # token: str = Query(None, description="Bearer token passed via URL for EventSource compatibility"), # Token should be in header now
    # Use the helper dependency to get user/auth context
    auth_context: Dict[str, Any] = Depends(get_user_context) # Auth handled by dependency
):
    """
    Endpoint for streaming chat responses via Server-Sent Events (SSE).
    Client connects via EventSource. Authentication is handled via Bearer token.
    """
    # Get the singleton agent instance using the refactored function
    cw_agent = agent_module.get_connectwise_agent()
    if not cw_agent or not _HAS_AGENT_SDK or Runner is None:
        raise HTTPException(status_code=503, detail="Agent service or SDK is unavailable.")

    # Create the ToolContext needed by some tools
    # Instantiate CwMemberInfo if details are present
    member_info_dict = auth_context.get("cw_member_info")
    cw_member_info_model = CwMemberInfo(**member_info_dict) if member_info_dict else None
    tool_context = ToolContext(cw_member_info=cw_member_info_model)

    # Enrich context with UI state information
    ui_state = {
        "current_view": context_type,
        "entity_id": ticket_id,
        "active_tab": active_tab
    }

    # Add to tool_context if it has ui_state attribute
    if hasattr(tool_context, "ui_state"):
        # If ToolContext has ui_state attribute, set it directly
        # If ToolContext has ui_state attribute, set it directly using keyword arguments
        # Explicitly type variables before passing to UIState constructor
        current_view_raw = ui_state.get("current_view")
        current_view_val: Optional[str] = str(current_view_raw) if current_view_raw is not None else None # Ensure str | None
        entity_id_val = ui_state.get("entity_id") # Type is int | None
        active_tab_raw = ui_state.get("active_tab")
        active_tab_val: Optional[str] = str(active_tab_raw) if active_tab_raw is not None else None # Ensure str | None

        # Convert entity_id to str | None if needed by model (though model allows int | str | None)
        entity_id_processed: Optional[Union[int, str]] = entity_id_val # Match model type

        tool_context.ui_state = UIState(
            current_view=current_view_val, # Pass explicitly typed variable
            entity_id=entity_id_processed, # Pass explicitly typed variable
            active_tab=active_tab_val      # Pass explicitly typed variable
        )
    else:
        # Otherwise add it as a context variable
        logger.info("Adding UI state information to agent context")

    # Define an async generator to yield events from the agent's run
    async def event_generator():
        final_prompt = prompt # Default to the raw user prompt
        prompt_source = "Raw User Input"

        # --- Ticket-Specific Prompt Generation ---
        if ticket_id and request_type:
            logger.info(f"Ticket-specific request detected: ticket_id={ticket_id}, request_type='{request_type}'")
            # 1. Fetch ticket details
            details_result = cw.get_ticket_details(ticket_id=ticket_id) # Assumes this returns a dict-like object or Pydantic model
            if not details_result.success:
                 logger.error(f"Failed to get details for ticket {ticket_id} to process request '{request_type}'. Error: {details_result.message}")
                 yield {"event": "error", "data": json.dumps({"error": f"Could not fetch details for ticket {ticket_id}: {details_result.message}"})}
                 yield {"event": "end_stream", "data": json.dumps({"message": "Stream ended due to error"})}
                 return # Stop generation

            # Convert Pydantic model to dict if necessary for process_ticket_request
            ticket_details_dict = details_result.dict() if hasattr(details_result, 'dict') else details_result

            # 2. Generate specialized prompt
            prompt_gen_result = agent_module.process_ticket_request(
                agent_instance=cw_agent, # Pass agent instance (needed by function signature)
                ticket_id=ticket_id,
                ticket_details=ticket_details_dict,
                request_type=request_type,
                custom_prompt=prompt # Pass original prompt as potential custom context
            )

            if prompt_gen_result.get("success") and prompt_gen_result.get("generated_prompt"):
                final_prompt = prompt_gen_result["generated_prompt"]
                prompt_source = f"Generated for Ticket {ticket_id} ({request_type})"
                logger.info(f"Using specialized prompt generated by process_ticket_request for type '{request_type}'.")
            else:
                 logger.warning(f"Failed to generate specialized prompt via process_ticket_request for type '{request_type}'. Falling back to raw prompt. Reason: {prompt_gen_result.get('message')}")
                 # Keep final_prompt as the original user prompt

        # --- Continue with Agent Execution ---
        logger.info(f"Running agent with prompt (Source: {prompt_source}): '{final_prompt[:150]}...'")
        # Yield user prompt back to client (optional - maybe yield the original prompt?)
        yield {"event": "user_message", "data": json.dumps({"text": prompt})} # Show original prompt in UI

        # For testing/development: just send a static response if agent is not available
        if not config.OPENAI_API_KEY:
            logger.warning("OpenAI API key not configured. Sending test response.")
            yield {"event": "assistant_token", "data": "Hello! "}
            yield {"event": "assistant_token", "data": "I'm the "}
            yield {"event": "assistant_token", "data": "ConnectWise AI "}
            yield {"event": "assistant_token", "data": "Assistant. "}
            yield {"event": "assistant_token", "data": "How can I "}
            yield {"event": "assistant_token", "data": "help you today?"}
            yield {"event": "end_stream", "data": json.dumps({"message": "Stream ended"})}
            return

        # Instantiate the SDK Runner
        runner = Runner() # Add tracer=... here if needed

        # Create a RunConfig with appropriate settings for the SDK version
        from agents import RunConfig

        # Define the max_turns parameter - increased from default to handle complex conversations
        MAX_TURNS = 20

        # Create the RunConfig with trace_metadata and max_turns
        try:
            # Try to create RunConfig with max_turns parameter
            run_config = RunConfig(
                trace_metadata={"prompt_source": prompt_source, "context_type": context_type},
                max_turns=MAX_TURNS
            )
            logger.info(f"Created RunConfig with max_turns={MAX_TURNS}")
        except TypeError:
            # Fall back to creating RunConfig without max_turns parameter
            run_config = RunConfig(
                trace_metadata={"prompt_source": prompt_source, "context_type": context_type}
            )

            # Try to set max_turns attribute directly
            if hasattr(run_config, 'max_turns'):
                run_config.max_turns = MAX_TURNS
                logger.info(f"Set max_turns={MAX_TURNS} on RunConfig after creation")
            else:
                logger.warning("max_turns attribute not available on RunConfig in this SDK version")

        token = None # Initialize token for finally block
        try:
            # Set the context variable for this agent run
            logger.debug(f"Setting current_tool_context with member_info: {tool_context.cw_member_info}")
            token = current_tool_context.set(tool_context)

            # Create a circuit breaker to detect repeated similar tool calls
            tool_call_history = []
            max_similar_calls = 3  # Maximum number of similar consecutive tool calls before warning

            # Run the agent using the SDK's runner
            # The 'context' argument to runner.run might still be useful for other SDK features,
            # but our tools will now rely on the contextvar.
            # Use the final_prompt (which might be specialized or the original)
            # Use run_streamed instead of run to monitor tool calls in real-time
            result_stream = runner.run_streamed(cw_agent, final_prompt, context=tool_context, run_config=run_config)

            # Initialize variables for circuit breaker pattern
            tool_call_history = []
            consecutive_similar_calls = 0
            max_similar_calls = MAX_SIMILAR_TOOL_CALLS
            last_tool_name = None
            last_tool_args = None
            circuit_broken = False

            # Initialize variables for loop detection
            tool_call_frequency = {}
            loop_detected = False
            loop_threshold = 5  # Number of times a tool can be called before considering it a potential loop

            # Process the stream events
            async for event in result_stream.stream_events():
                # Skip raw response events (token-by-token output)
                if event.type == "raw_response_event":
                    continue

                # Handle run item events (tool calls, tool outputs, messages)
                elif event.type == "run_item_stream_event":
                    item = event.item

                    # Monitor tool calls for the circuit breaker pattern
                    if item.type == "tool_call_item" and hasattr(item.raw_item, "function"):
                        tool_name = item.raw_item.function.name
                        tool_args = item.raw_item.function.arguments

                        # Update tool call frequency for loop detection
                        tool_call_frequency[tool_name] = tool_call_frequency.get(tool_name, 0) + 1

                        # Check if this is a similar consecutive call (exact same arguments)
                        if tool_name == last_tool_name and tool_args == last_tool_args:
                            consecutive_similar_calls += 1
                            logger.warning(f"Detected similar consecutive tool call: {tool_name} (count: {consecutive_similar_calls})")

                            # Break the circuit if too many similar calls
                            if consecutive_similar_calls >= max_similar_calls and not circuit_broken:
                                circuit_broken = True
                                logger.warning(f"Circuit breaker triggered after {consecutive_similar_calls} similar calls to {tool_name}")

                                # Send a warning message to the user
                                warning_message = (
                                    f"I notice I've been repeatedly calling the same tool ({tool_name}) without making progress. "
                                    f"Let me try a different approach to solve your request."
                                )
                                yield {"event": "assistant_message", "data": json.dumps({"text": warning_message})}
                        else:
                            # Reset counter for different tool calls
                            consecutive_similar_calls = 0

                        # Check for potential loops (same tool called many times, even with different args)
                        if tool_call_frequency[tool_name] >= loop_threshold and not loop_detected and not circuit_broken:
                            loop_detected = True
                            logger.warning(f"Potential loop detected: {tool_name} called {tool_call_frequency[tool_name]} times")

                            # Log all tool calls for debugging
                            logger.info(f"Tool call history: {tool_call_history}")

                            # Send a warning message to the user
                            loop_message = (
                                f"I seem to be making multiple attempts with the tool '{tool_name}' without resolving your request. "
                                f"This might be due to missing or incorrect information. Could you provide more specific details?"
                            )
                            yield {"event": "assistant_message", "data": json.dumps({"text": loop_message})}

                        # Update last tool call
                        last_tool_name = tool_name
                        last_tool_args = tool_args

                        # Add to history for debugging
                        tool_call_history.append({"name": tool_name, "args": tool_args})

                    # Handle message output items (final or intermediate responses)
                    elif item.type == "message_output_item" and hasattr(item, "raw_item") and hasattr(item.raw_item, "content"):
                        message_text = item.raw_item.content
                        if message_text:
                            # Use the custom JSON encoder to handle non-string objects
                            yield {"event": "assistant_message", "data": json.dumps({"text": message_text}, cls=CustomJSONEncoder)}

            # Get the final result after streaming is complete
            if result_stream.is_complete and hasattr(result_stream, "final_output"):
                final_output_text = result_stream.final_output
                if final_output_text and not circuit_broken:
                    logger.info("Sending final agent output.")
                    # Use the custom JSON encoder to handle non-string objects
                    yield {"event": "assistant_message", "data": json.dumps({"text": final_output_text}, cls=CustomJSONEncoder)}
            else:
                logger.warning("Agent run completed but produced no final output text.")
                if not circuit_broken:  # Only show this if we haven't already sent a circuit breaker message
                    yield {"event": "assistant_message", "data": json.dumps({"text": "[Agent produced no output]"}, cls=CustomJSONEncoder)}

            # Check for disconnection *after* the run completes (for this simple approach)
            if await request.is_disconnected():
                 logger.warning("Client disconnected after agent run completed.")

        except MaxTurnsExceeded as mte:
            logger.warning(f"MaxTurnsExceeded error during agent execution: {mte}")

            # Log tool call history for debugging
            logger.info(f"Tool call history before MaxTurnsExceeded: {tool_call_history}")

            # Analyze the tool call history to provide more specific guidance
            tool_frequency = {}
            for call in tool_call_history:
                tool_name = call.get('name')
                if tool_name:
                    tool_frequency[tool_name] = tool_frequency.get(tool_name, 0) + 1

            # Find the most frequently called tool
            most_frequent_tool = None
            max_count = 0
            for tool, count in tool_frequency.items():
                if count > max_count:
                    max_count = count
                    most_frequent_tool = tool

            # Customize the error message based on the tool call pattern
            if most_frequent_tool and max_count > 3:
                error_message = (
                    f"I've reached the maximum number of steps allowed for this conversation. "
                    f"I notice I've been using the '{most_frequent_tool}' tool frequently without resolving your request. "
                    f"This might be due to missing or incorrect information. Could you provide more specific details "
                    f"or try rephrasing your request with clearer instructions?"
                )
            else:
                error_message = (
                    "I've reached the maximum number of steps allowed for this conversation. "
                    "This usually happens when I'm having trouble completing a task or when there's ambiguity in the request. "
                    "Please try rephrasing your question or breaking it down into smaller, more specific requests."
                )

            yield {"event": "assistant_message", "data": json.dumps({"text": error_message})}
            yield {"event": "error", "data": json.dumps({"error": "Maximum conversation turns exceeded", "error_type": "MaxTurnsExceeded"})}
        except MaxTurnsExceeded as mte:
            logger.warning(f"MaxTurnsExceeded: {mte}")
            error_message = "I've reached the maximum number of steps I can take for this conversation. Let's start a new approach or break this down into smaller questions."
            yield {"event": "assistant_message", "data": json.dumps({"text": error_message})}
            yield {"event": "error", "data": json.dumps({"error": "Maximum conversation turns exceeded", "error_type": "MaxTurnsExceeded"})}
        except Exception as e:
            logger.exception(f"Error during agent execution or streaming: {e}")
            # Send a more detailed error event to the client
            error_message = "An error occurred processing your request."
            error_type = type(e).__name__

            # Provide more specific error messages based on error type
            if "ConnectWise" in error_type:
                error_message = "There was an issue connecting to ConnectWise. Please try again later."
            elif "Authentication" in error_type or "Auth" in error_type:
                error_message = "There was an authentication issue. Please try logging out and back in."
            elif "Timeout" in error_type:
                error_message = "The request timed out. Please try again with a simpler query."

            yield {"event": "error", "data": json.dumps({"error": error_message, "error_type": error_type})}
        finally:
            # Reset the context variable after the run completes or fails
            if token:
                logger.debug("Resetting current_tool_context")
                current_tool_context.reset(token)
            # Always signal the end of the stream
            logger.info("Stream ended for prompt.")
            yield {"event": "end_stream", "data": json.dumps({"message": "Stream ended"})}

    return EventSourceResponse(event_generator())

# --- Ticket and Tool Endpoints (RESTful) ---
# Apply the user context dependency to all protected routes

@router.get("/ticket/{ticket_id}/details") # Path already updated
async def get_ticket_details_endpoint(ticket_id: int, context: Dict[str, Any] = Depends(get_user_context)): # Renamed function for clarity
    """Fetch detailed ticket info by ID."""
    # Directly call the tool function which returns a Pydantic model
    # Call the undecorated logic function directly
    # Call the actual logic function, not the FunctionTool wrapper
    # Revert to calling the decorated tool function directly via the cw alias
    # Call the new, separate, undecorated function specifically for the API
    # Call the decorated tool function directly via the cw alias
    # Use the dedicated API helper function
    try:
        # Import the function here to avoid circular imports
        from app.cw_tools.cw_tools_main import get_ticket_details_for_api

        result = get_ticket_details_for_api(ticket_id=ticket_id)

        # Check success from the dict result
        if not result.get("success", False):
            status_code = result.get("status_code", 500)
            raise HTTPException(status_code=status_code, detail=result.get("message", "Unknown error fetching ticket details"))

        return result

    except Exception as e:
        logger.exception(f"Error invoking get_ticket_details tool via on_invoke_tool: {e}")
        raise HTTPException(status_code=500, detail="Internal server error processing ticket details request.")

@router.post("/ticket", status_code=201)
async def create_ticket(data: TicketCreateRequest, context: Dict[str, Any] = Depends(get_user_context)):
    """Create a new ticket with the given details."""
    # Note: create_new_ticket tool doesn't require member context currently
    # Call the implementation function directly
    result = tool_adapter.call_impl(
        "create_new_ticket",
        summary=data.summary,
        company_name=data.company_name,
        service_board_id=data.service_board_id,
        contact_name=data.contact_name,
        priority_id=data.priority_id,
        details=data.details
    )
    if not result.get("success"):
        status_code = 400 if result.get("error_type") == "ValueError" else (result.get("status_code", 500) if result.get("error_type") == "APIError" else 500)
        raise HTTPException(status_code=status_code, detail=result.get("message", "Failed to create ticket"))
    return result

@router.put("/ticket/{ticket_id}/status")
async def update_ticket_status(ticket_id: int, data: TicketStatusUpdateRequest, context: Dict[str, Any] = Depends(get_user_context)):
    """Change the status of a ticket."""
    # Note: change_ticket_status tool doesn't require member context currently
    # Call the implementation function directly
    logger.info(f"DEBUG: Updating ticket {ticket_id} status to ID {data.status_id}")
    try:
        # Call the implementation function directly with status_id
        result = tool_adapter.call_impl(
            "change_ticket_status",  # Use the standard function name
            ticket_id=ticket_id,
            status_id=data.status_id
        )
        logger.info(f"DEBUG: Result: {result}")
        # Check if result is a dictionary or a Pydantic model
        if hasattr(result, 'dict'):
            # Convert Pydantic model to dict
            result_dict = result.dict()
        elif isinstance(result, dict):
            result_dict = result
        else:
            # Handle other types (like Pydantic models with no dict method)
            if hasattr(result, 'success') and not result.success:
                status_code = 400
                if hasattr(result, 'error_type'):
                    if result.error_type == "ValueError":
                        status_code = 400
                    elif result.error_type == "APIError" and hasattr(result, 'status_code'):
                        status_code = result.status_code
                error_message = getattr(result, 'message', "Failed to update status")
                logger.error(f"Status update failed: {error_message}")
                raise HTTPException(status_code=status_code, detail=error_message)
            return result

        if not result_dict.get("success"):
            status_code = 400 if result_dict.get("error_type") == "ValueError" else (result_dict.get("status_code", 500) if result_dict.get("error_type") == "APIError" else 500)
            error_message = result_dict.get("message", "Failed to update status")
            logger.error(f"Status update failed: {error_message}")
            raise HTTPException(status_code=status_code, detail=error_message)
        return result
    except Exception as e:
        logger.exception(f"Exception in update_ticket_status: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.put("/ticket/{ticket_id}/summary")
async def update_ticket_summary_endpoint(ticket_id: int, data: TicketSummaryUpdateRequest, context: Dict[str, Any] = Depends(get_user_context)):
   """Update the summary of a ticket."""
   # Call the implementation function directly
   result = tool_adapter.call_impl("update_ticket_summary", ticket_id=ticket_id, new_summary=data.summary)
   if not result.success:
       status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
       raise HTTPException(status_code=status_code, detail=result.message or "Failed to update summary")
   return result

@router.put("/ticket/{ticket_id}/priority")
async def update_ticket_priority_endpoint(ticket_id: int, data: TicketPriorityUpdateRequest, context: Dict[str, Any] = Depends(get_user_context)):
   """Update the priority of a ticket."""
   # Call the implementation function directly
   result = tool_adapter.call_impl("update_ticket_priority", ticket_id=ticket_id, priority_id=data.priority_id)
   if not result.success:
       status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
       raise HTTPException(status_code=status_code, detail=result.message or "Failed to update priority")
   return result

@router.put("/ticket/{ticket_id}/contact")
async def update_ticket_contact_endpoint(ticket_id: int, data: TicketContactUpdateRequest, context: Dict[str, Any] = Depends(get_user_context)):
  """Update the primary contact of a ticket."""
  # Call the implementation function directly
  result = tool_adapter.call_impl("update_ticket_contact", ticket_id=ticket_id, new_contact_id=data.contact_id)
  # Check Pydantic model attributes
  if not result.success:
      status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
      raise HTTPException(status_code=status_code, detail=result.message or "Failed to update contact")
  return result # Return the Pydantic model

@router.put("/ticket/{ticket_id}/company")
async def update_ticket_company_endpoint(ticket_id: int, data: TicketCompanyUpdateRequest, context: Dict[str, Any] = Depends(get_user_context)):
    """Update the company associated with a ticket."""
    # Call the tool function directly
    # Call the decorated tool function directly
    # Call the implementation function directly
    # Call the implementation function directly (already correct)
    result = cw.update_ticket_company_impl(ticket_id=ticket_id, new_company_name=data.new_company_name) # type: ignore[attr-defined] # Keep attr-defined ignore for now
    # Check Pydantic model attributes
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to update company")
    return result # Return the Pydantic model

@router.put("/ticket/{ticket_id}/owner")
async def update_ticket_owner_endpoint(ticket_id: int, data: TicketOwnerUpdateRequest, context: Dict[str, Any] = Depends(get_user_context)):
    """Update the owner (member) of a ticket."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("update_ticket_owner", ticket_id=ticket_id, member_identifier=data.member_identifier)
    # Check Pydantic model attributes
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to update owner")
    return result # Return the Pydantic model

@router.put("/ticket/{ticket_id}/close")
async def close_ticket_endpoint(ticket_id: int, service_board_id: int = Query(...), context: Dict[str, Any] = Depends(get_user_context)):
    """Close a ticket (requires board ID as query parameter)."""
    # Note: close_ticket tool doesn't require member context currently
    # Call the implementation function directly
    result = tool_adapter.call_impl("close_ticket", ticket_id=ticket_id, service_board_id=service_board_id)
    # Check Pydantic model attributes
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to close ticket")
    return result # Return the Pydantic model

@router.post("/ticket/{ticket_id}/note", status_code=201)
async def add_note(ticket_id: int, note: NoteRequest, context: Dict[str, Any] = Depends(get_user_context)):
    """Add a note to a ticket. Uses the authenticated user's context."""
    # Get CW member info from the authenticated context
    cw_member_info = context.get("cw_member_info")
    if not cw_member_info:
        raise HTTPException(status_code=403, detail="User's ConnectWise member context not found or user not linked.")

    # Create the ToolContext required by the updated tool
    # Instantiate CwMemberInfo if details are present
    cw_member_info_model = CwMemberInfo(**cw_member_info) if cw_member_info else None
    tool_context = ToolContext(cw_member_info=cw_member_info_model)

    # Determine note type if not provided
    note_type = note.note_type
    if not note_type:
        note_type = "Resolution" if note.resolution else ("Internal" if note.internal else "Discussion")

    # Call the implementation function directly
    result = tool_adapter.call_impl(
        "add_ticket_note",
        context=tool_context,
        ticket_id=ticket_id,
        note_text=note.note_text,
        internal=note.internal,
        resolution=note.resolution,
        note_type=note_type
    )
    # Use attribute access for Pydantic model result
    if not result.success:
        status_code = 400 if result.error_type in ["ValueError", "AuthError"] else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to add note")
    return result

@router.post("/ticket/{ticket_id}/time", status_code=201)
async def add_time(ticket_id: int, entry: TimeEntryRequest, context: Dict[str, Any] = Depends(get_user_context)):
    """Add a time entry to a ticket. Uses the authenticated user's context."""
    # Get CW member info from the authenticated context
    cw_member_info = context.get("cw_member_info")
    if not cw_member_info:
        raise HTTPException(status_code=403, detail="User's ConnectWise member context not found or user not linked.")

    # Create the ToolContext required by the updated tool
    # Instantiate CwMemberInfo if details are present
    cw_member_info_model = CwMemberInfo(**cw_member_info) if cw_member_info else None
    tool_context = ToolContext(cw_member_info=cw_member_info_model)

    # Call the implementation function directly with all parameters
    result = tool_adapter.call_impl(
        "add_time_entry",
        context=tool_context,
        ticket_id=ticket_id,
        notes=entry.notes,
        actual_hours=entry.actual_hours,
        billable_option=entry.billable_option,
        time_start=entry.time_start,
        time_end=entry.time_end,
        work_type_id=entry.work_type_id,
        work_role_id=entry.work_role_id,
        location_id=entry.location_id,
        email_contact=entry.email_contact,
        email_resource=entry.email_resource,
        email_cc=entry.email_cc,
        new_status_id=entry.new_status_id
    )
    # Use attribute access for Pydantic model
    if not result.success:
        status_code = 400 if result.error_type in ["ValueError", "AuthError"] else (result.status_code if result.error_type == "APIError" else 500)
        raise HTTPException(status_code=status_code or 500, detail=result.message or "Failed to add time entry")
    return result

# Pydantic model to capture query parameters for the endpoint
# We can reuse the QueryTicketsParams definition from cw_tools if imported,
# but defining it here keeps route logic self-contained.
# Alternatively, import QueryTicketsParams from cw_tools.
# Updated schema for enhanced ticket searching with pagination and sorting
class TicketSearchSchema(BaseModel):
    # Filtering
    board_id: Optional[int] = Query(None, description="Filter by service board ID")
    company_name: Optional[str] = Query(None, description="Filter by company name (exact or partial match)")
    contact_name: Optional[str] = Query(None, description="Filter by contact name (partial match)")
    status_name: Optional[str] = Query(None, description="Filter by status name (e.g., 'New', 'Assigned') or 'open'/'closed'")
    days_range: Optional[int] = Query(None, ge=1, description="Filter by tickets entered within the last N days")
    search_term: Optional[str] = Query(None, description="Search term for ticket summary")
    priority_name: Optional[str] = Query(None, description="Filter by priority name (comma-separated for multiple)")
    # TODO: Add date range (from/to) if needed

    # Sorting
    sort_by: Optional[str] = Query('dateEntered', description="Field to sort by (e.g., 'dateEntered', 'summary', 'priority', 'companyName', 'statusName')")
    sort_order: Literal['asc', 'desc'] = Query('desc', description="Sort order: 'asc' or 'desc'")

    # Pagination
    page: int = Query(1, ge=1, description="Page number (1-based)")
    per_page: int = Query(10, ge=1, le=100, description="Items per page (max 100)")
@router.get("/tickets", response_model=PaginatedTicketsResult) # Keep endpoint path, add response model
async def search_tickets_endpoint( # Renamed function for clarity
    params: TicketSearchSchema = Depends(), # Use updated schema
    context: Dict[str, Any] = Depends(get_user_context)
) -> PaginatedTicketsResult: # Add return type hint
    """Query tickets based on various filter criteria."""
    if not cw.manage_api_client:
         raise HTTPException(status_code=503, detail="ConnectWise client not configured.")

    conditions: List[str] = [] # Added type hint
    try:
        # --- Build Conditions based on new search parameters ---
        conditions = []

        if params.board_id:
            conditions.append(f"board/id = {params.board_id}")

        if params.company_name:
            # Use find_company tool for better matching logic
            # Call the implementation function directly
            company_lookup = tool_adapter.call_impl("find_company", company_name_or_identifier=params.company_name)
            if company_lookup.success and company_lookup.found and company_lookup.company:
                conditions.append(f"company/id = {company_lookup.company.id}")
            else:
                 logger.warning(f"Company '{params.company_name}' not resolved to ID. Using 'contains'.")
                 conditions.append(f"company/name contains '{params.company_name}'")

        if params.contact_name:
            conditions.append(f"contact/name contains '{params.contact_name}'")

        # Handle status filtering explicitly
        if params.status_name:
            status_lower = params.status_name.lower()
            if status_lower == 'open':
                conditions.append("closedFlag = false")
            elif status_lower == 'closed':
                conditions.append("closedFlag = true")
            else:
                # Filter by specific status name (contains)
                conditions.append(f"status/name contains '{params.status_name}'")
        else:
            # Default: Only show open tickets if no status filter is specified
            conditions.append("closedFlag = false")

        if params.days_range:
            start_date = datetime.now(timezone.utc) - timedelta(days=params.days_range)
            start_date_str = start_date.strftime('%Y-%m-%dT00:00:00Z')
            conditions.append(f"dateEntered > [{start_date_str}]")

        if params.search_term:
            conditions.append(f"summary contains '{params.search_term}'")

        if params.priority_name:
            # Split comma-separated names, quote each, and create an 'in' clause
            priority_names = [name.strip() for name in params.priority_name.split(',') if name.strip()]
            if priority_names:
                quoted_names = [f"'{name}'" for name in priority_names]
                conditions.append(f"priority/name in ({','.join(quoted_names)})")

        # --- Get Total Count ---
        # Combine conditions, ensuring there's always at least one condition
        # If conditions list is empty after processing filters, it means no filters were applied.
        # In this case, we should still apply the default 'open tickets' filter.
        if not conditions:
             conditions.append("closedFlag = false") # Ensure default if no other filters applied

        combined_conditions = " AND ".join(conditions)
        logger.info(f"Getting count for ticket search with conditions: {combined_conditions}")
        try:
            # Correctly call the count endpoint (assuming conditions is direct arg)
            # Ensure count call uses ignore[operator]
            count_result = cw.manage_api_client.service.tickets.count.get(params={"conditions": combined_conditions}) # type: ignore[operator] # Pass conditions
            total_found = int(getattr(count_result, 'count', 0)) # Ensure int, default 0
            logger.info(f"Total tickets found: {total_found}")
        except ConnectWiseException as count_e:
            logger.error(f"ConnectWise API error during ticket count: {count_e}", exc_info=True)
            raise HTTPException(status_code=getattr(count_e, "status_code", 500), detail=f"ConnectWise API Error during count: {count_e}")
        except Exception as count_e:
            logger.exception(f"Unexpected error during ticket count: {count_e}")
            raise HTTPException(status_code=500, detail=f"Internal server error during count: {count_e}")

        # --- Calculate Pagination ---
        # Ensure total_found is int before division
        # total_found is guaranteed int
        total_pages = math.ceil(total_found / params.per_page) if params.per_page > 0 and total_found > 0 else 0
        has_next = params.page < total_pages
        has_previous = params.page > 1 and total_pages > 0 # Check total_pages here too

        # --- Execute Query for Current Page ---
        logger.info(f"Executing ticket search for page {params.page}/{total_pages} with conditions: {combined_conditions}")

        # Map frontend sort fields to API fields
        sort_field_map = {
            'dateEntered': 'dateEntered',
            'summary': 'summary',
            'priority': 'priority/name',
            'companyName': 'company/name',
            'statusName': 'status/name',
            'id': 'id' # Add id as a potential sort key
            # Add other mappings as needed
        }
        # Handle potential None for sort_by before dict.get
        # Ensure sort_key is always a string before dict.get
        # Ensure sort_key is str before get
        sort_key = params.sort_by if isinstance(params.sort_by, str) else 'dateEntered'
        api_sort_field = sort_field_map.get(sort_key, 'dateEntered')
        order_by_str = f"{api_sort_field} {params.sort_order}"

        # Include nested fields with explicit paths to ensure they're included in the response
        ticket_fields = "id,summary,status/id,status/name,board/id,board/name,company/id,company/name,contact/id,contact/name,owner/id,owner/identifier,owner/name,priority/id,priority/name,dateEntered,type/id,type/name,subType/id,subType/name,item/id,item/name,lastUpdated"

        # Log the fields being requested for debugging
        logger.debug(f"Requesting ticket fields for search: {ticket_fields}")
        api_params = {
            "conditions": combined_conditions,
            "orderBy": order_by_str,
            "fields": ticket_fields,
            "pageSize": params.per_page,
            "page": params.page
        }

        # Ensure total_found is int before comparison
        # total_found is now guaranteed int
        # total_found is guaranteed int
        tickets_raw = cw.manage_api_client.service.tickets.get(params=api_params) if total_found > 0 else [] # type: ignore[arg-type]

        # --- Format Results ---
        ticket_list = []
        if tickets_raw and isinstance(tickets_raw, list):
            logger.debug(f"Raw ticket object type: {type(tickets_raw[0])}") # Log type of first item
            logger.debug(f"Raw ticket object dir: {dir(tickets_raw[0])}") # Log attributes/methods
            logger.debug(f"Raw ticket object vars: {vars(tickets_raw[0]) if hasattr(tickets_raw[0], '__dict__') else 'N/A'}") # Log instance variables if possible
            for ticket_raw in tickets_raw: # Rename variable for clarity
                # Directly access attributes, including nested reference objects
                # Create TicketSummary objects (ensure fields match the model)
                try:
                    # Log the raw ticket data for debugging
                    logger.debug(f"Processing ticket: ID={getattr(ticket_raw, 'id', None)}")

                    # Extract nested objects
                    type_obj = getattr(ticket_raw, 'type', None)
                    subtype_obj = getattr(ticket_raw, 'subType', None)
                    item_obj = getattr(ticket_raw, 'item', None)

                    # Create TicketSummary with all fields
                    summary_obj = TicketSummary(
                        ticket_id=getattr(ticket_raw, 'id', None),
                        summary=getattr(ticket_raw, 'summary', None),
                        status=getattr(getattr(ticket_raw, 'status', None), 'name', None),
                        board_id=getattr(getattr(ticket_raw, 'board', None), 'id', None),
                        board_name=getattr(getattr(ticket_raw, 'board', None), 'name', None),
                        company_id=getattr(getattr(ticket_raw, 'company', None), 'id', None),
                        company_name=getattr(getattr(ticket_raw, 'company', None), 'name', None),
                        contact_id=getattr(getattr(ticket_raw, 'contact', None), 'id', None),
                        contact_name=getattr(getattr(ticket_raw, 'contact', None), 'name', None),
                        owner_identifier=getattr(getattr(ticket_raw, 'owner', None), 'identifier', None),
                        priority=getattr(getattr(ticket_raw, 'priority', None), 'name', None),
                        date_entered=cw.format_datetime(getattr(ticket_raw, 'dateEntered', None)),
                        # Add the additional fields
                        ticket_type=getattr(type_obj, 'name', None),
                        ticket_subtype=getattr(subtype_obj, 'name', None),
                        ticket_item=getattr(item_obj, 'name', None),
                    )

                    # Log the extracted fields for debugging
                    logger.debug(f"Extracted fields: type={summary_obj.ticket_type}, subtype={summary_obj.ticket_subtype}, item={summary_obj.ticket_item}")
                    # Filter out entries where essential info might be missing
                    if summary_obj.ticket_id:
                        ticket_list.append(summary_obj)
                    else:
                        logger.warning(f"Skipping ticket entry due to missing ID in raw data: {ticket_raw}")
                except Exception as format_e:
                     logger.warning(f"Error formatting ticket data for ticket ID {getattr(ticket_raw, 'id', 'N/A')}: {format_e}", exc_info=True)
                     # Optionally skip this ticket or handle the error differently
        else:
             logger.info(f"Received non-list or empty data from CW ticket search for page {params.page}: {tickets_raw}")


        logger.info(f"Query endpoint processed {len(ticket_list)} tickets for page {params.page}.")
        # Return the PaginatedTicketsResult structure
        return PaginatedTicketsResult(
            success=True,
            tickets=ticket_list,
            total_found=total_found, # Guaranteed int
            page=params.page,
            total_pages=total_pages,
            has_next=has_next,
            has_previous=has_previous
        )

    except ConnectWiseException as cw_e: # Use the directly imported exception
         logger.error(f"ConnectWise API error during ticket query: {cw_e}", exc_info=True)
         raise HTTPException(status_code=getattr(cw_e, "status_code", 500), detail=f"ConnectWise API Error: {cw_e}")
    except Exception as e:
        logger.exception(f"Unexpected error during ticket query: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")


# --- Metadata and Search Endpoints ---

@router.get("/metadata/boards")
async def list_boards(context: Dict[str, Any] = Depends(get_user_context)):
    """Get list of active service boards."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("list_service_boards")
    # Handle the ListBoardsResult Pydantic model
    if not result.success:
        # Log the error message from the result
        logger.error(f"Failed to list boards: {result.message}")
        raise HTTPException(status_code=500, detail=result.message or "Failed to list boards")
    # Return the list of boards (which are BoardDetail Pydantic models)
    # FastAPI will automatically serialize them to JSON
    return result.boards or []

@router.get("/metadata/work-types")
async def list_work_types(context: Dict[str, Any] = Depends(get_user_context)):
    """Get list of work types for time entries."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("list_work_types")
    if not result.success:
        logger.error(f"Failed to list work types: {result.message}")
        raise HTTPException(status_code=500, detail=result.message or "Failed to list work types")
    return result.work_types or []

@router.get("/metadata/work-roles")
async def list_work_roles(context: Dict[str, Any] = Depends(get_user_context)):
    """Get list of work roles for time entries."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("list_work_roles")
    if not result.success:
        logger.error(f"Failed to list work roles: {result.message}")
        raise HTTPException(status_code=500, detail=result.message or "Failed to list work roles")
    return result.work_roles or []

@router.get("/metadata/locations")
async def list_locations(context: Dict[str, Any] = Depends(get_user_context)):
    """Get list of locations for time entries."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("list_locations")
    if not result.success:
        logger.error(f"Failed to list locations: {result.message}")
        raise HTTPException(status_code=500, detail=result.message or "Failed to list locations")
    return result.locations or []

@router.get("/metadata/statuses")
async def list_statuses(service_board_id: int, context: Dict[str, Any] = Depends(get_user_context)):
    """Get list of statuses for a given board ID."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("list_ticket_statuses", service_board_id=service_board_id)
    # Check Pydantic model attributes
    if not result.success:
        raise HTTPException(status_code=result.status_code or 500, detail=result.message or "Failed to list statuses")
    # Return the full result object to match the ListStatusesResult interface expected by the frontend
    return result

@router.get("/search/companies")
async def search_companies(q: str = Query(..., description="Search query for company name"), context: Dict[str, Any] = Depends(get_user_context)):
    """Search companies by name."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("find_company", company_name_or_identifier=q)
    # find_company returns success=True even if not found
    return result # Return the full result including 'found' flag

@router.get("/search/contacts")
async def search_contacts(company_id: int, q: str = Query(..., description="Search query for contact name or email"), context: Dict[str, Any] = Depends(get_user_context)):
    """Search contacts by name/email within a specific company."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("find_contact", company_id=company_id, contact_name=q)
    return result

@router.get("/search/members")
async def search_members(q: str = Query(..., description="Search query for member identifier or email"), context: Dict[str, Any] = Depends(get_user_context)):
    """Search members by identifier or email."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("find_member", member_identifier=q)
    return result

@router.get("/metadata/priorities")
# Add service_board_id query parameter
async def list_priorities(board_id: int = Query(..., description="The ID of the service board for which to list priorities"), context: Dict[str, Any] = Depends(get_user_context)): # Changed parameter name to board_id
   """Get list of ticket priorities."""
   # Call the implementation function directly
   result = tool_adapter.call_impl("list_ticket_priorities", board_id=board_id)
   if not result.success:
       logger.error(f"Failed to list priorities: {result.message}")
       raise HTTPException(status_code=500, detail=result.message or "Failed to list priorities")
   return result.priorities or []

# Company and contact endpoints
@router.get("/company/{company_id}/details")
async def get_company_details_endpoint(company_id: int, context: Dict[str, Any] = Depends(get_user_context)):
    """Get detailed information about a company."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("get_company_details", company_id=company_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if hasattr(result, 'status_code') and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to get company details")
    return result

@router.get("/company/{company_id}/contacts")
async def get_company_contacts_endpoint(company_id: int, context: Dict[str, Any] = Depends(get_user_context)):
    """Get all contacts for a company."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("get_company_contacts", company_id=company_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if hasattr(result, 'status_code') and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to get company contacts")
    return result

@router.get("/company/{company_id}/tickets")
async def get_company_tickets_endpoint(company_id: int, board_id: Optional[int] = None, context: Dict[str, Any] = Depends(get_user_context)):
    """Get tickets for a company, optionally filtered by service board ID."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("get_company_tickets", company_id=company_id, board_id=board_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if hasattr(result, 'status_code') and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to get company tickets")
    return result

# Ticket statuses and priorities endpoints
@router.get("/ticket/{ticket_id}/statuses")
async def get_ticket_statuses_endpoint(ticket_id: int, context: Dict[str, Any] = Depends(get_user_context)):
    """Get all available statuses for a specific ticket."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("get_ticket_statuses", ticket_id=ticket_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to get ticket statuses")
    return result

@router.get("/ticket/{ticket_id}/priorities")
async def get_ticket_priorities_endpoint(ticket_id: int, context: Dict[str, Any] = Depends(get_user_context)):
    """Get all available priorities for a specific ticket."""
    # Call the implementation function directly
    result = tool_adapter.call_impl("get_ticket_priorities", ticket_id=ticket_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to get ticket priorities")
    return result

@router.get("/ticket/{ticket_id}/types")
async def get_ticket_types_endpoint(ticket_id: int, context: Dict[str, Any] = Depends(get_user_context)):
    """Get all available types for a specific ticket's board."""
    # First get the ticket details to determine the board ID
    from app.cw_tools.cw_tools_main import get_ticket_details_for_api
    ticket_result = get_ticket_details_for_api(ticket_id=ticket_id)

    if not ticket_result.get("success", False):
        status_code = ticket_result.get("status_code", 500)
        raise HTTPException(status_code=status_code, detail=ticket_result.get("message", "Failed to get ticket details"))

    board_id = ticket_result.get("board_id")
    if not board_id:
        raise HTTPException(status_code=400, detail="Could not determine board ID for ticket")

    # Call the implementation function to get types for this board
    result = tool_adapter.call_impl("get_board_types", board_id=board_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to get ticket types")
    return result

@router.get("/ticket/{ticket_id}/subtypes")
async def get_ticket_subtypes_endpoint(ticket_id: int, type_id: Optional[int] = None, context: Dict[str, Any] = Depends(get_user_context)):
    """Get all available subtypes for a specific ticket's type."""
    # First get the ticket details to determine the board ID and type ID if not provided
    from app.cw_tools.cw_tools_main import get_ticket_details_for_api
    ticket_result = get_ticket_details_for_api(ticket_id=ticket_id)

    if not ticket_result.get("success", False):
        status_code = ticket_result.get("status_code", 500)
        raise HTTPException(status_code=status_code, detail=ticket_result.get("message", "Failed to get ticket details"))

    board_id = ticket_result.get("board_id")
    if not board_id:
        raise HTTPException(status_code=400, detail="Could not determine board ID for ticket")

    # Use provided type_id or get it from ticket details
    current_type_id = type_id or ticket_result.get("type_id")
    if not current_type_id:
        raise HTTPException(status_code=400, detail="Could not determine type ID for ticket")

    # Call the implementation function to get subtypes for this type
    result = tool_adapter.call_impl("get_type_subtypes", board_id=board_id, type_id=current_type_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to get ticket subtypes")
    return result

@router.get("/ticket/{ticket_id}/items")
async def get_ticket_items_endpoint(ticket_id: int, subtype_id: Optional[int] = None, context: Dict[str, Any] = Depends(get_user_context)):
    """Get all available items for a specific ticket's subtype."""
    # First get the ticket details to determine the board ID, type ID, and subtype ID if not provided
    from app.cw_tools.cw_tools_main import get_ticket_details_for_api
    ticket_result = get_ticket_details_for_api(ticket_id=ticket_id)

    if not ticket_result.get("success", False):
        status_code = ticket_result.get("status_code", 500)
        raise HTTPException(status_code=status_code, detail=ticket_result.get("message", "Failed to get ticket details"))

    board_id = ticket_result.get("board_id")
    if not board_id:
        raise HTTPException(status_code=400, detail="Could not determine board ID for ticket")

    # Use provided subtype_id or get it from ticket details
    current_subtype_id = subtype_id or ticket_result.get("subtype_id")
    if not current_subtype_id:
        raise HTTPException(status_code=400, detail="Could not determine subtype ID for ticket")

    # Call the implementation function to get items for this subtype
    result = tool_adapter.call_impl("get_subtype_items", board_id=board_id, subtype_id=current_subtype_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to get ticket items")
    return result

# Update ticket type, subtype, and item endpoints
@router.put("/ticket/{ticket_id}/type")
async def update_ticket_type_endpoint(ticket_id: int, payload: dict, context: Dict[str, Any] = Depends(get_user_context)):
    """Update the type of a specific ticket."""
    type_id = payload.get("type_id")
    if not type_id:
        raise HTTPException(status_code=400, detail="type_id is required")

    # Call the implementation function directly
    result = tool_adapter.call_impl("update_ticket_type", ticket_id=ticket_id, type_id=type_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to update ticket type")
    return result

@router.put("/ticket/{ticket_id}/subtype")
async def update_ticket_subtype_endpoint(ticket_id: int, payload: dict, context: Dict[str, Any] = Depends(get_user_context)):
    """Update the subtype of a specific ticket."""
    subtype_id = payload.get("subtype_id")
    if not subtype_id:
        raise HTTPException(status_code=400, detail="subtype_id is required")

    # Call the implementation function directly
    result = tool_adapter.call_impl("update_ticket_subtype", ticket_id=ticket_id, subtype_id=subtype_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to update ticket subtype")
    return result

@router.put("/ticket/{ticket_id}/item")
async def update_ticket_item_endpoint(ticket_id: int, payload: dict, context: Dict[str, Any] = Depends(get_user_context)):
    """Update the item of a specific ticket."""
    item_id = payload.get("item_id")
    if not item_id:
        raise HTTPException(status_code=400, detail="item_id is required")

    # Call the implementation function directly
    result = tool_adapter.call_impl("update_ticket_item", ticket_id=ticket_id, item_id=item_id)
    if not result.success:
        status_code = 400 if result.error_type == "ValueError" else (result.status_code if result.error_type == "APIError" and result.status_code else 500)
        raise HTTPException(status_code=status_code, detail=result.message or "Failed to update ticket item")
    return result

# AI-powered ticket summary generation endpoint
@router.post("/generate/ticket-summary")
async def generate_ticket_summary(payload: dict, context: Dict[str, Any] = Depends(get_user_context)):
    """Generate an improved summary for a ticket using AI."""
    ticket_id = payload.get("ticket_id")
    if not ticket_id:
        raise HTTPException(status_code=400, detail="ticket_id is required")

    try:
        # Get ticket details (includes notes and time entries)
        ticket_details = tool_adapter.call_impl("get_ticket_details", ticket_id=ticket_id)
        if not ticket_details.success:
            raise HTTPException(status_code=404, detail=f"Ticket not found: {ticket_details.message}")

        # Extract notes and time entries from ticket_details
        notes = ticket_details.notes if hasattr(ticket_details, 'notes') else []
        time_entries = ticket_details.time_entries if hasattr(ticket_details, 'time_entries') else []

        # Construct context for the AI
        context_text = f"Ticket #{ticket_id}\n"
        context_text += f"Current Summary: {ticket_details.summary}\n"
        context_text += f"Status: {ticket_details.status}\n"
        context_text += f"Type: {ticket_details.type}\n" if hasattr(ticket_details, 'type') else ""
        context_text += f"Subtype: {ticket_details.subtype}\n" if hasattr(ticket_details, 'subtype') else ""
        context_text += f"Item: {ticket_details.item}\n" if hasattr(ticket_details, 'item') else ""

        # Add initial description
        if ticket_details.initial_description:
            context_text += f"\nInitial Description:\n{ticket_details.initial_description}\n"

        # Add recent notes (limit to last 5)
        if notes:
            context_text += "\nRecent Notes (newest first):\n"
            for note in notes[:5]:
                context_text += f"- {note.text}\n"

        # Add recent time entries (limit to last 5)
        if time_entries:
            context_text += "\nRecent Time Entries (newest first):\n"
            for entry in time_entries[:5]:
                context_text += f"- {entry.notes}\n"

        # Define system prompt for the AI
        system_prompt = """
        You are an expert at writing clear, concise, and informative ticket summaries for IT service management.
        Your task is to generate an improved summary for the ticket based on the provided information.

        Guidelines for a good summary:
        1. Be concise but descriptive (30-80 characters is ideal)
        2. Include the key issue or request
        3. Use proper technical terminology
        4. Be specific rather than vague
        5. Use standard capitalization (not all caps)
        6. Avoid unnecessary words like "please" or "help"
        7. Start with an action verb when possible
        8. Don't include ticket numbers or dates in the summary

        Examples of good summaries:
        - "Configure new VPN access for marketing team"
        - "Outlook crashes when opening calendar attachments"
        - "Replace failed hard drive in accounting server"
        - "Set up email forwarding for new hire John Smith"
        """

        # User prompt
        user_prompt = f"Based on the following ticket information, generate an improved, concise summary:\n\n{context_text}"

        # Call OpenAI Responses API
        from openai import OpenAI
        client = OpenAI()

        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.3,
            max_tokens=300
        )

        # Extract the suggested summary
        suggested_summary = response.choices[0].message.content.strip()

        # Remove any quotes that might be around the summary
        suggested_summary = suggested_summary.strip('"').strip("'").strip()

        return {
            "success": True,
            "suggested_summary": suggested_summary,
            "original_summary": ticket_details.summary
        }

    except Exception as e:
        logger.error(f"Error generating ticket summary: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to generate summary: {str(e)}")

# Example simple health check endpoint (unauthenticated)
@router.get("/health", status_code=200)
async def health_check():
   return {"status": "ok"}
</file>

<file path="routes/generate.py">
from typing import Dict, Any, Optional, List
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
import logging
import openai
import requests
from bs4 import BeautifulSoup
import re
from app.routes.api import get_user_context
import app.config as config
from app.cw_tools.cw_tools_main import get_ticket_details_impl

# Configure logging
logger = logging.getLogger(__name__)

router = APIRouter(prefix="/generate", tags=["generate"])

class SummaryRequest(BaseModel):
    ticket_id: int

class SummaryResponse(BaseModel):
    success: bool
    suggested_summary: Optional[str] = None
    message: Optional[str] = None

class DeepResearchRequest(BaseModel):
    query: str
    ticket_id: Optional[int] = None
    depth: Optional[int] = 3  # Default depth of research
    max_sources: Optional[int] = 5  # Default number of sources to use

class DeepResearchResponse(BaseModel):
    success: bool
    report: Optional[str] = None
    message: Optional[str] = None

@router.post("/ticket-summary", response_model=SummaryResponse)
async def generate_ticket_summary(request: SummaryRequest, context: Dict[str, Any] = Depends(get_user_context)):
    """Generate an improved ticket summary using OpenAI Responses API."""
    ticket_id = request.ticket_id

    # Get ticket details
    ticket_result = get_ticket_details_impl(ticket_id=ticket_id)
    if not ticket_result.success:
        raise HTTPException(
            status_code=404 if ticket_result.error_type == "NotFound" else 500,
            detail=f"Failed to retrieve ticket details: {ticket_result.message}"
        )

    # Format context for the AI
    context_string = f"""
# Ticket Information
- ID: {ticket_id}
- Current Summary: {ticket_result.summary or 'N/A'}
- Status: {ticket_result.status or 'N/A'}
- Board: {ticket_result.board_name or 'N/A'}
- Company: {ticket_result.company_name or 'N/A'}
- Contact: {ticket_result.contact_name or 'N/A'}

# Initial Description
{ticket_result.initial_description or 'No initial description available.'}

# Notes
"""

    if ticket_result.notes and len(ticket_result.notes) > 0:
        for i, note in enumerate(ticket_result.notes):
            context_string += f"\n## Note {i+1} ({note.created_by or 'Unknown'}):\n{note.text or 'Empty note'}\n"
    else:
        context_string += "\nNo notes available.\n"

    context_string += "\n# Time Entries\n"

    if ticket_result.time_entries and len(ticket_result.time_entries) > 0:
        for i, entry in enumerate(ticket_result.time_entries):
            context_string += f"\n## Time Entry {i+1} ({entry.member_name or 'Unknown'}):\n{entry.notes or 'No notes'}\n"
    else:
        context_string += "\nNo time entries available.\n"

    # Define the system prompt
    system_prompt = """
You are an expert at writing clear, concise, and informative ticket summaries for IT service tickets.
Your task is to analyze the provided ticket information and generate an improved summary.

Guidelines:
1. The summary should be 5-15 words, concise but descriptive
2. Focus on the core issue or request, not peripheral details
3. Use technical terminology appropriate for IT professionals
4. Include the affected system or service when relevant
5. Use present tense and active voice
6. Do not include status information (like "resolved" or "in progress")
7. Do not include ticket ID numbers
8. Do not include customer names
9. Prioritize information from the most recent notes if they clarify the issue

Return ONLY the suggested summary text with no additional commentary, explanations, or formatting.
"""

    # Initialize OpenAI client
    client = openai.AsyncOpenAI(api_key=config.OPENAI_API_KEY)

    try:
        # Call OpenAI Responses API
        response = await client.beta.threads.runs.create_and_stream(
            thread={
                "messages": [
                    {
                        "role": "user",
                        "content": f"Ticket Context:\n{context_string}"
                    }
                ]
            },
            assistant_id=config.OPENAI_ASSISTANT_ID,
            instructions=system_prompt,
            temperature=0.5,
            max_completion_tokens=50,
        )

        # Process the response
        suggested_summary = ""
        async for chunk in response:
            if hasattr(chunk, 'data') and chunk.data and hasattr(chunk.data, 'content'):
                suggested_summary += chunk.data.content[0].text

        # Clean up the summary
        suggested_summary = suggested_summary.strip().strip('"').strip("'").strip()

        if not suggested_summary:
            return SummaryResponse(
                success=False,
                message="Failed to generate a summary. The AI returned an empty response."
            )

        return SummaryResponse(
            success=True,
            suggested_summary=suggested_summary
        )

    except Exception as e:
        logger.error(f"Error calling OpenAI API for summary: {e}")
        return SummaryResponse(
            success=False,
            message=f"Failed to generate summary: {str(e)}"
        )

@router.post("/deep-research", response_model=DeepResearchResponse)
async def generate_deep_research(request: DeepResearchRequest, context: Dict[str, Any] = Depends(get_user_context)):
    """Generate a deep research report on a topic using web search and OpenAI Responses API."""
    query = request.query
    ticket_id = request.ticket_id
    depth = min(request.depth or 3, 5)  # Limit depth to 5 for performance
    max_sources = min(request.max_sources or 5, 10)  # Limit sources to 10

    # Get ticket context if ticket_id is provided
    ticket_context = ""
    if ticket_id:
        try:
            ticket_result = get_ticket_details_impl(ticket_id=ticket_id)
            if ticket_result.success:
                ticket_context = f"""
# Ticket Information
- ID: {ticket_id}
- Summary: {ticket_result.summary or 'N/A'}
- Status: {ticket_result.status or 'N/A'}
- Board: {ticket_result.board_name or 'N/A'}
- Company: {ticket_result.company_name or 'N/A'}
- Contact: {ticket_result.contact_name or 'N/A'}

# Initial Description
{ticket_result.initial_description or 'No initial description available.'}

# Recent Notes
"""

                # Add a few recent notes if available
                if ticket_result.notes and len(ticket_result.notes) > 0:
                    for i, note in enumerate(ticket_result.notes[:3]):  # Only include up to 3 recent notes
                        ticket_context += f"\n## Note {i+1} ({note.created_by or 'Unknown'}):\n{note.text or 'Empty note'}\n"
                else:
                    ticket_context += "\nNo notes available.\n"
        except Exception as e:
            logger.error(f"Error getting ticket details for deep research: {e}")
            # Continue without ticket context if there's an error

    # Initialize OpenAI client
    client = openai.AsyncOpenAI(api_key=config.OPENAI_API_KEY)

    try:
        # Simulate web search results
        # In a real implementation, this would use a proper web search API
        search_results = [
            {
                "title": "Understanding Technical Solutions for Common IT Issues",
                "url": "https://example.com/tech-solutions",
                "snippet": "This comprehensive guide covers solutions for common IT problems including network connectivity, software compatibility, and hardware troubleshooting."
            },
            {
                "title": "Best Practices for IT Support",
                "url": "https://example.com/it-support-best-practices",
                "snippet": "Learn about the industry best practices for providing effective IT support, including communication strategies, documentation, and problem-solving methodologies."
            },
            {
                "title": "Advanced Troubleshooting Techniques",
                "url": "https://example.com/advanced-troubleshooting",
                "snippet": "Discover advanced techniques for troubleshooting complex technical issues, with step-by-step guides and expert insights."
            }
        ]

        # Limit the number of sources based on max_sources
        search_results = search_results[:max_sources]

        # Format search results for the AI
        search_context = "\n# Search Results\n\n"
        for i, result in enumerate(search_results):
            search_context += f"## Source {i+1}: {result['title']}\nURL: {result['url']}\n{result['snippet']}\n\n"

        # Combine all context
        full_context = f"# Research Query\n{query}\n\n"
        if ticket_context:
            full_context += f"# Related Ticket Context\n{ticket_context}\n\n"
        full_context += search_context

        # Define the system prompt
        system_prompt = f"""
        You are an expert IT research assistant. Your task is to create a comprehensive research report based on the provided query and search results.

        Guidelines:
        1. Create a well-structured markdown report with headings, subheadings, and bullet points
        2. Include an executive summary at the beginning
        3. Analyze the information from all provided sources
        4. Cite sources when referencing specific information
        5. Provide practical, actionable recommendations
        6. Focus on depth level {depth} (1=basic overview, 5=detailed technical analysis)
        7. Include a "Next Steps" section at the end
        8. Format the report in clean, well-structured markdown

        Return ONLY the research report with no additional commentary or explanations.
        """

        # Call OpenAI Responses API
        response = await client.chat.completions.create(
            model="gpt-4-turbo",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": full_context}
            ],
            temperature=0.5,
            max_tokens=4000,
        )

        # Extract the report
        report = response.choices[0].message.content.strip()

        if not report:
            return DeepResearchResponse(
                success=False,
                message="Failed to generate a research report. The AI returned an empty response."
            )

        return DeepResearchResponse(
            success=True,
            report=report
        )

    except Exception as e:
        logger.error(f"Error generating deep research report: {e}")
        return DeepResearchResponse(
            success=False,
            message=f"Failed to generate research report: {str(e)}"
        )
</file>

<file path="routes/search.py">
import logging
import os
import asyncio
from typing import List, Optional, Dict, Any, Awaitable, cast
from pydantic import BaseModel
from fastapi import APIRouter, Depends, HTTPException, Query, Security
from fastapi.security import OAuth2PasswordBearer
from app.routes.api import get_user_context
from app.cw_tools.cw_tools_main import (
    search_tickets_tool_impl,
    find_company_impl,
    find_contact_impl,
    find_member,
    _find_member_details_sync
)
from app.cw_tools.models import (
    FindCompanyResult,
    FindContactResult,
    FindMemberResult
)

# Create a dummy OAuth2 scheme that doesn't actually validate tokens
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token", auto_error=False)

# Define a simple auth scheme function that always returns a dummy user
# The _token parameter is intentionally unused but required by the Security dependency
async def get_current_user(_token: str = Security(oauth2_scheme)):  # noqa: F841
    # In development mode, always return a dummy user
    return {"dummy_user": True, "name": "Development User", "email": "dev@example.com"}

# Import OpenAI client
from openai import OpenAI

# Set up logging
logger = logging.getLogger(__name__)

# Create router
router = APIRouter(prefix="/search", tags=["search"])

# Models for web search
class SearchResult(BaseModel):
    title: str
    url: str
    snippet: str

class WebSearchResponse(BaseModel):
    success: bool = True
    message: Optional[str] = None
    results: List[SearchResult] = []

# Models for unified search
class UnifiedSearchResult(BaseModel):
    tickets: List[Dict[str, Any]] = []
    companies: List[Dict[str, Any]] = []
    contacts: List[Dict[str, Any]] = []
    members: List[Dict[str, Any]] = []

class UnifiedSearchResponse(BaseModel):
    success: bool = True
    message: Optional[str] = None
    results: UnifiedSearchResult = UnifiedSearchResult()

@router.get("/web", response_model=WebSearchResponse)
async def web_search(
    query: str = Query(..., description="Search query"),
    num_results: int = Query(5, description="Number of results to return", ge=1, le=10),
    _current_user: dict = Depends(get_current_user)  # noqa: F841 - Required for auth but unused
) -> WebSearchResponse:
    """
    Perform a web search using OpenAI's web search tool.
    """
    try:
        # Initialize OpenAI client
        client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

        # Create a temporary assistant with function calling capability
        # We'll use a function to simulate web search since web_search tool is not available
        assistant = client.beta.assistants.create(
            name="Web Search Assistant",
            instructions="You are a web search assistant. Your only job is to search the web and return results.",
            model="pt-4o-search-preview-2025-03-11",
            tools=[{
                "type": "function",
                "function": {
                    "name": "search_web",
                    "description": "Search the web for information",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "query": {
                                "type": "string",
                                "description": "The search query"
                            }
                        },
                        "required": ["query"]
                    }
                }
            }]
        )

        # Create a thread
        thread = client.beta.threads.create()

        # Add a message to the thread
        client.beta.threads.messages.create(
            thread_id=thread.id,
            role="user",
            content=f"Search the web for: {query}. Return exactly {num_results} results in markdown format with title, URL, and a brief snippet for each result."
        )

        # Run the assistant
        run = client.beta.threads.runs.create(
            thread_id=thread.id,
            assistant_id=assistant.id
        )

        # Wait for the run to require action or complete
        while run.status not in ["requires_action", "completed"]:
            run = client.beta.threads.runs.retrieve(
                thread_id=thread.id,
                run_id=run.id
            )
            if run.status in ["failed", "cancelled", "expired"]:
                raise HTTPException(status_code=500, detail=f"Run failed with status: {run.status}")

            # Add a small delay to avoid hitting rate limits
            import time
            time.sleep(0.5)

        # Handle function calling if required
        if run.status == "requires_action":
            # Get the required action
            required_action = run.required_action
            if required_action and required_action.type == "submit_tool_outputs":
                # Process each tool call
                tool_outputs = []
                for tool_call in required_action.submit_tool_outputs.tool_calls:
                    if tool_call.function.name == "search_web":
                        # Simulate web search results
                        search_results = [
                            {
                                "title": f"Result 1 for {query}",
                                "url": "https://example.com/result1",
                                "snippet": f"This is a sample result for the query '{query}'. It contains relevant information about the topic."
                            },
                            {
                                "title": f"Result 2 for {query}",
                                "url": "https://example.com/result2",
                                "snippet": f"Another sample result for '{query}'. This provides additional context and information."
                            },
                            {
                                "title": f"Result 3 for {query}",
                                "url": "https://example.com/result3",
                                "snippet": f"A third sample result for '{query}'. This covers different aspects of the topic."
                            },
                            {
                                "title": f"Result 4 for {query}",
                                "url": "https://example.com/result4",
                                "snippet": f"A fourth sample result for '{query}'. This provides more detailed information."
                            },
                            {
                                "title": f"Result 5 for {query}",
                                "url": "https://example.com/result5",
                                "snippet": f"A fifth sample result for '{query}'. This covers additional perspectives."
                            }
                        ]

                        # Limit to requested number of results
                        search_results = search_results[:num_results]

                        # Format as markdown
                        markdown_results = "\n\n".join([f"## {result['title']}\n{result['url']}\n{result['snippet']}" for result in search_results])

                        # Add to tool outputs
                        tool_outputs.append({
                            "tool_call_id": tool_call.id,
                            "output": markdown_results
                        })

                # Submit the tool outputs
                # Use type: ignore to suppress the type error
                # In a production environment, we would use the proper ToolOutput type
                run = client.beta.threads.runs.submit_tool_outputs(
                    thread_id=thread.id,
                    run_id=run.id,
                    tool_outputs=tool_outputs  # type: ignore
                )

                # Wait for the run to complete
                while run.status != "completed":
                    run = client.beta.threads.runs.retrieve(
                        thread_id=thread.id,
                        run_id=run.id
                    )
                    if run.status in ["failed", "cancelled", "expired"]:
                        raise HTTPException(status_code=500, detail=f"Run failed with status: {run.status}")

                    # Add a small delay to avoid hitting rate limits
                    time.sleep(0.5)

        # We don't need to get the messages since we're using simulated results
        # But in a real implementation, we would parse the assistant's response here

        # Extract the results from the assistant's response
        results = []

        # In development mode, return simulated search results
        # This is a workaround for the lack of web search capability in the OpenAI API
        search_results = [
            {
                "title": f"Result 1 for {query}",
                "url": "https://example.com/result1",
                "snippet": f"This is a sample result for the query '{query}'. It contains relevant information about the topic."
            },
            {
                "title": f"Result 2 for {query}",
                "url": "https://example.com/result2",
                "snippet": f"Another sample result for '{query}'. This provides additional context and information."
            },
            {
                "title": f"Result 3 for {query}",
                "url": "https://example.com/result3",
                "snippet": f"A third sample result for '{query}'. This covers different aspects of the topic."
            },
            {
                "title": f"Result 4 for {query}",
                "url": "https://example.com/result4",
                "snippet": f"A fourth sample result for '{query}'. This provides more detailed information."
            },
            {
                "title": f"Result 5 for {query}",
                "url": "https://example.com/result5",
                "snippet": f"A fifth sample result for '{query}'. This covers additional perspectives."
            }
        ]

        # Limit to requested number of results
        search_results = search_results[:num_results]

        # Convert to SearchResult objects
        for result in search_results:
            results.append(SearchResult(
                title=result["title"],
                url=result["url"],
                snippet=result["snippet"]
            ))

        # Clean up - delete the assistant
        client.beta.assistants.delete(assistant.id)

        # Limit to requested number of results
        results = results[:num_results]

        return WebSearchResponse(
            success=True,
            results=results
        )

    except Exception as e:
        logger.error(f"Web search error: {str(e)}", exc_info=True)
        return WebSearchResponse(
            success=False,
            message=f"Error performing web search: {str(e)}"
        )

@router.get("/all", response_model=UnifiedSearchResponse)
async def unified_search(
    q: str = Query(..., description="Search query"),
    limit: int = Query(5, description="Number of results to return per entity type", ge=1, le=10),
    context: Dict[str, Any] = Depends(get_user_context)
) -> UnifiedSearchResponse:
    """
    Perform a unified search across tickets, companies, contacts, and members.
    Returns categorized results from multiple sources based on the query.
    Uses fuzzy matching to find the closest matches.
    """
    try:
        # Run searches individually to avoid type errors
        ticket_results = await search_tickets_tool_impl(search_term=q, limit=limit)
        company_results = await find_company_impl(company_name_or_identifier=q)
        
        # For contacts, use a sentinel value (0) instead of None
        contact_results = await find_contact_impl(contact_name=q, company_id=0)
        
        # Member search is synchronous
        member_results = find_member(member_identifier=q)

        # Prepare the response
        tickets = []
        if ticket_results.success and ticket_results.tickets:
            tickets = [{
                "id": ticket.ticket_id,
                "summary": ticket.summary,
                "status": ticket.status,
                "company": ticket.company_name,
                "type": "ticket"
            } for ticket in ticket_results.tickets]

        companies = []
        if company_results.success and company_results.found and company_results.company:
            companies = [{
                "id": company_results.company.get("id"),
                "name": company_results.company.get("name"),
                "identifier": company_results.company.get("identifier"),
                "type": "company"
            }]
        
        # If no exact company match but query is at least 2 chars, try to find similar companies
        elif q and len(q) >= 2:
            # This would be replaced with a proper fuzzy search in production
            # For now, we'll simulate it by searching for companies that contain the query
            try:
                # Log the search attempt
                logger.info(f"Performing fuzzy company search for: '{q}'")
                
                # Use the manage_api_client directly
                from app.cw_tools.api_client import manage_api_client
                
                if manage_api_client:
                    # Search for companies that contain the query string
                    companies_response = await manage_api_client.company.companies.get(
                        params={"conditions": f"name contains '{q}' or identifier contains '{q}'", "pageSize": limit, "orderBy": "name asc"}
                    )
                    
                    # Process the response
                    companies_data = companies_response
                    if companies_data:
                        companies = [{
                            "id": company.get("id"),
                            "name": company.get("name"),
                            "identifier": company.get("identifier"),
                            "type": "company"
                        } for company in companies_data]
            except Exception as company_error:
                logger.warning(f"Error in fuzzy company search: {str(company_error)}")

        contacts = []
        if contact_results.success and contact_results.found and contact_results.contact:
            # Single contact result
            contacts = [{
                "id": contact_results.contact.get("id"),
                "name": contact_results.contact.get("name"),
                "company": contact_results.contact.get("company", {}).get("name"),
                "type": "contact"
            }]
        
        # If no exact contact match but query is at least 2 chars, try to find similar contacts
        elif q and len(q) >= 2:
            # This would be replaced with a proper fuzzy search in production
            try:
                # Log the search attempt
                logger.info(f"Performing fuzzy contact search for: '{q}'")
                
                # Use the manage_api_client directly
                from app.cw_tools.api_client import manage_api_client
                
                if manage_api_client:
                    # Build conditions for the query
                    conditions = f"firstName contains '{q}' or lastName contains '{q}' or fullName contains '{q}'"
                    
                    # Search for contacts that contain the query string
                    contacts_response = await manage_api_client.company.contacts.get(
                        params={"conditions": conditions, "pageSize": limit, "orderBy": "lastName asc"}
                    )
                    
                    # Process the response
                    contacts_data = contacts_response
                    if contacts_data:
                        contacts = [{
                            "id": contact.get("id"),
                            "name": f"{contact.get('firstName', '')} {contact.get('lastName', '')}".strip(),
                            "company": contact.get("company", {}).get("name"),
                            "type": "contact"
                        } for contact in contacts_data]
            except Exception as contact_error:
                logger.warning(f"Error in fuzzy contact search: {str(contact_error)}")

        members = []
        if member_results.success and member_results.found and member_results.member:
            members = [{
                "id": member_results.member.get("id"),
                "name": member_results.member.get("name") or member_results.member.get("identifier"),
                "type": "member"
            }]
        
        # If no exact member match but query is at least 2 chars, try to find similar members
        elif q and len(q) >= 2:
            try:
                # Log the search attempt
                logger.info(f"Performing fuzzy member search for: '{q}'")
                
                # Use the manage_api_client directly
                from app.cw_tools.api_client import manage_api_client
                
                if manage_api_client:
                    # Search for members that contain the query string
                    members_response = await manage_api_client.system.members.get(
                        params={"conditions": f"identifier contains '{q}' or firstName contains '{q}' or lastName contains '{q}'", "pageSize": limit, "orderBy": "lastName asc"}
                    )
                    
                    # Process the response
                    members_data = members_response
                    if members_data:
                        members = [{
                            "id": member.get("id"),
                            "name": f"{member.get('firstName', '')} {member.get('lastName', '')}".strip() or member.get("identifier"),
                            "type": "member"
                        } for member in members_data]
            except Exception as member_error:
                logger.warning(f"Error in fuzzy member search: {str(member_error)}")

        return UnifiedSearchResponse(
            success=True,
            results=UnifiedSearchResult(
                tickets=tickets,
                companies=companies,
                contacts=contacts,
                members=members
            )
        )

    except Exception as e:
        logger.error(f"Unified search error: {str(e)}", exc_info=True)
        return UnifiedSearchResponse(
            success=False,
            message=f"Error performing unified search: {str(e)}"
        )

@router.get("/companies", response_model=FindCompanyResult)
async def search_companies(
    q: str = Query(..., description="Search query"),
    limit: int = Query(5, description="Number of results to return", ge=1, le=10),
    context: Dict[str, Any] = Depends(get_user_context)
):
    """
    Search for companies by name or identifier.
    Uses fuzzy matching to find the closest matches.
    """
    try:
        # First try exact match
        company_result = await find_company_impl(company_name_or_identifier=q)
        
        # If exact match found, return it
        if company_result.success and company_result.found and company_result.company:
            return company_result
        
        # If no exact match but query is at least 2 chars, try fuzzy search
        if q and len(q) >= 2:
            try:
                # Log the search attempt
                logger.info(f"Performing company search for: '{q}'")
                
                # Use the manage_api_client directly
                from app.cw_tools.api_client import manage_api_client
                
                if manage_api_client:
                    # Search for companies that contain the query string
                    companies_response = await manage_api_client.company.companies.get(
                        params={"conditions": f"name contains '{q}' or identifier contains '{q}'", "pageSize": limit, "orderBy": "name asc"}
                    )
                    
                    # Process the response
                    companies_data = companies_response
                    if companies_data and len(companies_data) > 0:
                        # Return the first company as the main result
                        return FindCompanyResult(
                            success=True,
                            found=True,
                            company=companies_data[0]
                        )
            except Exception as e:
                logger.warning(f"Error in fuzzy company search: {str(e)}")
        
        # If we get here, no matches were found
        return FindCompanyResult(
            success=True,
            found=False,
            message="No matching companies found"
        )
    
    except Exception as e:
        logger.error(f"Company search error: {str(e)}", exc_info=True)
        return FindCompanyResult(
            success=False,
            found=False,
            message=f"Error searching for companies: {str(e)}"
        )

@router.get("/contacts", response_model=FindContactResult)
async def search_contacts(
    q: str = Query(..., description="Search query"),
    company_id: Optional[int] = Query(None, description="Optional company ID to filter contacts"),
    limit: int = Query(5, description="Number of results to return", ge=1, le=10),
    context: Dict[str, Any] = Depends(get_user_context)
):
    """
    Search for contacts by name.
    Optionally filter by company ID.
    Uses fuzzy matching to find the closest matches.
    """
    try:
        # First try exact match with company_id if provided
        if company_id is not None:
            contact_result = await find_contact_impl(contact_name=q, company_id=company_id)
            
            # If exact match found, return it
            if contact_result.success and contact_result.found and contact_result.contact:
                return contact_result
        else:
            # If no company_id provided, use a sentinel value (0)
            contact_result = await find_contact_impl(contact_name=q, company_id=0)
            
            # If exact match found, return it
            if contact_result.success and contact_result.found and contact_result.contact:
                return contact_result
        
        # If no exact match but query is at least 2 chars, try fuzzy search
        if q and len(q) >= 2:
            try:
                # Build conditions for the query
                conditions = f"firstName contains '{q}' or lastName contains '{q}' or fullName contains '{q}'"
                if company_id:
                    conditions += f" and company/id={company_id}"
                
                # Log the search attempt
                logger.info(f"Performing contact search for: '{q}' with conditions: {conditions}")
                
                # Use the manage_api_client directly
                from app.cw_tools.api_client import manage_api_client
                
                if manage_api_client:
                    # Search for contacts that match the conditions
                    contacts_response = await manage_api_client.company.contacts.get(
                        params={"conditions": conditions, "pageSize": limit, "orderBy": "lastName asc"}
                    )
                    
                    # Process the response
                    contacts_data = contacts_response
                    if contacts_data and len(contacts_data) > 0:
                        # Return the first contact as the main result
                        return FindContactResult(
                            success=True,
                            found=True,
                            contact=contacts_data[0]
                        )
            except Exception as e:
                logger.warning(f"Error in fuzzy contact search: {str(e)}")
        
        # If we get here, no matches were found
        return FindContactResult(
            success=True,
            found=False,
            message="No matching contacts found"
        )
    
    except Exception as e:
        logger.error(f"Contact search error: {str(e)}", exc_info=True)
        return FindContactResult(
            success=False,
            found=False,
            message=f"Error searching for contacts: {str(e)}"
        )

@router.get("/members", response_model=FindMemberResult)
async def search_members(
    q: str = Query(..., description="Search query"),
    limit: int = Query(5, description="Number of results to return", ge=1, le=10),
    context: Dict[str, Any] = Depends(get_user_context)
):
    """
    Search for members by identifier, first name, or last name.
    Uses fuzzy matching to find the closest matches.
    """
    try:
        # First try exact match using the function_tool
        member_result = find_member(member_identifier=q)
        
        # If exact match found, return it
        if member_result.success and member_result.found and member_result.member:
            return member_result
        
        # If no exact match but query is at least 2 chars, try fuzzy search
        if q and len(q) >= 2:
            try:
                # Log the search attempt
                logger.info(f"Performing member search for: '{q}'")
                
                # Use the manage_api_client directly
                from app.cw_tools.api_client import manage_api_client
                
                if manage_api_client:
                    # Search for members that contain the query string
                    members_response = await manage_api_client.system.members.get(
                        params={"conditions": f"identifier contains '{q}' or firstName contains '{q}' or lastName contains '{q}'", "pageSize": limit, "orderBy": "lastName asc"}
                    )
                    
                    # Process the response
                    members_data = members_response
                    if members_data and len(members_data) > 0:
                        # Return the first member as the main result
                        return FindMemberResult(
                            success=True,
                            found=True,
                            member=members_data[0]
                        )
            except Exception as e:
                logger.warning(f"Error in fuzzy member search: {str(e)}")
        
        # If we get here, no matches were found
        return FindMemberResult(
            success=True,
            found=False,
            message="No matching members found"
        )
    
    except Exception as e:
        logger.error(f"Member search error: {str(e)}", exc_info=True)
        return FindMemberResult(
            success=False,
            found=False,
            message=f"Error searching for members: {str(e)}"
        )
</file>

<file path="routes/suggestions.py">
from fastapi import APIRouter, Depends, HTTPException, Query # type: ignore
import logging
import json
import re
from typing import Dict, Any, Optional, Type # Added Type

# Define Runner with default type hint before try block
Runner: Optional[Type[Any]] = None
# Import SDK components
try:
    from agents import Runner as _SdkRunner # type: ignore
    Runner = _SdkRunner # Assign actual type if import succeeds
    _HAS_AGENT_SDK = True
except ImportError:
    # Runner remains None if import fails
    _HAS_AGENT_SDK = False
    logging.warning("OpenAI Agents SDK ('agents' module) not found. Suggestions will be disabled.")

from app.cw_tools import ToolContext, CwMemberInfo
from app.routes.api import get_user_context
import app.agent as agent_module
# Removed unused import: import app.config as config

logger = logging.getLogger(__name__)

router = APIRouter()

@router.get("/suggestions")
async def get_suggestions(
    context: str = Query("general", description="Entity context (ticket, company, general)"),
    ticket_id: Optional[int] = None,
    company_id: Optional[int] = None,
    active_tab: Optional[str] = None,
    user: Dict[str, Any] = Depends(get_user_context)
):
    """
    Generate context-aware suggestions for user actions based on the current UI state.
    """
    agent_instance = agent_module.get_connectwise_agent()
    if not agent_instance or not _HAS_AGENT_SDK or Runner is None:
        raise HTTPException(status_code=500, detail="Failed to initialize agent.")

    # Create tool context with minimal info needed
    tool_context = ToolContext()
    tool_context.cw_member_info = CwMemberInfo(
        identifier=user.get("email", "unknown"),
        name=user.get("name", "Unknown User")
    )

    # Add entity-specific context
    entity_specific_context = {}

    if context == "ticket" and ticket_id:
        try:
            # Get ticket details
            # Import the function here to avoid circular imports
            from app.cw_tools.cw_tools_main import get_ticket_details_for_api
            ticket_details = get_ticket_details_for_api(ticket_id)

            # Get recent activity (last 7 days)
            from app.cw_tools.activity import get_ticket_activity_impl
            activity_result = get_ticket_activity_impl(ticket_id, days=7)

            # Combined context for ticket
            entity_specific_context = {
                "ticket_id": ticket_id,
                "details": ticket_details,
                "activity": activity_result.get("activity", []),
                "active_tab": active_tab or "details"
            }
        except Exception as e:
            logger.error(f"Error getting ticket context for suggestions: {e}")

    elif context == "company" and company_id:
        try:
            # Get company details - implementation depends on available tools
            # company_details = await cw.get_company_details_impl(company_id)

            # Get recent tickets for company - implementation depends on available tools
            # company_tickets = await cw.get_company_tickets_impl(company_id, limit=5)

            # Combined context for company
            entity_specific_context = {
                "company_id": company_id,
                # "details": company_details,
                # "recent_tickets": company_tickets,
                "active_tab": active_tab or "details"
            }
        except Exception as e:
            logger.error(f"Error getting company context for suggestions: {e}")

    # Use a system prompt specifically for generating suggestions
    suggestion_prompt = f"""
    Based on the following context, suggest 2-3 specific actions the user might want to take next.

    USER CONTEXT:
    - User role: {user.get("name", "Technician")}
    - Current view: {context} {f"#{ticket_id}" if ticket_id else f"#{company_id}" if company_id else ""}
    - Active tab: {active_tab or "details"}

    {f"TICKET CONTEXT:\n- Summary: {entity_specific_context.get('details', {}).get('summary', 'N/A')}\n- Status: {entity_specific_context.get('details', {}).get('status', 'N/A')}\n- Company: {entity_specific_context.get('details', {}).get('company_name', 'N/A')}" if context == "ticket" else ""}

    Return JSON array with 2-3 suggestions:
    [{{
      "id": "unique_id",
      "title": "Short action name",
      "description": "Brief explanation why",
      "type": "action_type", // add_time, status_change, add_note, etc.
      "params": {{ // parameters needed for action
        // action-specific parameters
      }}
    }}]

    Be specific and actionable, suggesting relevant next steps based on ticket status, recent activity, and urgency.
    For tickets, consider SLA, status, recent notes, priority.
    """

    try:
        # Use a quick, non-streaming request to get suggestions
        # Instantiate and use the Runner
        runner = Runner()
        response = await runner.run(agent_instance, suggestion_prompt, context=tool_context)

        # Parse the JSON response
        try:
            # Assuming response is RunResult, access final_output
            suggestions_text = response.final_output if response and hasattr(response, 'final_output') else None
            extracted_json = None
            if suggestions_text:
                logger.debug(f"Raw suggestions text: {suggestions_text}")
                # Try to extract JSON from markdown code fence
                match = re.search(r"```(?:json)?\n(.+?)\n```", suggestions_text, re.DOTALL)
                if match:
                    extracted_json = match.group(1).strip()
                    logger.debug(f"Extracted JSON from code fence: {extracted_json[:100]}...")
                else:
                    # Try to find any JSON array in the text
                    match = re.search(r'\[\s*\{[^\{\}]*\}\s*(?:,\s*\{[^\{\}]*\}\s*)*\]', suggestions_text, re.DOTALL)
                    if match:
                        extracted_json = match.group(0).strip()
                        logger.debug(f"Extracted JSON array: {extracted_json[:100]}...")
                    else:
                        # Fallback: assume the whole output might be JSON if no fence found
                        extracted_json = suggestions_text.strip()
                        logger.debug(f"Using full text as JSON: {extracted_json[:100]}...")

            if not extracted_json:
                logger.error("Agent produced no output or empty JSON for suggestions.")
                # Return empty suggestions instead of raising an error
                suggestions = []
            else:
                try:
                    # Clean up the JSON string before parsing
                    # Remove any trailing commas in arrays/objects which are invalid JSON
                    cleaned_json = re.sub(r',\s*([\]\}])', r'\1', extracted_json)
                    # Remove any comments (// style)
                    cleaned_json = re.sub(r'\s*//.*', '', cleaned_json)
                    # Try to parse the JSON
                    suggestions = json.loads(cleaned_json)
                    logger.debug(f"Successfully parsed JSON: {type(suggestions)}")
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to parse JSON: {e}. Raw text: {extracted_json[:277]}...")
                    # Provide more detailed error information
                    error_position = e.pos
                    error_context = extracted_json[max(0, error_position-20):min(len(extracted_json), error_position+20)]
                    logger.error(f"Error context: ...{error_context}... (position {error_position})")
                    suggestions = []

            # Validate the expected format
            if not isinstance(suggestions, list):
                logger.warning(f"Unexpected suggestions format: {type(suggestions)}")
                suggestions = []
            else:
                # Validate each suggestion has the required fields
                valid_suggestions = []
                for i, suggestion in enumerate(suggestions):
                    if not isinstance(suggestion, dict):
                        logger.warning(f"Suggestion {i} is not a dictionary: {suggestion}")
                        continue

                    # Check for required fields
                    if 'id' not in suggestion or 'title' not in suggestion:
                        logger.warning(f"Suggestion {i} missing required fields: {suggestion}")
                        continue

                    valid_suggestions.append(suggestion)

                suggestions = valid_suggestions
        except Exception as e:
            logger.error(f"Failed to parse suggestions JSON: {e}")
            suggestions = []

        return {
            "success": True,
            "context": context,
            "entity_id": ticket_id or company_id,
            "suggestions": suggestions
        }
    except Exception as e:
        logger.error(f"Error generating suggestions: {e}")
        return {
            "success": False,
            "message": "Failed to generate suggestions",
            "suggestions": []
        }

@router.get("/smart-prompts")
async def get_smart_prompts(
    context: str = Query("general", description="Entity context (ticket, company, general)"),
    ticket_id: Optional[int] = None,
    company_id: Optional[int] = None,
    user: Dict[str, Any] = Depends(get_user_context)
):
    """
    Generate context-aware prompt suggestions based on the current UI state.
    """
    agent_instance = agent_module.get_connectwise_agent()
    if not agent_instance or not _HAS_AGENT_SDK or Runner is None:
        raise HTTPException(status_code=500, detail="Failed to initialize agent.")

    # Create minimal context
    tool_context = ToolContext()
    tool_context.cw_member_info = CwMemberInfo(
        identifier=user.get("email", "unknown"),
        name=user.get("name", "Unknown User")
    )

    # Build prompt based on context
    system_prompt = f"""
    Generate 3-5 useful prompt suggestions for the AI assistant based on the current context.

    USER CONTEXT:
    - User role: {user.get("name", "Technician")}
    - Current view: {context} {f"#{ticket_id}" if ticket_id else f"#{company_id}" if company_id else ""}

    """

    # Add more context for tickets
    if context == "ticket" and ticket_id:
        try:
            # Get basic ticket info
            # Import the function here to avoid circular imports
            from app.cw_tools.cw_tools_main import get_ticket_details_for_api
            ticket_details = get_ticket_details_for_api(ticket_id)

            system_prompt += f"""
            TICKET CONTEXT:
            - Summary: {ticket_details.get('summary', 'N/A')}
            - Status: {ticket_details.get('status', 'N/A')}
            - Company: {ticket_details.get('company_name', 'N/A')}

            Return an array of 3-5 useful, specific prompts related to this ticket.
            Prompts should be short commands or questions the user could ask the AI about this ticket.
            Each prompt should help accomplish common tasks for tickets in this status.
            """
        except Exception as e:
            logger.error(f"Error getting ticket context for smart prompts: {e}")

    # General context fallback
    else:
        system_prompt += """
        Return an array of 3-5 useful, specific prompts related to general ConnectWise tasks.
        Focus on common daily tasks like finding tickets, creating tickets, or getting summaries of work.
        """

    system_prompt += """
    Return a simple JSON array of strings:
    ["prompt 1", "prompt 2", "prompt 3"]
    """

    try:
        # Use a quick, non-streaming request to get prompt suggestions
        # Instantiate and use the Runner
        runner = Runner()
        response = await runner.run(agent_instance, system_prompt, context=tool_context)

        # Parse the JSON response
        try:
            # Assuming response is RunResult, access final_output
            prompts_text = response.final_output if response and hasattr(response, 'final_output') else None
            extracted_json = None
            if prompts_text:
                logger.debug(f"Raw prompts text: {prompts_text}")
                # Try to extract JSON from markdown code fence
                match = re.search(r"```(?:json)?\n(.+?)\n```", prompts_text, re.DOTALL)
                if match:
                    extracted_json = match.group(1).strip()
                    logger.debug(f"Extracted JSON from code fence: {extracted_json[:100]}...")
                else:
                    # Try to find any JSON array in the text
                    match = re.search(r'\[\s*"[^"]*"\s*(?:,\s*"[^"]*"\s*)*\]', prompts_text, re.DOTALL)
                    if match:
                        extracted_json = match.group(0).strip()
                        logger.debug(f"Extracted JSON array: {extracted_json[:100]}...")
                    else:
                        # Fallback: assume the whole output might be JSON if no fence found
                        extracted_json = prompts_text.strip()
                        logger.debug(f"Using full text as JSON: {extracted_json[:100]}...")

            if not extracted_json:
                logger.error("Agent produced no output or empty JSON for smart prompts.")
                raise ValueError("Agent produced no output for smart prompts.")

            try:
                # Clean up the JSON string before parsing
                # Remove any trailing commas in arrays which are invalid JSON
                cleaned_json = re.sub(r',\s*(\])', r'\1', extracted_json)
                # Try to parse the JSON
                prompts = json.loads(cleaned_json)
                logger.debug(f"Successfully parsed JSON: {type(prompts)}")
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse JSON: {e}. Raw text: {extracted_json[:100]}...")
                # Provide more detailed error information
                error_position = e.pos
                error_context = extracted_json[max(0, error_position-20):min(len(extracted_json), error_position+20)]
                logger.error(f"Error context: ...{error_context}... (position {error_position})")
                raise

            # Validate the expected format
            if not isinstance(prompts, list):
                logger.warning(f"Unexpected prompts format: {type(prompts)}")
                prompts = [
                    "Find my open tickets",
                    "Create a new ticket",
                    "Show recent activity"
                ]
            else:
                # Validate each prompt is a string
                valid_prompts = []
                for i, prompt in enumerate(prompts):
                    if not isinstance(prompt, str):
                        logger.warning(f"Prompt {i} is not a string: {prompt}")
                        continue
                    valid_prompts.append(prompt)

                if valid_prompts:
                    prompts = valid_prompts
                else:
                    # If no valid prompts, use fallbacks
                    prompts = [
                        "Find my open tickets",
                        "Create a new ticket",
                        "Show recent activity"
                    ]
        except Exception as e:
            logger.error(f"Failed to parse prompts JSON: {e}")
            # Fallback prompts based on context
            if context == "ticket":
                prompts = [
                    f"Summarize ticket #{ticket_id}",
                    f"What's the status of ticket #{ticket_id}?",
                    f"Draft a customer update for ticket #{ticket_id}",
                    f"Analyze ticket #{ticket_id} and suggest next steps",
                    f"Review ticket #{ticket_id} and determine if it can be closed",
                    f"Analyze the timeline of ticket #{ticket_id} and identify patterns"
                ]
            else:
                prompts = [
                    "Find my open tickets",
                    "Create a new ticket",
                    "Show recent activity"
                ]

        return {
            "success": True,
            "context": context,
            "entity_id": ticket_id or company_id,
            "prompts": prompts
        }
    except Exception as e:
        logger.error(f"Error generating smart prompts: {e}")
        return {
            "success": False,
            "message": "Failed to generate smart prompts",
            "prompts": [
                "Find my open tickets",
                "Create a new ticket",
                "Show recent activity"
            ]
        }
</file>

<file path="user_context.py">
"""
User Context Provider

This module provides enhanced user context for the AI agent, ensuring it always
knows the identity of the user it's talking to and their relevant ConnectWise information.
"""

import logging
from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta

from app.cw_tools.tool_adapter import tool_adapter
from app.context import current_tool_context

logger = logging.getLogger(__name__)

class UserContextProvider:
    """Provider for enhanced user context."""
    
    def __init__(self):
        """Initialize the user context provider."""
        self._cache = {}
        self._cache_expiry = {}
        self._cache_ttl = 300  # 5 minutes
    
    def get_user_context(self, member_identifier: str) -> Dict[str, Any]:
        """
        Get enhanced user context for a member.
        
        Args:
            member_identifier: The ConnectWise member identifier
            
        Returns:
            A dictionary containing enhanced user context
        """
        # Check cache first
        cache_key = f"user_context_{member_identifier}"
        if cache_key in self._cache and datetime.now() < self._cache_expiry.get(cache_key, datetime.min):
            logger.info(f"Using cached user context for {member_identifier}")
            return self._cache[cache_key]
        
        logger.info(f"Building enhanced user context for {member_identifier}")
        
        # Get member details
        member_result = tool_adapter.call_impl("find_member", member_identifier=member_identifier)
        
        if not member_result.success or not member_result.found:
            logger.warning(f"Failed to get member details for {member_identifier}: {member_result.message}")
            return {
                "member_identifier": member_identifier,
                "error": f"Failed to get member details: {member_result.message}"
            }
        
        # Extract member details
        member_data = member_result.member
        
        # Create enhanced context
        enhanced_context = {
            "member_id": getattr(member_data, "id", None),
            "member_identifier": member_identifier,
            "member_name": getattr(member_data, "name", ""),
            "member_email": getattr(member_data, "email", ""),
            "role": getattr(member_data, "title", ""),
            "last_updated": datetime.now().isoformat(),
        }
        
        # Get recent tickets assigned to this member
        try:
            recent_tickets_result = tool_adapter.call_impl(
                "search_tickets_tool", 
                assigned_to=member_identifier,
                days_range=7,
                limit=10
            )
            
            if recent_tickets_result.success and recent_tickets_result.tickets:
                enhanced_context["recent_tickets"] = [
                    {
                        "ticket_id": ticket.ticket_id,
                        "summary": ticket.summary,
                        "status": ticket.status,
                        "board_name": ticket.board_name,
                        "company_name": ticket.company_name,
                        "date_entered": ticket.date_entered
                    }
                    for ticket in recent_tickets_result.tickets
                ]
                
                # Count tickets by status
                status_counts = {}
                for ticket in recent_tickets_result.tickets:
                    status = ticket.status
                    status_counts[status] = status_counts.get(status, 0) + 1
                
                enhanced_context["ticket_status_counts"] = status_counts
            else:
                enhanced_context["recent_tickets"] = []
                enhanced_context["ticket_status_counts"] = {}
        except Exception as e:
            logger.warning(f"Failed to get recent tickets for {member_identifier}: {e}")
            enhanced_context["recent_tickets"] = []
            enhanced_context["ticket_status_counts"] = {}
        
        # Get recent time entries
        try:
            # This would need to be implemented as a new tool
            # For now, we'll leave it as an empty list
            enhanced_context["recent_time_entries"] = []
        except Exception as e:
            logger.warning(f"Failed to get recent time entries for {member_identifier}: {e}")
            enhanced_context["recent_time_entries"] = []
        
        # Cache the result
        self._cache[cache_key] = enhanced_context
        self._cache_expiry[cache_key] = datetime.now() + timedelta(seconds=self._cache_ttl)
        
        return enhanced_context
    
    def clear_cache(self, member_identifier: Optional[str] = None):
        """
        Clear the cache for a specific member or all members.
        
        Args:
            member_identifier: The ConnectWise member identifier, or None to clear all
        """
        if member_identifier:
            cache_key = f"user_context_{member_identifier}"
            if cache_key in self._cache:
                del self._cache[cache_key]
                del self._cache_expiry[cache_key]
                logger.info(f"Cleared cache for {member_identifier}")
        else:
            self._cache.clear()
            self._cache_expiry.clear()
            logger.info("Cleared all user context cache")

# Create a singleton instance
user_context_provider = UserContextProvider()

def get_enhanced_user_context(member_identifier: str) -> Dict[str, Any]:
    """
    Get enhanced user context for a member.
    
    Args:
        member_identifier: The ConnectWise member identifier
        
    Returns:
        A dictionary containing enhanced user context
    """
    return user_context_provider.get_user_context(member_identifier)

def clear_user_context_cache(member_identifier: Optional[str] = None):
    """
    Clear the user context cache.
    
    Args:
        member_identifier: The ConnectWise member identifier, or None to clear all
    """
    user_context_provider.clear_cache(member_identifier)

def get_current_user_context() -> Optional[Dict[str, Any]]:
    """
    Get the current user context from the tool context.
    
    Returns:
        The current user context, or None if not available
    """
    context = current_tool_context.get()
    if context and context.cw_member_info and context.cw_member_info.identifier:
        return get_enhanced_user_context(context.cw_member_info.identifier)
    return None
</file>

</files>
